<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Article PUBLIC "-//OASIS//DTD Article//EN" "article.dtd" []>
<Article>
<ArticleTitle>
<ParaX>
THE <Index><I_Body>ConPro</I_Body><I_Superscript>2</I_Superscript></Index> BOOK</ParaX>
</ArticleTitle>
<Para>
Rule-Based Mapping of an Imperative Programming Language to RTL for Higher-Level-Synthesis Using Communicating Sequential Processes</Para>
<Author>
<ParaX>
Dr. Stefan Bosse</ParaX>
</Author>
<Address>
<ParaX>
BSSLAB <Symbol>&#xb7;</Symbol> Independent Research Laboratory <Symbol>&#xb7;</Symbol> Bremen </ParaX>
</Address>
<Date>
<Index><I_Body>ConPro</I_Body><I_Superscript>2</I_Superscript></Index> <Symbol>&#xb7;</Symbol> V2.1 <Symbol>&#xb7;</Symbol> 22.1.2010 </Date>
<Section Id = "S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Introduction and Overview</SectionTitle>
<Para>
The ConPro programming language, a new enhanced  imperative programming language is mapped to Register-Transfer-Logic using a  higher-level-synthesis approach
performed by the synthesis tool ConPro. In contrast to other approaches using modified existing software languages like C, this language is designed from
scratch providing a consistent model for  both hardware design and software programming. The programming model and the language provide parallelism on control
path level using a multi-process model with communicating sequential processes (CSP), and on data path level using bounded program blocks. Each process is
mapped to a Finite-State-Machine and is executed concurrently. Additionally, program blocks can be parameterized and can control the synthesis process
(scheduling and allocation). Synthesis is  based on a non-iterative, multi-level and constraint selective rule-set based  approach,  rather than  on a
traditional constrained iterative scheduling and allocation approach.  Required  interprocess communication is provided by a set of primitives, entirely mapped
to hardware, already established in concurrent softwareprogramming (multi-threading), implemented with an abstract data type object model and method-based
access. It is demonstrated that this synthesis approach is efficient and stable enough to create complex circuits reaching the million gates boundary.</Para>
<Para>
</Para>
</Section>
<Section Id = "S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Higher-Level-Synthesis</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
<Section Id = "S2S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Multi-Process-Architecture</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S2S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Scheduling &amp; Allocation</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S2S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Rule Based Scheduling</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Language Specification</SectionTitle>
<Section Id = "S3S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Introduction</SectionTitle>
<Para>
The ConPro programming language consist of two classes of statements: 1. process instructions mapped to FSM/RTL, and 2. type, and object definitions. It is an
imperative programming language with strong type checking. Imperative programs which describe algorithms that execute sequentially from one statement to the
next, are familiar to most programmers. But beneath algorithmic statements the programming language must provide some kind of relation to the hardware circuit
synthesized from the programming level.</Para>
<Para>
The syntax and semantics of the programming language is consistently designed and mostly self-explanatory, without cryptic extensions, required in most hardware
C-derivates, like Handel-C or System-C, providing easy access to digital circuit development, also for software programmer.</Para>
<Para>
Additionally there is a requirement to get full programmability of the design activities themselves, that means of the synthesis process, too <XRef IDRef =
"B1"></XRef>,  implemented here with constrained rules on block level, providing fine-grained control of the synthesis process. The synthesis process can be
parameterized by the programmer globally or locally on instruction block level, for example scheduling and allocation.</Para>
<Para>
The set of objects is splitted into two classes: 1. data storage type set <Symbol>&#xc2;</Symbol>, and 2. abstract data object type set (ADTO)
<Symbol>&#x51;</Symbol>, with a subset of  the IPC objects <Symbol>&#xc1;</Symbol>. Though it is a traditional imperative programming language, it features true
parallel programming both in control and data path, explicitly modelled by the programmer. </Para>
<Para>
Processes provide parallelism on control path level, whereby arbitrary nested bounded blocks inside processes provide parallelism on data path level.</Para>
<Para>
There is an extended interface to connect to external hardware objects. </Para>
<Para>
</Para>
<Para>
 </Para>
</Section>
<Section Id = "S3S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Modules and Processes</SectionTitle>
<Para>
A ConPro design hierarchy consists of a behavioural module level (Module-B) containing global (shared) objects and processes. A module is mapped to a circuit
component with a toplevel hardware port interface. Structural modules (Module-S) can be composed of behavioural modules with optional internal interconnect
components. Each process (process level) consists of local (non-shared) objects and a process instruction sequence, specifying the control and data flow.
Abstract object types are implemented with abstract object modules (Module-O).</Para>
<Para>
</Para>
<Section Id = "S3S2S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Behavioural Modules</SectionTitle>
<Para>
Behavioural modules implement objects and processes. A behavioural module  is defined by the source code file itself. Actually there is only one module
hierarchy level, the main module. More source code file can be included using the <Terminal> include</Terminal> statement. </Para>
<Para>
There are two kinds of modules: a module embedding objectes and processes, and modules providing access and implementation of abstract data type objects (ADTO).
These are mainly interprocess communication and synchronization objects, for example mutex, sempahore, timer and some communication links. Each ADTO module to
be used must be opened using the <Terminal> open</Terminal> statement.</Para>
<Environment ID = "D1" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
module-b&nbsp;::=&nbsp;module-b-impl&nbsp;.</Line>
<Line>
module-b-impl&nbsp;::=&nbsp;{&nbsp;include-source&nbsp;}+&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;open-module&nbsp;}+&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;object-definition&nbsp;}+&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;process&nbsp;}+&nbsp;.&nbsp;</Line>
<Line>
include-source&nbsp;::=&nbsp;'include'&nbsp;'"'&nbsp;name&nbsp;'"'&nbsp;';'&nbsp;.</Line>
<Line>
open-module&nbsp;::=&nbsp;'open'&nbsp;name&nbsp;';'&nbsp;.</Line>
<Title>
Formal syntax specification of a behavioural  module.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S2S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Abstract Object Modules</SectionTitle>
<Para>
This module  provides access and implementation of abstract data type objects (ADTO). These are mainly interprocess communication and synchronization objects,
for example mutex, sempahore, timer and some communication links. Each ADTO module to be used must be opened using the <Terminal> open</Terminal> statement.
They are defined by the External Module Interface (see section <XRef IDRef = "S6"></XRef>).</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S2S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Structural Modules</SectionTitle>
<Para>
Structural modules are used to build System-On-Chip (SoC) circuits from behavioural modules.</Para>
<Environment ID = "D2" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
module-s&nbsp;::=&nbsp;'module'&nbsp;name&nbsp;'begin'&nbsp;module-s-impl&nbsp;'end'&nbsp;';'&nbsp;.</Line>
<Title>
Formal syntax specification of  a structural module.</Title>
</Environment>
<Environment ID = "T1" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of module-s definition and interconnect.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E0" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
module&nbsp;MS</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;import</Line>
<Line>
&nbsp;&nbsp;component</Line>
<Line>
&nbsp;&nbsp;structtype</Line>
<Line>
&nbsp;&nbsp;mapping</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new structural module with specified name.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E0" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
import&nbsp;MB;</Line>
<Line>
component&nbsp;C1,C2,..:MB;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Import of behavioural modules and instantiation of components (ciruits).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E0" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
type&nbsp;ICT:{&nbsp;port...};&nbsp;</Line>
<Line>
component&nbsp;IC:ICT&nbsp;:=</Line>
<Line>
{</Line>
<Line>
&nbsp;&nbsp;C1.TOP.S1,</Line>
<Line>
&nbsp;&nbsp;C1.TOP.S2,...</Line>
<Line>
&nbsp;&nbsp;C2.TOP.S1,...</Line>
<Line>
};</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines and instantiate a port interface of interconnect component with initial signal mapping.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E0" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
IC.S1&nbsp;&gt;&gt;&nbsp;IC.S2;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Internal interconnect using mapping statements </Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Link;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
</Line>
<Line>
type&nbsp;dev_type:{</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_din:&nbsp;input&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_din_ack:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_dout:&nbsp;output&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_dout_ack:&nbsp;input&nbsp;logic;</Line>
<Line>
};</Line>
<Line>
component&nbsp;DEV:&nbsp;dev_type;</Line>
<Line>
export&nbsp;DEV;</Line>
<Line>
</Line>
<Line>
object&nbsp;sys:&nbsp;system;</Line>
<Line>
&nbsp;&nbsp;sys.simu_cycles(100);</Line>
<Line>
</Line>
<Line>
--</Line>
<Line>
--&nbsp;Async.&nbsp;Link</Line>
<Line>
--</Line>
<Line>
object&nbsp;ln:&nbsp;link&nbsp;with&nbsp;datawidth=4;</Line>
<Line>
&nbsp;&nbsp;ln.interface(DEV.ln_din,DEV.ln_din_ack,DEV.ln_dout,DEV.ln_dout_ack);</Line>
<Line>
reg&nbsp;xa:&nbsp;int[8];</Line>
<Line>
export&nbsp;x,xa;</Line>
<Line>
</Line>
<Line>
exception&nbsp;Exit;</Line>
<Line>
</Line>
<Line>
</Line>
<Line>
--</Line>
<Line>
--&nbsp;Producer-Consumer&nbsp;process</Line>
<Line>
--</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;err:bool;</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;d:logic[4];</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;try</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xa&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'w',x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_int(d);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ln.write(d,err);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;err&nbsp;=&nbsp;true&nbsp;then&nbsp;raise&nbsp;Exit;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xa&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'r';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ln.read&nbsp;(d,err);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;err&nbsp;=&nbsp;true&nbsp;then&nbsp;raise&nbsp;Exit;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_int(d),d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;d&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;with</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;Exit:&nbsp;ln.stop&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;xa&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'.';</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;ln.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;ln.start&nbsp;();</Line>
<Line>
&nbsp;&nbsp;p1.start&nbsp;();</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
--&nbsp;SoC:&nbsp;two&nbsp;identical&nbsp;blocks&nbsp;Lc1&nbsp;and&nbsp;Lc2&nbsp;containing&nbsp;</Line>
<Line>
--&nbsp;one&nbsp;link&nbsp;ln,&nbsp;process&nbsp;p1&nbsp;and&nbsp;main&nbsp;from&nbsp;this&nbsp;module&nbsp;Link_simu&nbsp;are</Line>
<Line>
--&nbsp;cross&nbsp;linked&nbsp;(Lc1:&nbsp;dout&nbsp;=&gt;&nbsp;Lc2:&nbsp;din,&nbsp;Lc2:dout&nbsp;=&gt;&nbsp;Lc1:din)</Line>
<Line>
--</Line>
<Line>
</Line>
<Line>
module&nbsp;Link2_simu:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;--&nbsp;Instantiate&nbsp;components,&nbsp;import</Line>
<Line>
&nbsp;&nbsp;--&nbsp;THIS&nbsp;toplevel&nbsp;module.</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;import&nbsp;Link_simu;</Line>
<Line>
&nbsp;&nbsp;component&nbsp;Lc1,Lc2:&nbsp;Link_simu;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;--&nbsp;Structural&nbsp;Interconnection</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;type&nbsp;l_connect:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc1_ln_din:&nbsp;output&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc1_ln_din_ack:&nbsp;input&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc1_ln_dout:&nbsp;input&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc1_ln_dout_ack:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc2_ln_din:&nbsp;output&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc2_ln_din_ack:&nbsp;input&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc2_ln_dout:&nbsp;input&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;Lc2_ln_dout_ack:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;};</Line>
<Line>
&nbsp;&nbsp;component&nbsp;L_c:&nbsp;l_connect&nbsp;:=</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Lc1.DEV.ln_din,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc1.DEV.ln_din_ack,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc1.DEV.ln_dout,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc1.DEV.ln_dout_ack,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc2.DEV.ln_din,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc2.DEV.ln_din_ack,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc2.DEV.ln_dout,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lc2.DEV.ln_dout_ack};</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;--&nbsp;Interconnect</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;L_c.Lc1_ln_din&nbsp;&lt;&lt;&nbsp;L_c.Lc2_ln_dout;</Line>
<Line>
&nbsp;&nbsp;L_c.Lc1_ln_din_ack&nbsp;&gt;&gt;&nbsp;L_c.Lc2_ln_dout_ack;</Line>
<Line>
&nbsp;&nbsp;L_c.Lc1_ln_dout&nbsp;&gt;&gt;&nbsp;L_c.Lc2_ln_din;</Line>
<Line>
&nbsp;&nbsp;L_c.Lc1_ln_dout_ack&nbsp;&lt;&lt;&nbsp;L_c.Lc2_ln_din_ack;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Title>
Example of combined behavioural and structural module definitions. A SoC is composed of two components Lc1 and Lc2, instantiated from behavioural module
Link_simu, the actual toplevel module (source file link_simu.cp).</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S2S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Processes</SectionTitle>
<Para>
A process definition consists of a unique process name identifier and the process body. The process body consists of local object definitions (types, data and
some abstract objects) and an instruction sequence. Definition <XRef IDRef = "D3"></XRef> shows the formal specification, and table <XRef IDRef = "T2"></XRef>
summarizes and explains different process defintions and management.</Para>
<Para>
Array of processes can be defined using the array definition statement. To distinguish processes of an array, a process can access its unique process identifier
number (array index). Definition <XRef IDRef = "D4"></XRef>  shows the formal syntax definition for process array definitions.</Para>
<Para>
After definition, a process (itself an ADTO) must be started using the <Terminal> start</Terminal> or <Terminal> call</Terminal> method by another process (see
table <XRef IDRef = "T3"></XRef>), usually the main process (named <Terminal> main</Terminal>), which is the only process started some clock cycles after system
reset.   </Para>
<Environment ID = "D3" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
process&nbsp;::=&nbsp;'process'&nbsp;name&nbsp;':'&nbsp;'begin'&nbsp;process-body&nbsp;'end'&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;'with'&nbsp;parameter-list&nbsp;]&nbsp;';'&nbsp;.</Line>
<Line>
process-body&nbsp;::=&nbsp;{&nbsp;object-definition&nbsp;}+</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;process-instruction&nbsp;}+&nbsp;.</Line>
<Line>
object-definition&nbsp;::=&nbsp;type-definition&nbsp;|&nbsp;dataobj-definition&nbsp;|&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstrobj-definition&nbsp;.</Line>
<Title>
Formal syntax specification of  a process definition.</Title>
</Environment>
<Environment ID = "D4" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
process-array&nbsp;::=&nbsp;(&nbsp;'array'&nbsp;name&nbsp;':'&nbsp;'process'&nbsp;'['&nbsp;number&nbsp;']'&nbsp;'of'&nbsp;)&nbsp;\&gt;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;'begin'&nbsp;process-body&nbsp;'end'&nbsp;)&nbsp;\&gt;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;[&nbsp;'with'&nbsp;parameter-list&nbsp;]&nbsp;';'&nbsp;)&nbsp;.</Line>
<Line>
process-array-id&nbsp;::=&nbsp;'#'&nbsp;.</Line>
<Title>
Formal syntax specification of  a process array definition.</Title>
</Environment>
<Environment ID = "T2" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of process definitions and access.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
process&nbsp;pname</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;definitions</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new process with specified name.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
process&nbsp;pname</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;definitions</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end&nbsp;with&nbsp;param=value;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new process with specified name. Additional parameter settings are applied.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
array&nbsp;paname:&nbsp;</Line>
<Line>
&nbsp;&nbsp;process[size]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;definitions</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new array of <Emphasis>size</Emphasis> different processes. Optional parameter settings can be applied.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
pname.start&nbsp;();</Line>
<Line>
pname.stop&nbsp;();</Line>
<Line>
pname.[i].start&nbsp;();</Line>
<Line>
myid<Symbol>&#xac;</Symbol>#;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Process control using ADTO methods and array selectors.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T3" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of process  management.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Method</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
pname.start&nbsp;();</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Start process <Terminal> pname</Terminal>. The caller process will not be blocked.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
pname.stop&nbsp;();</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Stop process <Terminal> pname</Terminal>. The caller process will not be blocked.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E1" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
pname.call&nbsp;();</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Call process <Terminal> pname</Terminal>. The caller process will  be blocked untill the called process reaches it end state.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
--</Line>
<Line>
--&nbsp;Dining&nbsp;philosophers&nbsp;problem&nbsp;using&nbsp;semaphores.</Line>
<Line>
--</Line>
<Line>
--&nbsp;Five&nbsp;philosophers&nbsp;sit&nbsp;around&nbsp;a&nbsp;circular&nbsp;table.&nbsp;Each&nbsp;philosopher&nbsp;spends</Line>
<Line>
--&nbsp;his&nbsp;life&nbsp;alternately&nbsp;thinking&nbsp;and&nbsp;eating.&nbsp;In&nbsp;the&nbsp;center&nbsp;of&nbsp;the&nbsp;table&nbsp;is&nbsp;a</Line>
<Line>
--&nbsp;large&nbsp;platter&nbsp;of&nbsp;spaghetti.&nbsp;Each&nbsp;philosopher&nbsp;needs&nbsp;two&nbsp;forks&nbsp;two&nbsp;eat.&nbsp;But</Line>
<Line>
--&nbsp;there&nbsp;are&nbsp;only&nbsp;five&nbsp;forks&nbsp;for&nbsp;all.&nbsp;One&nbsp;fork&nbsp;is&nbsp;placed&nbsp;between&nbsp;each&nbsp;pair</Line>
<Line>
--&nbsp;of&nbsp;philosophers,&nbsp;and&nbsp;they&nbsp;agree&nbsp;that&nbsp;each&nbsp;will&nbsp;use&nbsp;only&nbsp;the&nbsp;forks&nbsp;to&nbsp;the</Line>
<Line>
--&nbsp;immeadiate&nbsp;left&nbsp;and&nbsp;right.</Line>
<Line>
--</Line>
<Line>
--&nbsp;[Andrews&nbsp;2000,&nbsp;Multihtreaded,&nbsp;Parallel,&nbsp;and&nbsp;Distributed&nbsp;Programming]</Line>
<Line>
--</Line>
<Line>
</Line>
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Semaphore;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
open&nbsp;Event;</Line>
<Line>
object&nbsp;sys:&nbsp;system;</Line>
<Line>
&nbsp;&nbsp;sys.simu_cycles&nbsp;(500);</Line>
<Line>
object&nbsp;ev:&nbsp;event;</Line>
<Line>
array&nbsp;eating,thinking:&nbsp;reg[5]&nbsp;of&nbsp;logic;</Line>
<Line>
export&nbsp;eating,thinking;</Line>
<Line>
</Line>
<Line>
array&nbsp;fork:&nbsp;object&nbsp;semaphore[5]&nbsp;with&nbsp;depth=8&nbsp;and&nbsp;init=1&nbsp;and&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheduler="fifo";</Line>
<Line>
</Line>
<Line>
<Highlight>process</Highlight>&nbsp;init:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;4&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;fork.[i].init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;ev.init&nbsp;();</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
function&nbsp;eat(n):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;eating.[n]&nbsp;&lt;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;thinking.[n]&nbsp;&lt;-&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end&nbsp;with&nbsp;bind;</Line>
<Line>
&nbsp;&nbsp;wait&nbsp;for&nbsp;5;</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;eating.[n]&nbsp;&lt;-&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;thinking.[n]&nbsp;&lt;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;end&nbsp;with&nbsp;bind;</Line>
<Line>
end&nbsp;with&nbsp;inline;</Line>
<Line>
</Line>
<Line>
<Highlight>array</Highlight>&nbsp;philosopher:&nbsp;<Highlight>process</Highlight>[5]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;<Highlight>#</Highlight>&nbsp;&lt;&nbsp;4&nbsp;then</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;ev.await&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;always&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;get&nbsp;left&nbsp;fork&nbsp;then&nbsp;right</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[<Highlight>#</Highlight>].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[<Highlight>#</Highlight>+1].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eat&nbsp;(<Highlight>#</Highlight>);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[<Highlight>#</Highlight>].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[<Highlight>#</Highlight>+1].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;always&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;get&nbsp;right&nbsp;fork&nbsp;then&nbsp;left</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[4].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[0].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eat&nbsp;(<Highlight>#</Highlight>);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[4].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[0].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
<Highlight>process</Highlight>&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;init.<Highlight>call</Highlight>&nbsp;();</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;4&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;philosopher.[i].<Highlight>start</Highlight>&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;ev.wakeup&nbsp;();</Line>
<Line>
end;</Line>
<Title>
An example showing process definitions and process arrays.</Title>
</Environment>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S3S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Block Structures</SectionTitle>
<Para>
The ConPro architecture is structured into modules and processes on top level. Each process consists of at least one block: the process body, which binds
instructions (and definitions) to the named process environment. Blocks, either on same level or nested, can be used to bind instructions to a specific
environment with different scheduling and allocation strategies. Blocks can be parameterized, shown in definition <XRef IDRef = "D5"></XRef> and table <XRef
IDRef = "T4"></XRef>. Additionally, blocks are used in control statements. </Para>
<Para>
In contrast to common imperative programming languages like C, there are no object defintions and hidden locality inside a block, except in function and process
body blocks.</Para>
<Para>
Predefined block parameters and their possible values are listes in table <XRef IDRef = "T5"></XRef>. A parameter of type boolean can be used without a value.
This assigns automatically the true value to the parameter.</Para>
<Environment ID = "D5" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
block&nbsp;::=&nbsp;'begin'&nbsp;{&nbsp;process-instruction&nbsp;}+&nbsp;'end'&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;'with'&nbsp;parameter-list&nbsp;]&nbsp;';'&nbsp;.</Line>
<Line>
process-instruction&nbsp;::=&nbsp;assignment&nbsp;|&nbsp;control-statement&nbsp;|&nbsp;block&nbsp;.</Line>
<Line>
parameter-list&nbsp;::=&nbsp;param-name&nbsp;'='&nbsp;param-value&nbsp;//&nbsp;'and'&nbsp;.</Line>
<Title>
Formal syntax specification of  a block definition.</Title>
</Environment>
<Environment ID = "T4" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of block definitions.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new block containing instructions.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end&nbsp;with&nbsp;param=value;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new block containing instructions with additional parameters.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
if&nbsp;expr&nbsp;then&nbsp;<Symbol>&#xbc;</Symbol>&nbsp;</Line>
<Line>
while&nbsp;expr&nbsp;do&nbsp;<Symbol>&#xbc;</Symbol></Line>
<Line>
for&nbsp;i&nbsp;=&nbsp;a&nbsp;to&nbsp;b&nbsp;do&nbsp;<Symbol>&#xbc;</Symbol></Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Blocks used with control statements (conditional branch block, conditional loop block, counting loop block)</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T5" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of block parameters. Highlighted values are default settings of each parameter.</Title>
<TABLE  Cols = "3">
<TableBody>
<TableRow>
<TableCell>
<Para>
Parameter</Para>
</TableCell>
<TableCell>
<Para>
Values</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> bind</Terminal></Para>
</TableCell>
<TableCell>
<Para>
<Terminal> true,false </Terminal></Para>
</TableCell>
<TableCell>
<Para>
Instructions (only assignments) are bound to one time unit. </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> unroll</Terminal></Para>
</TableCell>
<TableCell>
<Para>
<Terminal> true,false </Terminal></Para>
</TableCell>
<TableCell>
<Para>
Unrolls a counting for-loop.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> schedule</Terminal></Para>
</TableCell>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
"SL[,SL]"</Line>
<Line>
SL=basicblock&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;refstack&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;expr</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Specifies scheduling strategy and optimization (basic block, reference stack and expression scheduler).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> expr</Terminal></Para>
</TableCell>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
"EXPR"</Line>
<Line>
EXPR=flat&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binary&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shared</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Specifies expression model (flat is non-shared, ALU is shared resource model).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> inline</Terminal></Para>
</TableCell>
<TableCell>
<Para>
<Terminal> true,false </Terminal></Para>
</TableCell>
<TableCell>
<Para>
Defines a function either be placed inline (macro substitution) or  implemented as a shared function block.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Data Objects and Data Types</SectionTitle>
<Para>
True bit-scaled data types (TYPE <Symbol>&#x62;</Symbol>) and storage objects (subset <Symbol>&#xc2;</Symbol> of TYPE <Symbol>&#x61;</Symbol>)  are supported.
The data width can be choosen in the range <Symbol>&#x77;</Symbol>={1,2,<Symbol>&#xbc;</Symbol>,64} Bit. The formal syntax of object definition is shown in
definition <XRef IDRef = "D6"></XRef>, and both data and object types are described in tables <XRef IDRef = "T6"></XRef> and <XRef IDRef = "T7"></XRef>. </Para>
<Para>
A data object <Symbol>&#xc2;</Symbol> is specified by a type cross product of (<Symbol>&#x61;</Symbol><Symbol>&#xb4;</Symbol><Symbol>&#x62;</Symbol>). </Para>
<Environment ID = "D6" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
dataobj-definition&nbsp;::=&nbsp;obj-type&nbsp;(&nbsp;name&nbsp;//&nbsp;','&nbsp;)&nbsp;':'&nbsp;data-type</Line>
<Line>
&nbsp;&nbsp;[&nbsp;'with'&nbsp;parameter-list&nbsp;]&nbsp;';'&nbsp;.&nbsp;&nbsp;</Line>
<Line>
obj-type&nbsp;::=&nbsp;'reg'&nbsp;|&nbsp;'var'&nbsp;|&nbsp;'sig'&nbsp;|&nbsp;'queue'&nbsp;|&nbsp;'channel'&nbsp;.</Line>
<Line>
data-type&nbsp;::=&nbsp;&nbsp;'logic'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;'logic'&nbsp;'['&nbsp;number&nbsp;']'&nbsp;&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;'int'&nbsp;'['&nbsp;number&nbsp;']'&nbsp;&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;'bool'&nbsp;&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;'char'&nbsp;&nbsp;.</Line>
<Title>
Formal syntax specification of  a data object definition.</Title>
</Environment>
<Environment ID = "T6" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of provided set of  data (core) objects <Symbol>&#xc2;</Symbol>, TYPE <Symbol>&#x61;</Symbol>.</Title>
<TABLE  Cols = "3">
<TableBody>
<TableRow>
<TableCell>
<Para>
Keyword</Para>
</TableCell>
<TableCell>
<Para>
Name</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> reg</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Register</Para>
</TableCell>
<TableCell>
<Para>
Single register for CREW-access-behaviour</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> var</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Variable</Para>
</TableCell>
<TableCell>
<Para>
Variable embedded in RAm block with EREW-access-behaviour</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> sig</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Hardware Signal</Para>
</TableCell>
<TableCell>
<Para>
Interconnection signal, synthesizing always to a wire.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> queue</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Data Queue</Para>
</TableCell>
<TableCell>
<Para>
Buffered Queue (FIFO). Depth and data type can be specified.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> channel</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Data Channel</Para>
</TableCell>
<TableCell>
<Para>
Buffered (Queue with depth=1) or unbuffered (withour register) synchronized data exchange </Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T7" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of provided set of data (core) types, TYPE <Symbol>&#x62;</Symbol>.</Title>
<TABLE  Cols = "3">
<TableBody>
<TableRow>
<TableCell>
<Para>
Keyword</Para>
</TableCell>
<TableCell>
<Para>
Type</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> logic</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Bit Value</Para>
</TableCell>
<TableCell>
<Para>
Single bit type. This data type is commonly  synthesized to VHDL <Terminal> std_logic</Terminal> type. </Para>
<Para>
Value set:
 L={<Terminal> 0,1,H,L,Z</Terminal>}</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> logic[size]</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Unsigned Bit Vector</Para>
</TableCell>
<TableCell>
<Para>
Bit vector type of data width size. This data type is commonly  synthesized to VHDL <Terminal> std_logic_vector(size-1 downto 0)</Terminal> type.</Para>
<Para>
Value set: 
L={<Terminal> 0,1,H,L,Z</Terminal>}</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> int[size]</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Signed Integer Vector</Para>
</TableCell>
<TableCell>
<Para>
Signed integer type of data width size (including sign bit). This data type is commonly synthesized to VHDL <Terminal> signed(size-1 downto 0)</Terminal>
type.</Para>
<Para>
Value set: I={<Terminal> -n,</Terminal><Terminal> <Symbol>&#xbc;</Symbol></Terminal><Terminal> ,-1,0,1,</Terminal><Terminal>
<Symbol>&#xbc;</Symbol></Terminal><Terminal> n-1</Terminal>}</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> bool</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Boolean</Para>
</TableCell>
<TableCell>
<Para>
Boolean type.</Para>
<Para>
This data type is commonly synthesized to VHDL <Terminal> std_logic</Terminal> type</Para>
<Para>
Value set:
 B={<Terminal> 0,1,true,false</Terminal>}</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> char</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Character (one byte)</Para>
</TableCell>
<TableCell>
<Para>
8-bit vector (unsigned).</Para>
<Para>
This data type is commonly  synthesized to VHDL <Terminal> std_logic_vector(7 downto 0)</Terminal> type.</Para>
<Para>
Value set:
C= {<Terminal> '0'</Terminal><Terminal> <Symbol>&#xbc;</Symbol></Terminal><Terminal> '9','A'</Terminal><Terminal> <Symbol>&#xbc;</Symbol></Terminal><Terminal>
'Z',</Terminal><Terminal> <Symbol>&#xbc;</Symbol></Terminal>} <Symbol>&#xc8;</Symbol> I</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
There are local and global data objects. Global data objects are shared by several processes concurrently and require an access scheduler providing a mutual
exclusion lock.</Para>
<Para>
</Para>
<Section Id = "S3S4S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Shared Objects and Scheduler</SectionTitle>
<Para>
Access of shared objects muts be guarded inherently by a mutex using a mutual exclusion scheduler. This scheduler is responsible to serialize concurrent access.
</Para>
<Para>
There are two different scheduler available:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Static Priority Scheduler [default]</ItemLabel>
<Para>
This is the simplest scheduler and requires the lowest amount of hardware resources. Each process ever accessing the resource gets a unique ordered priority. If
there are different processes accessing the resource concurrently, the scheduler always grants access to the process with the highest priority. There is a risk
of race conditions using this scheduling strategy.</Para>
<Para>
Commonly, the order of processes appearing in the source code determines their priority: the first process gets the highest priority, the last the
lowest.</Para>
<Para>
A scheduled access requires at least two clock cycles.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Dynamic FIFO Scheduler</ItemLabel>
<Para>
The dynamic scheduler provides fair scheduling using a process queue. Each process wanting to access the resource is stored in this FIFO ordered queue. The
oldest one in the queue is choosen by the scheduler if the resource is released by the previous owner. The dynamic scheduler avoids race conditions, but
requires much more hardware resources.</Para>
</DescriptionItem></DescriptionList>
<Environment ID = "G1" XRefLabel = "Environment" Type = "Graph" LineNumbers = "No" Imported = "No">
<Title>
Scheduler Block Architecture</Title>
<Line>
digraph&nbsp;H&nbsp;{</Line>
<Line>
&nbsp;&nbsp;node&nbsp;[shape=record];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;SCHEDULER&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;label="{SCHEDULER|{&lt;r1&gt;REQ-1|&lt;g1&gt;GD-1|&lt;r2&gt;REQ-2|&lt;g2&gt;GD-2|&lt;r3&gt;REQ-N|&lt;g3&gt;GD-N}}"];&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO1&nbsp;[shape=record,label="{{&lt;rp1&gt;REQ|&lt;gp1&gt;GD}|PRO-1}"];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO2&nbsp;[shape=record,label="{{&lt;rp2&gt;REQ|&lt;gp2&gt;GD}|PRO-2}"];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO3&nbsp;[shape=record,label="{{&lt;rp3&gt;REQ|&lt;gp3&gt;GD}|PRO-N}"];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;SCHEDULER:g1&nbsp;-&gt;&nbsp;PRO1:gp1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;SCHEDULER:g2&nbsp;-&gt;&nbsp;PRO2:gp2;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;SCHEDULER:g3&nbsp;-&gt;&nbsp;PRO3:gp3;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO1:rp1&nbsp;-&gt;&nbsp;SCHEDULER:r1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO2:rp2&nbsp;-&gt;&nbsp;SCHEDULER:r2;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;PRO3:rp3&nbsp;-&gt;&nbsp;SCHEDULER:r3;</Line>
<Line>
}</Line>
</Environment>
<Environment ID = "A1" XRefLabel = "Environment" Type = "Algorithm" LineNumbers = "No" Imported = "No">
<Title>
Static Priority Scheduler: From/to process i:{REQ-i,GD-i}, from/to shared resource block:{ACT,ACK}.  A process-i  request activates REQ-i, and if the resource
is not locked, the request is granted to the next process in the if-then-else cascade. If the request is finished, then ACK is activated and releases the locked
object and releases GD-i for this respective process indicating that the request is finished.   </Title>
<Line>
if&nbsp;REQ-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED<Symbol>&#xac;</Symbol>TRUE;&nbsp;</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;1</Emphasis>;&nbsp;</Line>
<Line>
else&nbsp;if&nbsp;REQ-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED<Symbol>&#xac;</Symbol>TRUE;</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;2</Emphasis>;&nbsp;</Line>
<Line>
<Symbol>&#xbc;</Symbol></Line>
<Line>
else&nbsp;if&nbsp;ACK&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;REQ-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Release&nbsp;GD-1;</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;FALSE;</Line>
<Line>
else&nbsp;if&nbsp;ACK&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;REQ-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Release&nbsp;GD-2;</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;FALSE;</Line>
<Line>
<Symbol>&#xbc;</Symbol></Line>
<Line>
&nbsp;&nbsp;</Line>
</Environment>
<Environment ID = "A2" XRefLabel = "Environment" Type = "Algorithm" LineNumbers = "No" Imported = "No">
<Title>
Dynamic Queue Scheduler: From/to process i:{REQ-i,GD-i}, from/to shared resource block:{ACT,ACK}. A process-i  request activates REQ-i, and if the resource
queue is empty or this process is at head of the queue, the request is granted to the process in the if-then-else cascade. If the request is finished, then ACK
is activated and removes the process from the resource queue  and releases GD-i for this respective process indicating that  the request is finished.  </Title>
<Line>
if&nbsp;REQ-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED=[]&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>PRO-1-LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[PRO-1];</Line>
<Line>
&nbsp;&nbsp;PRO-1-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TRUE;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>PRO-1;</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;1</Emphasis>;</Line>
<Line>
else&nbsp;if&nbsp;REQ-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED=[]&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>PRO-2-LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[PRO-2];</Line>
<Line>
&nbsp;&nbsp;PRO-2-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TRUE;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>PRO-2;</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;2</Emphasis>;</Line>
<Line>
<Symbol>&#xbc;</Symbol></Line>
<Line>
else&nbsp;if&nbsp;REQ-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>PRO-1-LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;LOCKED&nbsp;@&nbsp;[PRO-1];&nbsp;<Emphasis>Append&nbsp;Process&nbsp;1&nbsp;to&nbsp;Queue</Emphasis>&nbsp;</Line>
<Line>
&nbsp;&nbsp;PRO-1-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TRUE;</Line>
<Line>
else&nbsp;if&nbsp;REQ-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;LOCKED&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>PRO-2-LOCKED&nbsp;then</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;LOCKED&nbsp;@&nbsp;[PRO-2];&nbsp;<Emphasis>Append&nbsp;Process&nbsp;2&nbsp;to&nbsp;Queue</Emphasis></Line>
<Line>
&nbsp;&nbsp;PRO-2-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TRUE;</Line>
<Line>
<Symbol>&#xbc;</Symbol></Line>
<Line>
else&nbsp;if&nbsp;REQ-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;Head(LOCKED)=PRO-1&nbsp;&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;OWNER<Symbol>&#xb9;</Symbol>PRO-1&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;1</Emphasis>;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>PRO-1;</Line>
<Line>
else&nbsp;if&nbsp;REQ-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;Head(LOCKED)=PRO-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;OWNER<Symbol>&#xb9;</Symbol>PRO-2&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Raise&nbsp;ACT;&nbsp;<Emphasis>Start&nbsp;Service&nbsp;for&nbsp;Process&nbsp;2</Emphasis>;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>PRO-2;</Line>
<Line>
<Symbol>&#xbc;</Symbol></Line>
<Line>
else&nbsp;if&nbsp;ACK-1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;Head(LOCKED)=PRO-1&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Release&nbsp;GD-1;</Line>
<Line>
&nbsp;&nbsp;PRO-1-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;FALSE;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>NONE;</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;Tail(LOCKED);</Line>
<Line>
else&nbsp;if&nbsp;ACK-2&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;Head(LOCKED)=PRO-2&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;Release&nbsp;GD-2;</Line>
<Line>
&nbsp;&nbsp;PRO-2-LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;FALSE;</Line>
<Line>
&nbsp;&nbsp;OWNER<Symbol>&#xac;</Symbol>NONE;</Line>
<Line>
&nbsp;&nbsp;LOCKED&nbsp;<Symbol>&#xac;</Symbol>&nbsp;Tail(LOCKED);</Line>
<Line>
<Symbol>&#xbc;</Symbol>&nbsp;&nbsp;&nbsp;</Line>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S4S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Registers</SectionTitle>
<Para>
Registers are single storage elements either used as a shared global object or as a local object inside a process. In the case of a global object, the register
provides concurrent read access (not requiring a mutex guarderd scheduler)  and exclusive mutex guarded write access. If there is more than process trying to
write to the register, a mutex guarded scheduler serializes the write accesses. There are two different schedulers available: static priority and dynamic FIFO
scheduled. See section <XRef IDRef = "S3_4_1"></XRef> for details.</Para>
<Environment ID = "T8" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of register definitions and access in expressions.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
reg&nbsp;rname:&nbsp;DT[N];</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new register of specified type and width. </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
reg&nbsp;rname:&nbsp;stype;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a register of a structure type. </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
reg&nbsp;rname:&nbsp;DT[N];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;param=value;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a register of specified type with additional parameters.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E2" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
if&nbsp;rname&nbsp;=&nbsp;expr&nbsp;then&nbsp;<Symbol>&#xbc;</Symbol>&nbsp;</Line>
<Line>
rname&nbsp;<Symbol>&#xac;</Symbol>&nbsp;expr;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Register used in expression and assignment.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
Registers can be read in expressions, and can be wrote in assignments, summarized in table <XRef IDRef = "T8"></XRef> and shown in example <XRef IDRef =
"E3"></XRef>.</Para>
<Environment ID = "E3" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
reg&nbsp;xs:&nbsp;int[10];</Line>
<Line>
reg&nbsp;ys:&nbsp;logic[11];</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;x:&nbsp;int[8];</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>0;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;xs&nbsp;+&nbsp;x;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;ys&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_logic(x);</Line>
<Line>
end;</Line>
<Line>
process&nbsp;p2:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;xs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;xs&nbsp;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;while&nbsp;ys&nbsp;&lt;&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;xs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;xs&nbsp;+&nbsp;to_int(ys);</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Title>
Example of global and local register definitions and register access.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S4S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Variables</SectionTitle>
<Para>
Variables are storage elements inside a memory block either used as a shared global object (the memory block itself) or as a local object inside a process. A
variable provides always  exclusive mutex guarded read and write access. </Para>
<Para>
Different variables concerning both data type and data width are stored in one memory block, which is mapped to a RAM. Address management is done automatically
during synthesis and is transparent to the programmer. Direct address references or manipulation (aka pointers) are not supported. </Para>
<Para>
The memory data width, always of type logic/bit-vector, is scaled to the largest variable stored in memory. To reduce memory data width, variables can be
fragmented, that means a variable is scattered about several memory cells. </Para>
<Para>
Different memory blocks can be created explicitly, and variables can be assigned to different blocks.</Para>
<Environment ID = "T9" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of variable definitions and access in expressions.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E3" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
var&nbsp;rname:&nbsp;DT[N];</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new register of specified type and width. </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E3" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
var&nbsp;rname:&nbsp;stype;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a register of a structure type. </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E3" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
var&nbsp;vname:&nbsp;DT[N];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;param=value;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a register of specified type with additional parameters.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E3" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
if&nbsp;vname&nbsp;=&nbsp;expr&nbsp;then&nbsp;<Symbol>&#xbc;</Symbol>&nbsp;</Line>
<Line>
vname&nbsp;<Symbol>&#xac;</Symbol>&nbsp;expr;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Variable used in expression and assignment.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
There are two different schedulers available: static priority and dynamic FIFO scheduled. See section <XRef IDRef = "S3_4_1"></XRef> for details.</Para>
<Para>
Variables can be read in expressions, and can be wrote in assignments, shown in example <XRef IDRef = "E4"></XRef>.</Para>
<Environment ID = "E4" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
block&nbsp;ram1,ram2;</Line>
<Line>
var&nbsp;xs:&nbsp;int[10]&nbsp;in&nbsp;ram1;</Line>
<Line>
var&nbsp;ys:&nbsp;logic[11]&nbsp;in&nbsp;ram1;</Line>
<Line>
var&nbsp;zs:&nbsp;logic[11]&nbsp;in&nbsp;ram2;</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;x:&nbsp;int[8];</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>0;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;xs&nbsp;+&nbsp;x;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;ys&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_logic(x);</Line>
<Line>
&nbsp;&nbsp;zs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;ys&nbsp;*&nbsp;2;</Line>
<Line>
end;</Line>
<Line>
process&nbsp;p2:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;zs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;ys;</Line>
<Line>
&nbsp;&nbsp;ys&nbsp;<Symbol>&#xac;</Symbol>&nbsp;zs&nbsp;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;while&nbsp;ys&nbsp;&lt;&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;xs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;xs&nbsp;+&nbsp;to_int(ys);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;ys&nbsp;<Symbol>&#xac;</Symbol>&nbsp;zs&nbsp;*&nbsp;2;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Title>
Example of variable  definitions and variable access.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S4S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Signals</SectionTitle>
<Para>
Signals are interconnection elements without a storage model. They provide an interface to external hardware blocks. Signals are used in component structures,
too.</Para>
<Para>
Signals can be read in expressions, and a value can be assigned in assignments, shown in example <XRef IDRef = "E5"></XRef>. Reading a signal returns the actual
value of a signal, but writing to a signal assigns a new value only for the time the assignment is active, otherwise a default values is assigned to the signal.
Therefore, there may be only one assignment for a signal.</Para>
<Para>
Signals can be used in conjunction with <Terminal> wait</Terminal> and <Terminal> wait-for</Terminal> control statements.</Para>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
type&nbsp;dev_type&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;port&nbsp;leds:&nbsp;output&nbsp;logic[4];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;rd:&nbsp;input&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;wr:&nbsp;output&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;we:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;port&nbsp;act:&nbsp;input&nbsp;logic;</Line>
<Line>
};</Line>
<Line>
component&nbsp;DEV:&nbsp;dev_type;</Line>
<Line>
export&nbsp;DEV;</Line>
<Line>
reg&nbsp;stat_leds:&nbsp;logic[4];</Line>
<Line>
DEV.leds&nbsp;&lt;&lt;&nbsp;stat_leds;</Line>
<Line>
signal&nbsp;s1:&nbsp;int[8];</Line>
<Line>
signal&nbsp;s2:&nbsp;logic;</Line>
<Line>
reg&nbsp;xs:&nbsp;int[8];</Line>
<Line>
export&nbsp;s1,s2;</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;x:&nbsp;int[8];</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>0;</Line>
<Line>
&nbsp;&nbsp;stat_leds[0]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;x&nbsp;+&nbsp;s1;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;xs&nbsp;<Symbol>&#xac;</Symbol>&nbsp;x;</Line>
<Line>
&nbsp;&nbsp;stat_leds[0]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
end;</Line>
<Line>
process&nbsp;p2:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;stat_leds[1]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;DEV.act&nbsp;=&nbsp;1&nbsp;with&nbsp;s2&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;DEV.we&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1,DEV.wr&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_logic(xs);</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;stat_leds[1]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
end;</Line>
<Title>
Example of signal definitions and signal access. Component structure elements are signals, too.</Title>
</Environment>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S3S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Expressions and Assignments</SectionTitle>
<Para>
Assignments transfer data from expression results to storage elements and they can be used with register, variables, queue and channels objects (with special
treatment for signals). An assignment finishing with a semicolon at the end is usually executed within one time unit. </Para>
<Para>
A group of  data independent assignments with up to one guarded object access can be executed within one time unit concurrently. All assignments of this group
are separated by a colon, shown in definition <XRef IDRef = "D7"></XRef>. Tables <XRef IDRef = "T10"></XRef>, <XRef IDRef = "T11"></XRef>, <XRef IDRef =
"T12"></XRef> and <XRef IDRef = "T13"></XRef> summarize the available operations.</Para>
<Environment ID = "D7" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
single-assignment&nbsp;::=&nbsp;data-obj&nbsp;'&lt;-'&nbsp;expression&nbsp;';'&nbsp;.</Line>
<Line>
bounded-assignment&nbsp;::=&nbsp;((&nbsp;data-obj&nbsp;'&lt;-'&nbsp;expression&nbsp;)&nbsp;//&nbsp;','&nbsp;)&nbsp;';'&nbsp;.</Line>
<Line>
expression&nbsp;::=&nbsp;arith-expr&nbsp;|&nbsp;logic-expr&nbsp;|&nbsp;bool-expr&nbsp;|&nbsp;relat-expr&nbsp;.</Line>
<Title>
Formal syntax specification of  single and bounded assignments, executed concurrently.</Title>
</Environment>
<Environment ID = "T10" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available arithmetic operators. Supported data type set: {logic[N],int[N],char}</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a + b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Addition</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a - b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Subtraction</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> -a</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Negation</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a * b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Multiplication</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a / b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Division</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a asl n</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Shifts operand <Terminal> a</Terminal> <Terminal> n</Terminal> digits left.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a asr n</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Shifts operand <Terminal> a</Terminal> <Terminal> n</Terminal> digits right.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> 2 ^ n</Terminal></Para>
</TableCell>
<TableCell>
<Para>
<Index><I_Body>2</I_Body><I_Superscript>n</I_Superscript></Index>, only constant values n</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> n ~ 2</Terminal></Para>
</TableCell>
<TableCell>
<Para>
<Index><I_Body>log</I_Body><I_Subscript>2</I_Subscript></Index>(n), only constant values</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T11" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available logic operators. Supported data type set: {logic[N],int[N],char}</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a lor b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Or-operation for each bit of <Terminal> a</Terminal> and <Terminal> b</Terminal>.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a land b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
And-operation for each bit of <Terminal> a</Terminal> and <Terminal> b</Terminal>.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a lxor b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Xor-operation for each bit of <Terminal> a</Terminal> and <Terminal> b</Terminal>.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> lnot a</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Negation</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a lsl n</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Shifts operand <Terminal> a</Terminal> <Terminal> n</Terminal> digits left.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a lsr n</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Shifts operand <Terminal> a</Terminal> <Terminal> n</Terminal> digits right.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T12" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available boolean operators. Supported data type: bool</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a bor b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Boolean or-operation</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a band b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Boolean and-operation </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a bxor b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Boolean xor-operation </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> bnot a</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Negation</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "T13" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available relational  operators. Supported data type: {logic[N],int[N],char}</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a &lt; b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Lower-than compare</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a &lt;= b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Lower-than-equal compare</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a &gt; b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Greater-than compare  </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a &gt;= b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Greater-than-equal compare  </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a = b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Equal compare  </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a &lt;&gt; b</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Not-Equal compare  </Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Types</SectionTitle>
<Para>
Objects are specified by their object type <Symbol>&#x61;</Symbol> and a data type <Symbol>&#x62;</Symbol>. There are data type  and abstract type objects. User
defined types providing oroduct types using arrays and structures and restricted sum types with enumerated symbolic name lists are available.</Para>
<Para>
</Para>
<Section Id = "S3S6S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Data Object Types</SectionTitle>
<Para>
Data objects (including IPC objects queue and channel) can be used directly in expressions and assignments.</Para>
<DescriptionList Type = "Description">
<DescriptionItem><ItemLabel>
Data Object Types</ItemLabel>
<Para>
<Terminal> TYPE a</Terminal><Terminal> '={</Terminal><Terminal> reg,var,sig,queue,channel}</Terminal></Para>
</DescriptionItem></DescriptionList>
<Environment ID = "T14" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available Data Object Types.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Object Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> reg</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Register</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> var</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Variable <Symbol>&#xba;</Symbol> memory block</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> sig</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Signal</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> queue</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Queue (IPC)</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> channel</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Channel (IPC)</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Data Types</SectionTitle>
<Para>
Table <XRef IDRef = "T15"></XRef> lists all available data types which can be used with expressions, function arguments and assignments. These data types can be
applied to a subset of available object types (data and some interprocess communication objects): </Para>
<Para>
See also tables <XRef IDRef = "T6"></XRef> and <XRef IDRef = "T7"></XRef> and definition <XRef IDRef = "D6"></XRef> for more informations.</Para>
<DescriptionList Type = "Description">
<DescriptionItem><ItemLabel>
Data Types</ItemLabel>
<Para>
<Terminal> TYPE </Terminal><Terminal> <Symbol>&#x62;</Symbol></Terminal><Terminal> '={</Terminal><Terminal> logic,int,char,bool}</Terminal></Para>
</DescriptionItem></DescriptionList>
<Environment ID = "T15" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of available Data Types.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> logic</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Single logic bit</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> logic[N]</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Logic vector of width N bit</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> int[N]</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Signed integer of width N bit</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> char</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Character (<Symbol>&#xba;</Symbol> logic[8])</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> bool</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Boolean (<Symbol>&#xba;</Symbol> logic)</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Abstract Data Object Types</SectionTitle>
<Para>
Table <XRef IDRef = "T16"></XRef>  summarizes all abstract object types <Symbol>&#xc1;</Symbol> used for interprocess communication and synchronization (IPC)
and additional ones used for communication and storage. Implementation and Interface of each ADTO are defined using the External Module Interface (EMI). More
ADT objects can be added and embedded in a ConPro design using this interface. ADTOs can only be accessed with their respective methods.</Para>
<Environment ID = "T16" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Available Abstract Data Objects Types.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Abstract Data Type</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> mutex</Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC: mutual exclusion</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> semaphore</Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC: sempahore</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> barrier</Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC: barrier</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> event</Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC: event</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> timer</Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC: periodical event timer</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> ram</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Storage: RAM blocks (external and internal)</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> random</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Pseudo-Random-Generators</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> latch</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Asynchronous Latch Memory</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> uart</Terminal></Para>
</TableCell>
<TableCell>
<Para>
COMM: Serial receiver and transmitter</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> process</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Process object</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Product Types: Array</SectionTitle>
<Environment ID = "T17" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of array definitions.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Statement</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>array</Highlight>&nbsp;A:&nbsp;</Line>
<Line>
&nbsp;&nbsp;OT[N]&nbsp;of&nbsp;DT;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Define storage array of size N with object type OT and data type DT.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>array</Highlight>&nbsp;A:&nbsp;</Line>
<Line>
&nbsp;&nbsp;OT[N]&nbsp;of&nbsp;DT</Line>
<Line>
&nbsp;&nbsp;with&nbsp;PARAMS;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Define storage array of size N with object type OT and data type DT and parameter settings.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>array</Highlight>&nbsp;A:&nbsp;</Line>
<Line>
&nbsp;&nbsp;object&nbsp;obj[N]</Line>
<Line>
&nbsp;&nbsp;with&nbsp;PARAMS;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Define abstract object array of size N. Optional object parameter settings require prefixed ADTO module selector.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>array</Highlight>&nbsp;A:&nbsp;</Line>
<Line>
&nbsp;&nbsp;process[N]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;B</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new array of N different processes. Optional process block parameters can be applied.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Product Types: Structure</SectionTitle>
<Para>
New user defined types can be used to aggregate objects with heterogene types and data widths. In contrast to arrays, a new type structure must be defined first
without creation of any data object. After type definition data objects of this type can be created (instantiated). Supported data object types are: signal,
register, variable, queue, channel, component.</Para>
<Para>
Structure Subclasses</Para>
<Para>
There are three different subclasses of structures for different purposes:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Multi-Type Structure</ItemLabel>
<Para>
The generic structure type binds different named structure elements with different data types to a new user defined data type, the native product type. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Bit Structure</ItemLabel>
<Para>
This structure subclass provides a bit-index-name mapping for storage objects. All structure elements have the same data type. The bit-index is either one bit
number or a range of bits. This structure type provides symbolic/named selection of parts of vector data type (for example logic vector and integer types) and
clarifies bit access of objects.  </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Component Structure</ItemLabel>
<Para>
This structure defines hardware component ports, either of a ConPro module toplevel port, or of an embedded hardware component (modelled on hardware level).
This structure type can only be used with component object defintions. The component type has equal behaviour like the signal type.</Para>
</DescriptionItem></DescriptionList>
<Para>
The structure type defintion therefore contains only data types, and no object types. A structure type binds N different structure elements, distinguished by
their names.</Para>
<Para>
Tip: The member names of structures should begin with a lower case letter, the elements of a enumerated symbolic list should begin with an uppercase letter.
Elements of a structure can be accessed with the object and element name concatenated with a dot.</Para>
<Para>
In the case the object type of a structure is a register, just N independent registers are created. In the case of a variable type, N objects are stored into a
RAM block.</Para>
<Para>
Arrays from structure types can be created. For each structure element a different array is created.</Para>
<Para>
Hardware component port types are defined with structures, too, with the difference that for each structure element the direction of the signal must be
specified. Some care must be taken for the direction: if the component is in lower hierarchical order (an embedded external hardware component), the direction
is seen from the external view of the hardware component. If the component is part of the toplevel port interface of a ConPro module, it must be seen from the
internal view.</Para>
<Environment ID = "T18" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of structure type definition, data object definitions and structure access.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Statement</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>type</Highlight>&nbsp;ST:&nbsp;{&nbsp;</Line>
<Line>
&nbsp;&nbsp;e1:&nbsp;DT;</Line>
<Line>
&nbsp;&nbsp;e2:&nbsp;DT;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
};</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new structure type with data type DT specification for each element..</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>type</Highlight>&nbsp;CT:&nbsp;{&nbsp;</Line>
<Line>
&nbsp;port&nbsp;e1:&nbsp;DIR&nbsp;DT;</Line>
<Line>
&nbsp;port&nbsp;e2:&nbsp;DIR&nbsp;DT;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
};</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new component structure type with data type DT and signal direction DIR specification for each element.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>type</Highlight>&nbsp;BT:&nbsp;{&nbsp;</Line>
<Line>
&nbsp;&nbsp;e1:&nbsp;BN;</Line>
<Line>
&nbsp;&nbsp;e2:&nbsp;BN;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
};</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new bit structure type with bit-index BW specification for each element.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>reg</Highlight>&nbsp;S:&nbsp;ST&nbsp;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new storage object of type register.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
OT&nbsp;S:&nbsp;ST&nbsp;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new object of type OT (sig,reg,var,queue,channel,component).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
ST.e1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;ST.e1&nbsp;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Access of structure element objects (write and read).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E5" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>array</Highlight>&nbsp;AS:&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;OT[N]&nbsp;of&nbsp;ST</Line>
<Line>
&nbsp;&nbsp;with&nbsp;PARAMS;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new array of N different structure objects. Optional process block parameters can be applied.</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "D8" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
type-definition&nbsp;::=&nbsp;(&nbsp;'type'&nbsp;type-name&nbsp;':'&nbsp;'{'&nbsp;)&nbsp;\&nbsp;</Line>
<Line>
&nbsp;&nbsp;(&nbsp;{&nbsp;element-name&nbsp;':'&nbsp;[&nbsp;port-type&nbsp;]&nbsp;data-type&nbsp;';'&nbsp;}+&nbsp;)&nbsp;\</Line>
<Line>
&nbsp;&nbsp;(&nbsp;'}'&nbsp;';'&nbsp;)&nbsp;.&nbsp;</Line>
<Line>
component-type-definition&nbsp;::=&nbsp;(&nbsp;'type'&nbsp;type-name&nbsp;':'&nbsp;'{'&nbsp;)&nbsp;\&nbsp;</Line>
<Line>
&nbsp;&nbsp;(&nbsp;{&nbsp;'port'&nbsp;element-name&nbsp;':'&nbsp;port-type&nbsp;data-type&nbsp;';'&nbsp;}+&nbsp;)&nbsp;\</Line>
<Line>
&nbsp;&nbsp;(&nbsp;'}'&nbsp;';'&nbsp;)&nbsp;.&nbsp;</Line>
<Line>
bit-type-definition&nbsp;::=&nbsp;(&nbsp;'type'&nbsp;type-name&nbsp;':'&nbsp;'{'&nbsp;)&nbsp;\&nbsp;</Line>
<Line>
&nbsp;&nbsp;(&nbsp;{&nbsp;element-name&nbsp;':'&nbsp;bit-index&nbsp;';'&nbsp;}+&nbsp;)&nbsp;\</Line>
<Line>
&nbsp;&nbsp;(&nbsp;'}'&nbsp;';'&nbsp;)&nbsp;.&nbsp;</Line>
<Line>
object-definition&nbsp;::=&nbsp;&nbsp;object-type&nbsp;obj-name&nbsp;':'&nbsp;type-name&nbsp;';'&nbsp;.&nbsp;</Line>
<Line>
object-type&nbsp;::=&nbsp;'sig'&nbsp;|&nbsp;'reg'&nbsp;|&nbsp;'var'&nbsp;|&nbsp;'queue'&nbsp;|&nbsp;'channel'&nbsp;|&nbsp;'component'&nbsp;.</Line>
<Line>
port-type&nbsp;::=&nbsp;'input'&nbsp;|&nbsp;'output'&nbsp;|&nbsp;'bus'&nbsp;.</Line>
<Line>
bit-index&nbsp;::=&nbsp;natural&nbsp;|&nbsp;range&nbsp;.</Line>
<Line>
range&nbsp;::=&nbsp;A&nbsp;(&nbsp;'to'&nbsp;|&nbsp;'downto'&nbsp;)&nbsp;B&nbsp;.&nbsp;</Line>
<Line>
element-access&nbsp;::=&nbsp;obj-name&nbsp;'.'&nbsp;element-name&nbsp;.</Line>
<Title>
Formal syntax definition for structure type definition, object definition and structure object  access.</Title>
</Environment>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
--&nbsp;Multi-type&nbsp;structure&nbsp;type&nbsp;definition</Line>
<Line>
type&nbsp;registers&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;ax&nbsp;:&nbsp;logic[32];</Line>
<Line>
&nbsp;&nbsp;bx&nbsp;:&nbsp;logic[32];</Line>
<Line>
&nbsp;&nbsp;sp&nbsp;:&nbsp;logic[16];</Line>
<Line>
&nbsp;};</Line>
<Line>
type&nbsp;image&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;row:&nbsp;logic[32%4];</Line>
<Line>
&nbsp;&nbsp;col:&nbsp;logic[32%4];</Line>
<Line>
&nbsp;};</Line>
<Line>
--&nbsp;Component&nbsp;structure&nbsp;type&nbsp;defintion</Line>
<Line>
type&nbsp;uart&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;port&nbsp;rx&nbsp;:&nbsp;input&nbsp;logic[2];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;tx&nbsp;:&nbsp;output&nbsp;logic[2];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;re&nbsp;:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;port&nbsp;we&nbsp;:&nbsp;input&nbsp;logic;&nbsp;</Line>
<Line>
&nbsp;};</Line>
<Line>
--&nbsp;Bit-type&nbsp;structure&nbsp;type&nbsp;defintion</Line>
<Line>
type&nbsp;command&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;ack:&nbsp;&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;cmd:&nbsp;1&nbsp;to&nbsp;2;</Line>
<Line>
&nbsp;&nbsp;data:&nbsp;3&nbsp;to&nbsp;7;&nbsp;</Line>
<Line>
&nbsp;};</Line>
<Line>
</Line>
<Line>
block&nbsp;ram1;</Line>
<Line>
reg&nbsp;regs&nbsp;:&nbsp;registers;</Line>
<Line>
var&nbsp;vegs&nbsp;:&nbsp;registers&nbsp;in&nbsp;ram1;</Line>
<Line>
var&nbsp;vim&nbsp;:&nbsp;image&nbsp;in&nbsp;ram1;</Line>
<Line>
var&nbsp;after&nbsp;:&nbsp;logic[16]&nbsp;in&nbsp;ram1;</Line>
<Line>
component&nbsp;dev1:&nbsp;uart;</Line>
<Line>
reg&nbsp;cmd:&nbsp;command;</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;x:&nbsp;logic[2];</Line>
<Line>
&nbsp;&nbsp;type&nbsp;cpu_regs&nbsp;:&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;ax&nbsp;:&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;bx&nbsp;:&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;&nbsp;sp&nbsp;:&nbsp;logic[8];</Line>
<Line>
&nbsp;&nbsp;};</Line>
<Line>
&nbsp;&nbsp;var&nbsp;cpu&nbsp;:&nbsp;cpu_regs&nbsp;in&nbsp;ram1;</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;row:&nbsp;logic[32];</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;regs.ax&nbsp;<Symbol>&#xac;</Symbol>&nbsp;row;</Line>
<Line>
&nbsp;&nbsp;regs.ax&nbsp;<Symbol>&#xac;</Symbol>&nbsp;regs.ax&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;vegs.ax&nbsp;<Symbol>&#xac;</Symbol>&nbsp;vegs.ax&nbsp;+&nbsp;intern;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;wait&nbsp;for&nbsp;dev1.re&nbsp;=&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;dev1.rx;</Line>
<Line>
&nbsp;&nbsp;dev1.tx&nbsp;<Symbol>&#xac;</Symbol>&nbsp;x,&nbsp;dev1.we&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;cmd&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;cmd.ack&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;cmd.cmd&nbsp;<Symbol>&#xac;</Symbol>&nbsp;x;</Line>
<Line>
end;</Line>
<Title>
Structures with register, variable and component object type.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S6S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Sum Types: Enumeration</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S6S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Exceptions</SectionTitle>
<Para>
Exceptions provide the only way to leave a control structure, for example loops, conditional branches or functions itself. Exception are abstract signals, which
can be raised anywhere and caught within a try-with exception handler environment, either within the process/function where the execption was raised, or
outside. Thus exceptions are automatically propagated along a call path of processes and functions using exception state registers if they are not caught within
the raising process/function.</Para>
<Environment ID = "T19" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of array definitions.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Statement</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>exception</Highlight>&nbsp;E;&nbsp;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Define a new exception type E.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>raise</Highlight>&nbsp;E;&nbsp;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Raise exception E. The control flow is directed to exception handler environment, if any.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
<Highlight>try</Highlight>&nbsp;B&nbsp;with&nbsp;</Line>
<Line>
<Highlight>begin</Highlight></Line>
<Line>
&nbsp;&nbsp;when&nbsp;E1:&nbsp;B1;</Line>
<Line>
&nbsp;&nbsp;when&nbsp;E2:&nbsp;B2;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
<Highlight>end</Highlight>;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines an excpetion handler environment. An exception raised in B is caught by a particular case in the when list which executes the particluar instruction
(block) B..</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S3S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Control Statements</SectionTitle>
<Section Id = "S3S7S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Counting for-Loop</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Conditional while-Loop</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Endless always-Loop</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Blocking wait-for-Loop</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Conditional if-else-Branch</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Multicase match-Branch</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S3S7S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Exception Handler</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S3S8" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Functions</SectionTitle>
<Para>
A function definition consists of a unique function name identifier, the function application interface, and the function body. The function body consists of
local object definitions (types, data and some abstract objects) and an instruction sequence. Definition <XRef IDRef = "D9"></XRef> shows the formal
specification, and table <XRef IDRef = "T20"></XRef> summarizes and explains different function defintions and function application (calling).</Para>
<Para>
The function application interface specifies function parameters with theit name and type.  Function can return values. If there is no value returned, the
function behaves like a procedure. </Para>
<Para>
Functions can be used within simple assignments, but not within expressions. If a function returns more than one value, a tuple must be used on the left hand
side of the assignment.</Para>
<Para>
Each function parameter and the set of return value paramters are handled like registers. Only call-by-value semantic is supported. Values of function arguments
are copied to the respective parameters on function call, and return values are copied after function call has finished. Within the function body, all
parameters and the (named) return parameter can be used in assignments and expression like any other register. There is no return statement. The last value
assigned to the return parameter is automatically returned.</Para>
<Para>
There are two different types of functions: inlined and shared. The inlined function type is handled likle a macro definition. Each time a function is applied
(called), the function call is replaced by the function body, and all function parameters are replaced by  the function arguments (including return value
parameters).</Para>
<Para>
Shared functions are implemented using the process model using the call method, and with an additional function call wrapper. Each time a shared function is
called the argument values are passed to the function parameters (global registers), and the return value(s) are passed back, if any.</Para>
<Environment ID = "D9" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
function&nbsp;::=&nbsp;('function'&nbsp;name&nbsp;func-params&nbsp;func-ret&nbsp;':'&nbsp;)&nbsp;\&lt;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('begin'&nbsp;function-body&nbsp;'end')&nbsp;\&lt;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([&nbsp;'with'&nbsp;parameter-list&nbsp;]&nbsp;';')&nbsp;.</Line>
<Line>
function-params&nbsp;::=&nbsp;'('&nbsp;{&nbsp;param-def&nbsp;}+&nbsp;')'&nbsp;.</Line>
<Line>
function-ret&nbsp;::=&nbsp;'return'&nbsp;'('&nbsp;{&nbsp;param-def&nbsp;}+&nbsp;')'&nbsp;.</Line>
<Line>
param-def&nbsp;::=&nbsp;name&nbsp;':'&nbsp;data-type&nbsp;.</Line>
<Line>
function-body&nbsp;::=&nbsp;{&nbsp;object-definition&nbsp;}+</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;process-instruction&nbsp;}+&nbsp;.</Line>
<Line>
object-definition&nbsp;::=&nbsp;type-definition&nbsp;|&nbsp;dataobj-definition&nbsp;|&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstrobj-definition&nbsp;.</Line>
<Title>
Formal syntax specification of  a function definition.</Title>
</Environment>
<Environment ID = "T20" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of function definitions and application (call).</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Syntax</Para>
</TableCell>
<TableCell>
<Para>
Description</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
function&nbsp;pname</Line>
<Line>
&nbsp;(x:int[8],n:bool):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;definitions</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new procedure with specified name (no return value).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
function&nbsp;fname</Line>
<Line>
&nbsp;(x:int[8],n:bool)</Line>
<Line>
&nbsp;return&nbsp;(a:int[4]):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;definitions</Line>
<Line>
&nbsp;&nbsp;instructions</Line>
<Line>
end&nbsp;with&nbsp;param=value;</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Defines a new function with specified name. Additional parameter settings are applied (<Terminal> inline</Terminal>: inlined function macro).</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Environment ID = "E6" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
pname();</Line>
<Line>
pname(i,1);</Line>
<Line>
y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;fname(x);</Line>
<Line>
{y1,y2}&nbsp;<Symbol>&#xac;</Symbol>&nbsp;fname(x);</Line>
</Environment>
</TableCell>
<TableCell>
<Para>
Function and procedure application (call with arguments).</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Environment ID = "E7" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
const&nbsp;div_n:&nbsp;value&nbsp;:=&nbsp;16;</Line>
<Line>
const&nbsp;div_n1:&nbsp;value&nbsp;:=&nbsp;15;</Line>
<Line>
const&nbsp;div2_n:&nbsp;value&nbsp;:=&nbsp;32;</Line>
<Line>
const&nbsp;div2_n1:&nbsp;value&nbsp;:=&nbsp;31;</Line>
<Line>
</Line>
<Line>
--</Line>
<Line>
--&nbsp;optimized&nbsp;fast&nbsp;sequentiel&nbsp;division</Line>
<Line>
--</Line>
<Line>
function&nbsp;div&nbsp;(a:logic[div_n],b:logic[div_n])&nbsp;return(z:logic[div_n]):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;q,b2:&nbsp;logic[div2_n];</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;i:&nbsp;logic[5];</Line>
<Line>
&nbsp;&nbsp;const&nbsp;l0:&nbsp;logic[1]&nbsp;:=&nbsp;0;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;q&nbsp;&lt;-&nbsp;a;</Line>
<Line>
&nbsp;&nbsp;b2&nbsp;&lt;-&nbsp;b&nbsp;lsl&nbsp;div_n;</Line>
<Line>
&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;0;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;while&nbsp;i&nbsp;&lt;&nbsp;div_n&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;&lt;-&nbsp;((q&nbsp;lsl&nbsp;1)-b2)&nbsp;lor&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;with&nbsp;bind;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;q[div2_n1]&nbsp;=&nbsp;1&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;&lt;-&nbsp;(q&nbsp;+&nbsp;b2)&nbsp;land&nbsp;0xFFFFFFFE;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;z&nbsp;&lt;-&nbsp;q[0&nbsp;to&nbsp;div_n1];</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
function&nbsp;swap(a:logic[div_n],b:logic[div_n])&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(c:logic[div_n],d:&nbsp;logic[div_n]):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;c&nbsp;<Symbol>&#xac;</Symbol>&nbsp;b,&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;a;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;calc:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;x,y,z:&nbsp;logic[div_n];</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;456,&nbsp;y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;32;</Line>
<Line>
&nbsp;&nbsp;z&nbsp;<Symbol>&#xac;</Symbol>&nbsp;div(x,y);</Line>
<Line>
&nbsp;&nbsp;{x,y}&nbsp;<Symbol>&#xac;</Symbol>&nbsp;swap(x,y);</Line>
<Line>
&nbsp;&nbsp;z&nbsp;<Symbol>&#xac;</Symbol>&nbsp;div(x,y);</Line>
<Line>
end;</Line>
<Line>
</Line>
<Title>
An example showing function definitions and function application. The first function returns one result value, the second a tuple of two values, assigned a
tuple of storage objects (of same type) in line 42.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S3S9" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
I/O: Hardware Port Interface</SectionTitle>
<Section Id = "S3S9S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Components: Interfacing HDL</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S3S9S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
External Module Interface: Embedding HDL</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
</Section>
<Section Id = "S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Abstract Data Type Objects</SectionTitle>
<Para>
Abstract data type objects <Symbol>&#x51;</Symbol> define objects  not directly accessible in expressions like registers (with some exceptions).</Para>
<Para>
Before abstract objects of a particular type can be used, the appropiate module must be opened first: </Para>
<Environment ID = "D10" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
open-module&nbsp;::=&nbsp;'open'&nbsp;mod-name&nbsp;';'&nbsp;.</Line>
<Title>
Opening of a module.</Title>
</Environment>
<Para>
ADT objects can be accessed by their appropiate method set
<Symbol>&#x75;</Symbol>={<Index><I_Body><Symbol>&#x75;</Symbol></I_Body><I_Subscript>1</I_Subscript></Index>,<Index><I_Body><Symbol>&#x75;</Symbol></I_Body><I_Subscript>2</I_Subscript></Index>,...}.
A method is applied using the selector operator followed by a list of arguments passed to method parameters, with arguments separated by a comma list
encapsulated between paranthesis:</Para>
<Environment ID = "D11" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
object-defintion&nbsp;::=&nbsp;'object'&nbsp;obj-name&nbsp;':'&nbsp;obj-type&nbsp;';'&nbsp;.</Line>
<Line>
object-call&nbsp;::=&nbsp;obj-name&nbsp;'.'&nbsp;method-name&nbsp;'('&nbsp;(&nbsp;argument&nbsp;\\&nbsp;','&nbsp;)&nbsp;')'&nbsp;';'&nbsp;.&nbsp;</Line>
<Title>
Object method calls. The object must be first created with the object defintion statement.</Title>
</Environment>
<Para>
Methods which do not expect arguments are applied with an empty argument list (). Table <XRef IDRef = "T21"></XRef> summarizes the statements required for using
abstract object types.</Para>
<Environment ID = "T21" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of abstract object module inclusion, definition and access.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Statement</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> open Module;</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Open specified ADTO module</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> object obj: objtype;</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Defines and instantiates a new object of specified ADT.</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> obj.meth</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Object method access using the selector operator </Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
<Section Id = "S4S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Pseudo-Notation</SectionTitle>
<Para>
In the following sections, an abstract syntax notation is used to define modules of an particular ADTO type with their supported methods. Defintions <XRef IDRef
= "D12"></XRef> to <XRef IDRef = "D15"></XRef> show the formal syntax of this notation. The signature declaration specifies types and the type signature for
each method, the interface declaration defines signals and the RTL access for each method. The implementation definition specifie the behaviout for each
method.</Para>
<Environment ID = "D12" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
module&nbsp;::=&nbsp;'MODULE'&nbsp;name&nbsp;module-decl&nbsp;';'&nbsp;.</Line>
<Line>
module-decl&nbsp;::=&nbsp;signature-decl&nbsp;|&nbsp;implementation-decl&nbsp;|&nbsp;interface-decl&nbsp;.</Line>
<Line>
signature-decl&nbsp;::=&nbsp;'SIGNATURE'&nbsp;{&nbsp;signature&nbsp;}+&nbsp;.</Line>
<Line>
implementation-decl&nbsp;::=&nbsp;'IMPLEMENTATION'&nbsp;{&nbsp;implementation&nbsp;}+&nbsp;.</Line>
<Line>
interface-decl&nbsp;::=&nbsp;'INTERFACE'&nbsp;{&nbsp;interface&nbsp;}+&nbsp;.</Line>
<Line>
signature&nbsp;::=&nbsp;method-decl&nbsp;|&nbsp;type-decl&nbsp;.</Line>
<Line>
implementation&nbsp;::=&nbsp;val-def&nbsp;|&nbsp;method-def&nbsp;.</Line>
<Line>
interface&nbsp;::=&nbsp;signal-def&nbsp;|&nbsp;method-interface&nbsp;.</Line>
<Title>
Pseudo notation for abstract modules: signature and interface declarations, and  implementation defintion. </Title>
</Environment>
<Environment ID = "D13" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
type-decl&nbsp;::=&nbsp;type-abstract&nbsp;|&nbsp;type-struct&nbsp;.</Line>
<Line>
type-abstract&nbsp;::=&nbsp;'TYPE'&nbsp;name&nbsp;.</Line>
<Line>
type-struct&nbsp;::=&nbsp;(&nbsp;'TYPE'&nbsp;name&nbsp;'='&nbsp;'{'&nbsp;)&nbsp;\&lt;&nbsp;(&nbsp;{&nbsp;struct-elem&nbsp;}+&nbsp;)&nbsp;.</Line>
<Line>
struct-elem&nbsp;::=&nbsp;name&nbsp;':'&nbsp;(&nbsp;core-type&nbsp;|&nbsp;symbol-set&nbsp;)&nbsp;.</Line>
<Line>
core-type&nbsp;::=&nbsp;'INT'&nbsp;|&nbsp;'CHAR'&nbsp;|&nbsp;'BOOL'&nbsp;|&nbsp;'FLOAT'&nbsp;.&nbsp;</Line>
<Line>
symbol-set&nbsp;::=&nbsp;'{'&nbsp;{&nbsp;symbol-name&nbsp;}+&nbsp;'}'&nbsp;.</Line>
<Title>
(Cont.) Pseudo notation for abstract modules: type definition.  </Title>
</Environment>
<Environment ID = "D14" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
method-decl&nbsp;::=&nbsp;'METHOD'&nbsp;name&nbsp;':'&nbsp;{&nbsp;argument-type&nbsp;}+&nbsp;.</Line>
<Line>
argument-type&nbsp;::=&nbsp;dir&nbsp;name&nbsp;':'&nbsp;object-type&nbsp;'*'&nbsp;data-type&nbsp;.</Line>
<Line>
dir&nbsp;::=&nbsp;read&nbsp;|&nbsp;write&nbsp;|&nbsp;read-write&nbsp;.</Line>
<Title>
(Cont.) Pseudo notation for abstract modules: method type signature.  </Title>
</Environment>
<Environment ID = "D15" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
object-type&nbsp;::=&nbsp;&nbsp;'reg'&nbsp;|&nbsp;'var'&nbsp;|&nbsp;'reg&nbsp;array'&nbsp;|&nbsp;'var&nbsp;array'&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'reg&nbsp;struct'&nbsp;|&nbsp;'var&nbsp;struct'&nbsp;|&nbsp;'const'&nbsp;.</Line>
<Line>
data-type&nbsp;::=&nbsp;'logic'&nbsp;|&nbsp;'int'&nbsp;|&nbsp;'bool'&nbsp;|&nbsp;'char'&nbsp;.&nbsp;&nbsp;</Line>
<Title>
(Cont.) Pseudo notation for abstract modules: object- and data types.</Title>
</Environment>
<Para>
Table <XRef IDRef = "T22"></XRef> explains symbols used in the notation.</Para>
<Environment ID = "T22" XRefLabel = "Environment" Type = "Table" LineNumbers = "No" Imported = "No">
<Title>
Summary of symbols used in pseudo notation.</Title>
<TABLE  Cols = "2">
<TableBody>
<TableRow>
<TableCell>
<Para>
Statement</Para>
</TableCell>
<TableCell>
<Para>
Decsription</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x47;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Control Path</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x44;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Data Path</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x51;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Abstract Object (Type)</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x75;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Abstract Object Methods</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#xc2;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Data Storage Objects </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#xc1;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
IPC Objects </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> D</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Abstract Computational Objects </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> E</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Abstract External Communication Objects </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x61;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Set of objects (Type)</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x62;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Data Type Set</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x63;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Synthesis Rule Set</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> $</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Parameter variable</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x73;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
State</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x73;</Symbol>+</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Next State</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x51;</Symbol> <Symbol>&#x58;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
List of (blocked) Processes</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#xad;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Output/Write </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#xaf;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Input/Read </Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#x5e;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Suspend a process</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Dingbats>&#x73;</Dingbats></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Resume a process</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> <Symbol>&#xc6;</Symbol></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Empty set or argument list</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a<Index><I_Body>|</I_Body><I_Subscript>b</I_Subscript></Index></Terminal></Para>
</TableCell>
<TableCell>
<Para>
Expression a depends on expression b</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> []</Terminal></Para>
</TableCell>
<TableCell>
<Para>
List/empty List</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> a :: l</Terminal></Para>
</TableCell>
<TableCell>
<Para>
Appends element a to head of list l</Para>
</TableCell>
</TableRow>
<TableRow>
<TableCell>
<Para>
<Terminal> l1 @ l2 </Terminal></Para>
</TableCell>
<TableCell>
<Para>
Concatenates two lists l1 and l2</Para>
</TableCell>
</TableRow>
</TableBody>
</TABLE>
</Environment>
</Section>
<Section Id = "S4S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Interprocess-Communication</SectionTitle>
<Para>
The following ADTOs are available for interprocess communication:</Para>
<List Type = "Numbered">
<Item>
<Para>
Mutex</Para>
</Item>
<Item>
<Para>
Semaphore</Para>
</Item>
<Item>
<Para>
Event</Para>
</Item>
<Item>
<Para>
Barrier</Para>
</Item>
<Item>
<Para>
Timer</Para>
</Item>
<Item>
<Para>
Queue [core]</Para>
</Item>
<Item>
<Para>
Channel [core]</Para>
</Item>
</List>
<Para>
</Para>
<Section Id = "S4S2S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Mutex</SectionTitle>
<Para>
The Mutex module implements a mutual exclusion lock required for protection of shared resources accessed concurrently. All shared atomic objects (both storage
and ADTO) are already implicitly guarded by a mutex lock, serializing the access of the object, including this mutex object, too!</Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
lock</ItemLabel>
<Para>
A process requests the lock with this method. If the mutex is unlocked (not owned by any other process), the calling process gets the lock and continues
operation. If the lock is already owned by another process (mutex is locked), the calling process is blocked untill the mutex owener release the lock using the
unlock method. In this case the calling process P is added to a wait-list <Symbol>&#x58;</Symbol>.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
unlock</ItemLabel>
<Para>
The unlock method releases a previously locked mutex. If there are blocked processes awaiting the release. the next waiting process is scheduled and the lock is
transferred to this process.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
init</ItemLabel>
<Para>
Initialize the mutex object.</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
scheduler</ItemLabel>
<Para>
Selects static or FIFO scheduler policy.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
model</ItemLabel>
<Para>
The model parameter provides two different access models: owner: only the owner process of a mutex can unlock the mutex,  group: each member of a process group
can unlock the mutex. </Para>
</DescriptionItem></DescriptionList>
<Para>
Definitions <XRef IDRef = "D16"></XRef> and <XRef IDRef = "D17"></XRef> specifiy the signature and the implementation of the mutex module, and <XRef IDRef =
"D18"></XRef> the object interface. Two schedulers are available: static priority and dynmaic priority FIFO scheduler.</Para>
<Environment ID = "D16" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Mutex</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;mutex</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;scheduler:&nbsp;{static,fifo}</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;model:&nbsp;{owner,group}</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;mutex&nbsp;[with&nbsp;parameters]:&nbsp;mutex</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;<Symbol>&#xc6;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;lock:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Title>
Signature of ADTO Module Mutex. </Title>
</Environment>
<Environment ID = "D17" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Mutex</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;lock:&nbsp;bool</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol>),&nbsp;P'&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>P'</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;lock:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;lock&nbsp;=&nbsp;false&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;true</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Mutex.</Title>
</Environment>
<Environment ID = "D18" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Mutex</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNALS&nbsp;GD,INIT,UNLOCK,LOCK:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;INIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;UNLOCK&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;lock:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;UNLOCK&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Mutex.</Title>
</Environment>
<Environment ID = "E8" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Mutex;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
reg&nbsp;x,y:&nbsp;int[10];</Line>
<Line>
object&nbsp;mu:&nbsp;mutex;</Line>
<Line>
</Line>
<Line>
</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mu.lock&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;y-1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;y+1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mu.unlock&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;p2:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mu.lock&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;y+1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;y-1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mu.unlock&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;mu.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;100;</Line>
<Line>
&nbsp;&nbsp;y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;100;</Line>
<Line>
&nbsp;&nbsp;p1.start&nbsp;();</Line>
<Line>
&nbsp;&nbsp;p2.start&nbsp;();</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
</Line>
<Title>
A mutex lock is used to protect the access of two global registers x and y.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Semaphore</SectionTitle>
<Para>
The Semaphore module implements a guarded counter <Symbol>&#x77;</Symbol>. A semaphore is used in produce-consumer applications. The counter can be incremented
(up operation) and decremented (down operation). The value of the counter may never be negative. Thus a down operation with an actual semaphore value zero
blocks the requesting process untill another processes increments the semaphore counter. </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
down</ItemLabel>
<Para>
A process decrements the semaphore counter <Symbol>&#x77;</Symbol> <Symbol>&#xac;</Symbol> <Symbol>&#x77;</Symbol>-1 iff <Symbol>&#x77;</Symbol> &gt; 0. In the
case the counter is alreayd zero, the calling process  is blocked untill the semaphore was incremented by another process using the up method. In this case the
calling process P is added to a wait-list <Symbol>&#x58;</Symbol>.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
up</ItemLabel>
<Para>
The up method increments the semaphore counter <Symbol>&#x77;</Symbol> <Symbol>&#xac;</Symbol> <Symbol>&#x77;</Symbol>+1. If there are blocked processes
awaiting an increment the next waiting process is scheduled and <Symbol>&#x77;</Symbol> is still zero (the increment compensates the decrement operation). If
there are no blocked processes the sempahore counter is incremented.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
init</ItemLabel>
<Para>
Initialize the semaphore object with an initial counter value.</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
scheduler</ItemLabel>
<Para>
Selects static or FIFO scheduler policy.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
depth</ItemLabel>
<Para>
The depth parameter specifies the bit width of the semaphore counter, thus the semaphore value can be in the range
[0,<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1]</Para>
</DescriptionItem></DescriptionList>
<Para>
Definitions <XRef IDRef = "D19"></XRef> and <XRef IDRef = "D20"></XRef> specifiy the signature and the implementation of the semaphore module, and <XRef IDRef =
"D21"></XRef>  the interface. Two schedulers are available: static priority and dynmaic priority FIFO scheduler.</Para>
<Environment ID = "D19" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Semaphore</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;semaphore</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;constant:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;scheduler:&nbsp;{static,fifo}</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;depth:&nbsp;[4&nbsp;to&nbsp;16]</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;semaphore&nbsp;[with&nbsp;parameters]:&nbsp;semaphore</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;<Symbol>&#xaf;</Symbol>init-val:(constant&nbsp;|&nbsp;storage-type&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;integer)&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;down:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;up:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Title>
Signature of ADTO Module Semaphore. </Title>
</Environment>
<Environment ID = "D20" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Semaphore</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;lock:&nbsp;bool</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;counter:&nbsp;natural&nbsp;[0,<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1]</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;<Symbol>&#xac;</Symbol>&nbsp;init-val</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;up:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol>&nbsp;=&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;counter</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol>),&nbsp;P'&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>P'</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;down:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;counter&nbsp;&gt;&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;counter</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>&nbsp;@&nbsp;[P],&nbsp;lock&nbsp;<Symbol>&#xac;</Symbol>&nbsp;true</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P</Line>
<Title>
Implementation of ADTO Module Semaphore.</Title>
</Environment>
<Environment ID = "D21" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Semaphore</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;GD,INIT,UP,DOWN:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;WR:&nbsp;logic[depth]</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;INIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WR&nbsp;<Symbol>&#xac;</Symbol>&nbsp;ARG1&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;up:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;UNLOCK&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;down:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;UNLOCK&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Semaphore.</Title>
</Environment>
<Environment ID = "E9" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Semaphore;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
open&nbsp;Event;</Line>
<Line>
object&nbsp;sys:&nbsp;system;</Line>
<Line>
&nbsp;&nbsp;sys.simu_cycles&nbsp;(500);</Line>
<Line>
object&nbsp;ev:&nbsp;event;</Line>
<Line>
</Line>
<Line>
array&nbsp;eating,thinking:&nbsp;reg[5]&nbsp;of&nbsp;logic;</Line>
<Line>
export&nbsp;eating,thinking;</Line>
<Line>
</Line>
<Line>
array&nbsp;fork:&nbsp;object&nbsp;semaphore[5]&nbsp;with&nbsp;depth=8&nbsp;and&nbsp;scheduler="fifo";</Line>
<Line>
</Line>
<Line>
process&nbsp;init:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;4&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;fork.[i].init&nbsp;(1);</Line>
<Line>
&nbsp;&nbsp;ev.init&nbsp;();</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
function&nbsp;eat(n):</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;eating.[n]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;thinking.[n]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end&nbsp;with&nbsp;bind;</Line>
<Line>
&nbsp;&nbsp;wait&nbsp;for&nbsp;5;</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;eating.[n]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;thinking.[n]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;end&nbsp;with&nbsp;bind;</Line>
<Line>
end&nbsp;with&nbsp;inline;</Line>
<Line>
</Line>
<Line>
array&nbsp;philosopher:&nbsp;process[5]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;#&nbsp;&lt;&nbsp;4&nbsp;then</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;ev.await&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;always&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;get&nbsp;left&nbsp;fork&nbsp;then&nbsp;right</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[#].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[#+1].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eat&nbsp;(#);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[#].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[#+1].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;always&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;get&nbsp;right&nbsp;fork&nbsp;then&nbsp;left</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[4].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[0].down&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eat&nbsp;(#);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[4].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fork.[0].up&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;init.call&nbsp;();</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;4&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;philosopher.[i].start&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;ev.wakeup&nbsp;();</Line>
<Line>
end;</Line>
<Title>
Semaphores are used to implement a resource negoatation algorithm: Dining philosophers problem using semaphores.  Five philosophers sit around a circular table.
Each philosopher spends his life alternately thinking and eating. In the center of the table is a large platter of spaghetti. Each philosopher needs two forks
two eat. But there are only five forks for all. One fork is placed between each pair  of philosophers, and they agree that each will use only the forks to the 
immeadiate left and right. [Andrews 2000, Multihtreaded, Parallel, and Distributed Programming]</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Event</SectionTitle>
<Para>
The Event module implements an event handler (abstract signal) and is used for process control flow synchronization (control flow boundary). A group of
processes can join the event handler and wait for the occurrence of this event. The processes are blocked untill the event occurs. The event is signaled by
another process. </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
await</ItemLabel>
<Para>
A process waits for the event associated with the abstract object.  The calling process is blocked untill the event occurs, and P is added to a wait-list
<Symbol>&#x58;</Symbol>.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
wakeup</ItemLabel>
<Para>
The event associated with this abstract object is signaled. All blocked processes waiting for this event are released. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
init</ItemLabel>
<Para>
Initialize the event object.</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
latch</ItemLabel>
<Para>
The latch=1 parameter setting provides a latched event, which causes if an event occured with empty blocked process list, this event is latched. If a process
requests the await method, and the latch is set, it will immediately released.</Para>
</DescriptionItem></DescriptionList>
<Para>
Definitions <XRef IDRef = "D22"></XRef> and <XRef IDRef = "D23"></XRef> specifiy the signature and the implementation of the event module. The <Terminal>
latch=1</Terminal> parameter setting provides a latched event, which means if an event occured with empty blocked process list, this event is latched. If a
process requests the await method, and the latch is set, it will immediately released.</Para>
<Environment ID = "D22" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Event:</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;event</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;latch:&nbsp;{0,1}</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;event&nbsp;[with&nbsp;parameters]:&nbsp;event</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;<Symbol>&#xc6;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Title>
Signature of ADTO Module Event.</Title>
</Environment>
<Environment ID = "D23" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Event:</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;if&nbsp;$latch=1&nbsp;then&nbsp;VAR&nbsp;latch:&nbsp;bool</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$latch=1&nbsp;then&nbsp;latch&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$latch=1&nbsp;then&nbsp;latch&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$latch=1&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;latch&nbsp;=&nbsp;true&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;latch&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Event.</Title>
</Environment>
<Environment ID = "D24" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Event</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNALS&nbsp;GD,INIT,WAKEUP,AWAIT:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;INIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;WAKEUP&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;AWAIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Event.</Title>
</Environment>
<Environment ID = "E10" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
</Line>
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Event;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
</Line>
<Line>
object&nbsp;sys:system;</Line>
<Line>
&nbsp;&nbsp;sys.sim_cycles(300);</Line>
<Line>
</Line>
<Line>
object&nbsp;e:&nbsp;event;</Line>
<Line>
</Line>
<Line>
array&nbsp;d:&nbsp;reg[4]&nbsp;of&nbsp;int[8];</Line>
<Line>
</Line>
<Line>
export&nbsp;d;</Line>
<Line>
</Line>
<Line>
array&nbsp;p:&nbsp;process[4]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;e.await&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;#&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;e.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;3&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;p.[i].start&nbsp;();&nbsp;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;20;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;e.wakeup&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Title>
An event synchronize the control flow of several processes. The processes of array p are started sequentially, but they are all suspended untill the event is
signaled by the main process. This happens again in each loop iteration.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Barrier</SectionTitle>
<Para>
The barrier module implements a self synchonization event handler (abstract signal) and is used for process control flow synchronization (control flow
boundary). A group of processes with defined number N can join the barrier and wait for the occurrence of the event. The processes are blocked untill the event
occurs. The event is signaled by the last process N joining the barrier. Each time a proces join the barriers, a counter <Terminal> join</Terminal> is
incremented.  </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
await</ItemLabel>
<Para>
A process waits for the barrier event associated with the abstract object.  The calling process is blocked untill the event occurs, and P is added to a
wait-list <Symbol>&#x58;</Symbol>. The event happens when <Terminal> size(</Terminal><Terminal> <Symbol>&#x58;</Symbol></Terminal><Terminal>
)=join=N</Terminal>.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
init</ItemLabel>
<Para>
Initialize the barrier object with size of joining process group. The process group size N is automatically determnined by  the number of differernt processes
calling the await method.</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<Para>
<Symbol>&#xc6;</Symbol></Para>
<Para>
Definitions <XRef IDRef = "D25"></XRef> and <XRef IDRef = "D26"></XRef> specifiy the signature and the implementation of the barrier module, and <XRef IDRef =
"D27"></XRef>  the process interface. </Para>
<Environment ID = "D25" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Barrier:</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;barrier</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;barrier&nbsp;[with&nbsp;parameters]:&nbsp;barrier</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;<Symbol>&#xc6;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Title>
Signature of ADTO Module Barrier.</Title>
</Environment>
<Environment ID = "D26" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Barrier:</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;size,join:&nbsp;natural</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;size&nbsp;<Symbol>&#xac;</Symbol>&nbsp;sizeof(<Index><I_Body><Symbol>&#x46;</Symbol></I_Body><I_Subscript>await</I_Subscript></Index>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;join&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xac;</Symbol>[]&nbsp;</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(join+1)&nbsp;=&nbsp;size&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xac;</Symbol>[]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;join</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Barrier.</Title>
</Environment>
<Environment ID = "D27" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Barrier</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNALS&nbsp;GD,INIT,AWAIT:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;INIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;AWAIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Barrier.</Title>
</Environment>
<Environment ID = "E11" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
</Line>
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Barrier;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
</Line>
<Line>
object&nbsp;sys:system;</Line>
<Line>
&nbsp;&nbsp;sys.sim_cycles(300);</Line>
<Line>
</Line>
<Line>
object&nbsp;b:&nbsp;barrier;</Line>
<Line>
</Line>
<Line>
array&nbsp;d:&nbsp;reg[4]&nbsp;of&nbsp;int[8];</Line>
<Line>
</Line>
<Line>
export&nbsp;d;</Line>
<Line>
</Line>
<Line>
array&nbsp;p:&nbsp;process[4]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;b.await&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;#&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;b.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;--&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;64;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;3&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;p.[i].start&nbsp;();&nbsp;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Title>
A group of processes defined in array p wait for the barrier b event. The loop iteration of each process starts at the same time. </Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Timer</SectionTitle>
<Para>
The Timer module implements an interval timer and is used for time constrained process control flow synchronization. A group of processes can join the timer
handler and wait for the occurrence of this time event. The processes are blocked untill the event occurs. The event is signaled by the timeout of the timer.
The timer can operate one-time and continously. </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
await</ItemLabel>
<Para>
A process waits for the timer event associated with the abstract object.  The calling process is blocked untill the timer event occurs, and P is added to a
wait-list <Symbol>&#x58;</Symbol>.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
wakeup</ItemLabel>
<Para>
Wakeup all blocked processes.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
init</ItemLabel>
<Para>
Initialize the timer object.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
time</ItemLabel>
<Para>
Set interval time of timer in nano seconds (or in time unit specified). </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
start</ItemLabel>
<Para>
Start the timer.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
stop</ItemLabel>
<Para>
Stop the timer.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
sig_action</ItemLabel>
<Para>
A signal can be used to check the actual state of the timer: enabled or disabled. Can be used in one-shot timer mode to check the timeout. The activity level
and the default signal value must be specified, too.</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
time</ItemLabel>
<Para>
The timer interval period time in nano seconds.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
mode</ItemLabel>
<Para>
The mode parameter specifies timer operation: one-time/shot (1) or continously (0).</Para>
</DescriptionItem></DescriptionList>
<Para>
Definitions <XRef IDRef = "D28"></XRef> and <XRef IDRef = "D29"></XRef> specifiy the signature and the implementation of the timer module. </Para>
<Environment ID = "D28" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Timer</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;timer</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;time:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mode:&nbsp;{0,1}</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;timer&nbsp;[with&nbsp;parameters]:&nbsp;timer</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;<Symbol>&#xc6;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;time:&nbsp;<Symbol>&#xaf;</Symbol>period:natural</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;mode:&nbsp;<Symbol>&#xaf;</Symbol>mode:natural</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;sig_action:&nbsp;<Symbol>&#xaf;</Symbol>sig:(output&nbsp;signal&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;logic)&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>action_level:logic&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>def_level:logic</Line>
<Title>
Signature of ADTO Module Timer.</Title>
</Environment>
<Environment ID = "D29" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Timer</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;time,timer:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;mode:&nbsp;natural&nbsp;{0,1}</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;enabled:&nbsp;bool</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;count,counter:&nbsp;natural</Line>
<Line>
&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;<Symbol>&#xac;</Symbol>&nbsp;clkcycles($time)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;enabled&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mode&nbsp;<Symbol>&#xac;</Symbol>&nbsp;$mode</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;start:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;<Symbol>&#xac;</Symbol>&nbsp;count</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;enabled&nbsp;<Symbol>&#xac;</Symbol>&nbsp;true</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;stop:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;enabled&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;time:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;<Symbol>&#xac;</Symbol>&nbsp;clkcycles($ARG1)</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;mode:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;mode&nbsp;<Symbol>&#xac;</Symbol>&nbsp;$ARG1</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P</Line>
<Line>
&nbsp;&nbsp;PROCESS&nbsp;timer:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;CLK'event:&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;enabled&nbsp;=&nbsp;true&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;counter&nbsp;=&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;<Symbol>&#xce;</Symbol>&nbsp;<Symbol>&#x51;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mode&nbsp;=&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;<Symbol>&#xac;</Symbol>&nbsp;count</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;counter</Line>
<Line>
&nbsp;</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Timer.</Title>
</Environment>
<Environment ID = "D30" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Timer</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;GD,INIT,WAKEUP,AWAIT,TIME_SET,START,STOP:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;TIME:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;init:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;INIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;start:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;START&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;stop:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;STOP&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;time:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;TIME_SET&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIME&nbsp;<Symbol>&#xac;</Symbol>&nbsp;index($time,$ARG1)&nbsp;--&nbsp;List&nbsp;index&nbsp;of&nbsp;time&nbsp;value</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;wakeup:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;WAKEUP&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;await:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;AWAIT&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Timer.</Title>
</Environment>
<Environment ID = "E12" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Timer;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
</Line>
<Line>
object&nbsp;sys:system;</Line>
<Line>
&nbsp;&nbsp;sys.sim_cycles(300);</Line>
<Line>
</Line>
<Line>
object&nbsp;t:&nbsp;timer;</Line>
<Line>
&nbsp;&nbsp;t.time&nbsp;(1&nbsp;microsec);</Line>
<Line>
</Line>
<Line>
array&nbsp;d:&nbsp;reg[4]&nbsp;of&nbsp;int[8];</Line>
<Line>
</Line>
<Line>
export&nbsp;d;</Line>
<Line>
</Line>
<Line>
array&nbsp;p:&nbsp;process[4]&nbsp;of</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;5&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;t.await&nbsp;();</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;#&nbsp;+&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;d.[#]&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;t.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;t.time&nbsp;(2&nbsp;microsec);</Line>
<Line>
&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;0&nbsp;to&nbsp;3&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;p.[i].start&nbsp;();&nbsp;</Line>
<Line>
&nbsp;&nbsp;t.mode&nbsp;(0);</Line>
<Line>
&nbsp;&nbsp;t.start&nbsp;();</Line>
<Line>
end;</Line>
<Line>
</Line>
<Title>
Timer example.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Queue</SectionTitle>
<Para>
The queue is both a core and abstract object data type. Queues can be used directly in expressions (read and write). The queue buffers data words written from
processes to the queue for processes requesting a read operation. The data word order is FIFO.   </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
read</ItemLabel>
<Para>
A process reading a queue is blocked untill at least one data word is available.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
write</ItemLabel>
<Para>
A process writing to a queue is blocked untill at least one data word cell is free to hold the new value.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
unlock</ItemLabel>
<Para>
This method releases all blocked processes (both waiting for read and write completion). </Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
depth</ItemLabel>
<Para>
Number of cell of the data queue: <Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Para>
</DescriptionItem></DescriptionList>
<Environment ID = "D31" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Queue</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;queue</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;depth:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;queue&nbsp;<Emphasis>name</Emphasis>:&nbsp;data-type&nbsp;[with&nbsp;parameters]:&nbsp;object-type</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:&nbsp;<Symbol>&#xad;</Symbol>data:data-type</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;mode:&nbsp;<Symbol>&#xaf;</Symbol>data:data-type</Line>
<Title>
Signature of ADTO Module Queue.</Title>
</Environment>
<Environment ID = "D32" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Queue</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>,<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;avail,free,size:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;<Symbol>&#x66;</Symbol>:&nbsp;data-type&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;d:&nbsp;data-type</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;RESET:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;size&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;free&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;avail&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xc8;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol><Symbol>&#xac;</Symbol>[],&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol><Symbol>&#xac;</Symbol>[]&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;avail&nbsp;&gt;&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;avail,&nbsp;incr&nbsp;free</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x66;</Symbol>),&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x66;</Symbol>)&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>),&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>&nbsp;P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;d</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;free&nbsp;&gt;&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;avail,&nbsp;decr&nbsp;free</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x66;</Symbol>&nbsp;@&nbsp;[<Symbol>&#xaf;</Symbol>]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>),&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>&nbsp;P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;free&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;avail&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xc8;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol><Symbol>&#xac;</Symbol>[],&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol><Symbol>&#xac;</Symbol>[]&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Queue.</Title>
</Environment>
<Environment ID = "D33" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Queue</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;GD,RE,WE:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;RD,WR:&nbsp;data-type</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;RE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;RD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;WE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;WR&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Queue.</Title>
</Environment>
<Para>
</Para>
</Section>
<Section Id = "S4S2S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Channel</SectionTitle>
<Para>
The channel is both a core and abstract object data type. Queues can be used directly in expressions (read and write). A channel is a special case of a queue.
The depth of the buffer is either 1 (buffered) or 0 (unbuffered). The channel provides a handshake for data transfer between processes. </Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
read</ItemLabel>
<Para>
A process reading a channel is blocked untill one data word is available.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
write</ItemLabel>
<Para>
A process writing to a queue is blocked untill there is a ready reader (unbuffered version) or the channel is empty (buffered version).</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
unlock</ItemLabel>
<Para>
This method releases all blocked processes (both waiting for read and write completion). </Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
depth</ItemLabel>
<Para>
Number of cell of the data queue: {0,1}</Para>
</DescriptionItem></DescriptionList>
<Environment ID = "D34" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Channel</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;channel</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;depth:&nbsp;{0,1}</Line>
<Line>
&nbsp;&nbsp;}&nbsp;</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;channel&nbsp;<Emphasis>name</Emphasis>:&nbsp;data-type&nbsp;[with&nbsp;parameters]:&nbsp;object-type</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:&nbsp;<Symbol>&#xad;</Symbol>data:data-type</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;mode:&nbsp;<Symbol>&#xaf;</Symbol>data:data-type</Line>
<Title>
Signature of ADTO Module Channel.</Title>
</Environment>
<Environment ID = "D35" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Channel</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>,<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;avail,free,size:&nbsp;natural</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;<Symbol>&#x66;</Symbol>:&nbsp;data-type&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;d:&nbsp;data-type</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;RESET:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;size&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;free&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;avail&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xc8;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol><Symbol>&#xac;</Symbol>[],&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol><Symbol>&#xac;</Symbol>[]&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;avail&nbsp;&gt;&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;avail,&nbsp;incr&nbsp;free</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x66;</Symbol>),&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x66;</Symbol>)&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>),&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>&nbsp;P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xad;</Symbol>d</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;free&nbsp;&gt;&nbsp;0&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;avail,&nbsp;decr&nbsp;free</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x66;</Symbol>&nbsp;@&nbsp;[<Symbol>&#xaf;</Symbol>]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xb9;</Symbol>&nbsp;[]&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;HEAD(<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>),&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;TAIL(<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Dingbats>&#x73;</Dingbats>&nbsp;P</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;<Symbol>&#xac;</Symbol>&nbsp;SELF</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;@&nbsp;[P]</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x5e;</Symbol>P&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;unlock:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;free&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Index><I_Body>2</I_Body><I_Superscript>depth</I_Superscript></Index>-1</Line>
<Line>
&nbsp;&nbsp;&nbsp;avail&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x66;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;[]&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x22;</Symbol>&nbsp;P&nbsp;in&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>&nbsp;<Symbol>&#xc8;</Symbol>&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>:&nbsp;<Dingbats>&#x73;</Dingbats>P</Line>
<Line>
&nbsp;&nbsp;&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol><Symbol>&#xac;</Symbol>[],&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol><Symbol>&#xac;</Symbol>[]&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Channel.</Title>
</Environment>
<Environment ID = "D36" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Channel</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;GD,RE,WE:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;RD,WR:&nbsp;data-type</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;(avail&nbsp;&gt;&nbsp;0&nbsp;<Symbol>&#xda;</Symbol>&nbsp;<Dingbats>&#x73;</Dingbats>P)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;RE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;RD&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;(free&nbsp;&gt;&nbsp;0&nbsp;<Symbol>&#xda;</Symbol>&nbsp;<Dingbats>&#x73;</Dingbats>P)&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;WE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;WR&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Channel.</Title>
</Environment>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S4S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
External Communication</SectionTitle>
<Section Id = "S4S3S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Link </SectionTitle>
<Para>
The Link module implements a bidirectional asynchronous parallel communication interface using dual rail data encoding and a 4-phase handshake protocol. A link
is used to connect different circuit components with different or skewed clock domains. </Para>
<Para>
Arbitrary data widths [1<Symbol>&#xbc;</Symbol>64] bits are supported. There is an outgoing and incoming link, requiring each 2*datawidth data lines D and one
acknowledge signal A: D<Symbol>&#xad;</Symbol> and A<Symbol>&#xaf;</Symbol> for the outgoing, and D<Symbol>&#xaf;</Symbol> and A<Symbol>&#xad;</Symbol> for the
incoming link.</Para>
<Para>
The following object methods are available:</Para>
<Para>
METHODS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
start</ItemLabel>
<Para>
Enables the LINK component.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
stop</ItemLabel>
<Para>
Disables the LINK component.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
read</ItemLabel>
<Para>
Read one data byte from the incoming link. This method blocks the calling process untill a data word was received. There is no receive queue, therefore if more
than one data byte was received the old ones are overriden!</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
write</ItemLabel>
<Para>
Write one data byte to the outgoing link. The calling process is blocked untill the data word was processed and acknowledged by the receiving end.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
interface</ItemLabel>
<Para>
Binds external signals (data and acknowledge, both for incoming and outgoing link).</Para>
</DescriptionItem></DescriptionList>
<Para>
PARAMETERS</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
datawidth</ItemLabel>
<Para>
Datawidth of link.</Para>
</DescriptionItem></DescriptionList>
<Para>
Definitions <XRef IDRef = "D37"></XRef> and <XRef IDRef = "D38"></XRef> specifiy the signature and the implementation of the link module.</Para>
<Environment ID = "D37" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Link:</Line>
<Line>
SIGNATURE</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;link</Line>
<Line>
 &nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;NEW&nbsp;<Symbol>&#xba;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;<Emphasis>name</Emphasis>:&nbsp;link:&nbsp;link</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;parameters&nbsp;=&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;datawidth:&nbsp;natural=[1,64];</Line>
<Line>
&nbsp;&nbsp;}</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;data-type:&nbsp;logic[datawidth]</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;data-type2:&nbsp;logic[2*data-width]</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;storage-type:&nbsp;register&nbsp;|&nbsp;variable&nbsp;|&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg-array-selector&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var-array-selector&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg-struct-selector&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var-struct-selector</Line>
<Line>
&nbsp;&nbsp;TYPE&nbsp;constant:&nbsp;data-type</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;start:&nbsp;<Symbol>&#xc6;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;stop:&nbsp;<Symbol>&#xc6;</Symbol></Line>
<Line>
 </Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>data:(storage-type&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;data-type)&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>err:(storage-type&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;bool)</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xad;</Symbol>data:(storage-type&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;data-type&nbsp;|&nbsp;constant)&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>err:(stoarge-type&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;bool)</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;interface:&nbsp;</Line>
<Line>
<Emphasis>&nbsp;&nbsp;&nbsp;&nbsp;</Emphasis><Emphasis><Symbol>&#xaf;</Symbol></Emphasis>data-in:(input&nbsp;signal&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;data-type2)&nbsp;<Symbol>&#xb4;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>data-in-ack:(output&nbsp;signal&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;logic)&nbsp;<Symbol>&#xb4;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>data-out:(output&nbsp;signal&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;data-type2)&nbsp;<Symbol>&#xb4;</Symbol></Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#xaf;</Symbol>data-out-ack:(input&nbsp;signal&nbsp;<Symbol>&#xb4;</Symbol>&nbsp;logic)</Line>
<Line>
 </Line>
<Title>
Signature of ADTO Module Link.  </Title>
</Environment>
<Environment ID = "D38" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Link:</Line>
<Line>
IMPLEMENTATION</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;<Symbol>&#x51;</Symbol><Symbol>&#xad;</Symbol>,<Symbol>&#x51;</Symbol><Symbol>&#xaf;</Symbol>,<Symbol>&#x46;</Symbol>:&nbsp;process&nbsp;list</Line>
<Line>
&nbsp;&nbsp;VAR&nbsp;P,P':&nbsp;process</Line>
<Line>
&nbsp;&nbsp;OBJ&nbsp;S:&nbsp;scheduler</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;enable:&nbsp;bool</Line>
<Line>
&nbsp;&nbsp;VAL&nbsp;din_compl,din_empty:&nbsp;logic</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;start:&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;enable&nbsp;<Symbol>&#xac;</Symbol>&nbsp;true</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;stop:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;enable&nbsp;<Symbol>&#xac;</Symbol>&nbsp;false</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;din_empty=1&nbsp;--&nbsp;await&nbsp;empty&nbsp;set&nbsp;(data-in)</Line>
<Line>
&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;di_compl=1&nbsp;&nbsp;--&nbsp;await&nbsp;data&nbsp;(data-in)</Line>
<Line>
&nbsp;&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;decode(data-in)</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-in-ack&nbsp;<Symbol>&#xac;</Symbol>&nbsp;1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;0</Line>
<Line>
&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;d</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;$ARG1</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-out&nbsp;<Symbol>&#xac;</Symbol>&nbsp;encode(<Symbol>&#xc6;</Symbol>)&nbsp;&nbsp;--&nbsp;send&nbsp;empty&nbsp;set&nbsp;(data-out)</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-out&nbsp;<Symbol>&#xac;</Symbol>&nbsp;encode(d)&nbsp;&nbsp;--&nbsp;send&nbsp;data&nbsp;(data-out)</Line>
<Line>
&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;data-out-ack=0&nbsp;--&nbsp;await&nbsp;empty&nbsp;set&nbsp;ack.&nbsp;(data-out-ack&nbsp;1<Symbol>&#xae;</Symbol>0),&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;data-out-ack=1&nbsp;--&nbsp;await&nbsp;data&nbsp;acknowledge&nbsp;(data-out-ack&nbsp;0<Symbol>&#xae;</Symbol>1)</Line>
<Line>
&nbsp;&nbsp;PROCESS:</Line>
<Line>
&nbsp;&nbsp;&nbsp;din_empty&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x22;</Symbol>&nbsp;i&nbsp;<Symbol>&#xce;</Symbol>&nbsp;[0,data_width-1]:&nbsp;<Symbol>&#x50;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>data-in.[2*i]&nbsp;<Symbol>&#xd9;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>data-in.[2*i+1]</Line>
<Line>
&nbsp;&nbsp;&nbsp;din_compl&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x22;</Symbol>&nbsp;i&nbsp;<Symbol>&#xce;</Symbol>&nbsp;[0,data_width-1]:&nbsp;<Symbol>&#x50;</Symbol>&nbsp;data-in.[2*i]&nbsp;<Symbol>&#xc5;</Symbol>&nbsp;data-in.[2*i+1]&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;interface:</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-in&nbsp;<Symbol>&#xdc;</Symbol>&nbsp;$ARG1</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-in-ack&nbsp;<Symbol>&#xdc;</Symbol>&nbsp;$ARG2</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-out&nbsp;<Symbol>&#xdc;</Symbol>&nbsp;$ARG3</Line>
<Line>
&nbsp;&nbsp;&nbsp;data-out-ack&nbsp;<Symbol>&#xdc;</Symbol>&nbsp;$ARG4</Line>
<Line>
&nbsp;&nbsp;FUN&nbsp;encode:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;FUN&nbsp;decode:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
 </Line>
<Title>
Implementation of ADTO Module Link.</Title>
</Environment>
<Environment ID = "D39" XRefLabel = "Environment" Type = "Definition" LineNumbers = "No" Imported = "No">
<Line>
MODULE&nbsp;Link</Line>
<Line>
INTERFACE</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;GD,RE,WE,START,STOP:&nbsp;logic</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;RD,WR:&nbsp;data-type</Line>
<Line>
&nbsp;&nbsp;SIGNAL&nbsp;RD_ERR,WR_ERR:&nbsp;logic&nbsp;(bool)</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;start:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;START&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;stop:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;STOP&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;read:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;RE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;<Symbol>&#xac;</Symbol>&nbsp;RD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG2&nbsp;<Symbol>&#xac;</Symbol>&nbsp;RD_ERR&nbsp;</Line>
<Line>
&nbsp;&nbsp;METHOD&nbsp;write:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x47;</Symbol>:&nbsp;<Symbol>&#x73;</Symbol>&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#x73;</Symbol>&nbsp;|&nbsp;GD=1&nbsp;//</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x73;</Symbol>+&nbsp;|&nbsp;GD=0&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;<Symbol>&#x44;</Symbol>:&nbsp;WE&nbsp;<Symbol>&#xac;</Symbol>&nbsp;<Symbol>&#xd8;</Symbol>GD</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WR&nbsp;<Symbol>&#xac;</Symbol>&nbsp;$ARG1&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ARG2&nbsp;<Symbol>&#xac;</Symbol>&nbsp;WR_ERR&nbsp;</Line>
<Line>
 </Line>
<Title>
Interface of ADTO Module Link.</Title>
</Environment>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
open&nbsp;Core;</Line>
<Line>
open&nbsp;Process;</Line>
<Line>
open&nbsp;Link;</Line>
<Line>
open&nbsp;System;</Line>
<Line>
</Line>
<Line>
type&nbsp;dev_type:{</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_din:&nbsp;input&nbsp;logic[20];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_din_ack:&nbsp;output&nbsp;logic;</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_dout:&nbsp;output&nbsp;logic[20];</Line>
<Line>
&nbsp;&nbsp;port&nbsp;ln_dout_ack:&nbsp;input&nbsp;logic;</Line>
<Line>
};</Line>
<Line>
component&nbsp;DEV:&nbsp;dev_type;</Line>
<Line>
export&nbsp;DEV;</Line>
<Line>
</Line>
<Line>
object&nbsp;sys:&nbsp;system;</Line>
<Line>
&nbsp;&nbsp;sys.simu_cycles(100);</Line>
<Line>
</Line>
<Line>
object&nbsp;ln:&nbsp;link&nbsp;with&nbsp;datawidth=10;</Line>
<Line>
&nbsp;&nbsp;ln.interface(DEV.ln_din,DEV.ln_din_ack,DEV.ln_dout,DEV.ln_dout_ack);</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
reg&nbsp;x,y:&nbsp;int[10];</Line>
<Line>
reg&nbsp;xa,ya:&nbsp;int[8];</Line>
<Line>
export&nbsp;x,y,xa,ya;</Line>
<Line>
exception&nbsp;Exit;</Line>
<Line>
</Line>
<Line>
process&nbsp;p1:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;err:bool;</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;d:logic[10];</Line>
<Line>
&nbsp;&nbsp;try</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xa&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'r';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ln.read&nbsp;(d,err);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xa&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'.';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;err&nbsp;=&nbsp;true&nbsp;then&nbsp;raise&nbsp;Exit;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_int(d);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;with</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;Exit:&nbsp;ln.stop&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
process&nbsp;p2:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;err:bool;</Line>
<Line>
&nbsp;&nbsp;reg&nbsp;d:logic[10];</Line>
<Line>
&nbsp;&nbsp;try</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;1&nbsp;to&nbsp;10&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<Symbol>&#xac;</Symbol>&nbsp;to_logic(i);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<Symbol>&#xac;</Symbol>&nbsp;i;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ya&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'w';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ln.write(d,err);</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ya&nbsp;<Symbol>&#xac;</Symbol>&nbsp;'.';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;err&nbsp;=&nbsp;true&nbsp;then&nbsp;raise&nbsp;Exit;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;with</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;Exit:&nbsp;ln.stop&nbsp;();</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
process&nbsp;main:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;ln.init&nbsp;();</Line>
<Line>
&nbsp;&nbsp;ln.start&nbsp;();</Line>
<Line>
&nbsp;&nbsp;p1.start&nbsp;();</Line>
<Line>
&nbsp;&nbsp;p2.start&nbsp;();</Line>
<Line>
end;</Line>
<Title>
More complex example of a Link component used by two processes, one reading from the link, and one writing to the link.</Title>
</Environment>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S4S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Data Processing</SectionTitle>
<Section Id = "S4S4S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Random</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
</Section>
<Section Id = "S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Hardware and System Architecture</SectionTitle>
<Section Id = "S5S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Introduction</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Modules and Processes</SectionTitle>
<Para>
...</Para>
<Section Id = "S5S2S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Modules</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S2S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Processes</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section Id = "S5S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Block Strcutures</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Data Objects and Data Types</SectionTitle>
<Para>
...</Para>
<Section Id = "S5S4S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Registers</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S4S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Variables</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S4S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Signals</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S4S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Expressions and Assignments</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section Id = "S5S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Interprocess-Communication</SectionTitle>
<Para>
...</Para>
<Section Id = "S5S5S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Mutex</SectionTitle>
<Para>
...</Para>
<Environment ID = "A3" XRefLabel = "Environment" Type = "Algorithm" LineNumbers = "No" Imported = "No">
<Title>
The static priority mutex access scheduler with embedded mutex implementation.</Title>
<Line>
MUTEX_$O_SCHED:&nbsp;#process&nbsp;($scheduler="static")</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;$CLK&nbsp;then</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$RES&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.lock&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.init&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;MUTEX_$O_$p_INIT&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$l&nbsp;in&nbsp;$P.lock&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;MUTEX_$O_$l_LOCKed&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$l_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$l_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.lock&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;MUTEX_$O_$p_LOCK&nbsp;=&nbsp;'1'&nbsp;and&nbsp;MUTEX_$O_LOCKed&nbsp;&nbsp;=&nbsp;'0'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_LOCKed&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$model&nbsp;=&nbsp;"owner"&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.unlock&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;MUTEX_$O_$p_UNLOCK&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$model&nbsp;=&nbsp;"group"&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.unlock&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;MUTEX_$O_$p_UNLOCK&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;member($P.lock,$p)&nbsp;=&nbsp;true&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
</Environment>
</Section>
<Section Id = "S5S5S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Semaphore</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S5S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Event</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S5S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Barrier</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S5S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Timer</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S5S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Queue</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S5S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Channel</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section Id = "S5S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
External Communication</SectionTitle>
<Section Id = "S5S6S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Link</SectionTitle>
<Para>
A link belongs to the class of external IO components, providing handshaked data exchange with the outside world, requiring interconnect both with ConPro
processes using internal signals <Index><I_Body><Symbol>&#xc3;</Symbol></I_Body><I_Subscript>int</I_Subscript></Index> and external signals
<Index><I_Body><Symbol>&#xc3;</Symbol></I_Body><I_Subscript>ext</I_Subscript></Index>. Because a link is a sheared resource, a scheduler is invoked.</Para>
<Environment ID = "G2" XRefLabel = "Environment" Type = "Graph" LineNumbers = "No" Imported = "No">
<Title>
Link Block Interconnect</Title>
<Line>
digraph&nbsp;H&nbsp;{</Line>
<Line>
&nbsp;&nbsp;PORT&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label="{PORT|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&lt;s1&gt;DOUT-2|&lt;s2&gt;DOUT-ACK|&lt;s3&gt;DIN-2|&lt;s4&gt;DIN-ACK}}"];</Line>
<Line>
&nbsp;&nbsp;subgraph&nbsp;cluster0&nbsp;{</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;LINKOUT&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label="{{&lt;e1&gt;DOUT-2|&lt;e2&gt;DOUT-ACK}|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINK-OUT|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&lt;s1&gt;DOUT|&lt;s2&gt;WE|&lt;s3&gt;BUSY}}"];</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;LINKIN&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label="{{&lt;e1&gt;DIN-2|&lt;e2&gt;DIN-ACK}|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINK-IN|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&lt;s1&gt;DIN|&lt;s2&gt;RE|&lt;s3&gt;AVAIL}}"];</Line>
<Line>
&nbsp;&nbsp;};</Line>
<Line>
&nbsp;&nbsp;SCHED&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label="{{&lt;s1&gt;DOUT|&lt;s2&gt;WE|&lt;s3&gt;BUSY|&lt;s4&gt;DIN|&lt;s5&gt;RE|&lt;s6&gt;AVAIL}|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCHEDULER|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&lt;r1&gt;START-i|&lt;r2&gt;STOP-i|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;r3&gt;READ-i|&lt;r4&gt;WRITE-i|&lt;r5&gt;DATA_RD-i|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;r6&gt;DATA_WR-i|&lt;g1&gt;GD-i}}"];&nbsp;</Line>
<Line>
&nbsp;&nbsp;PRO&nbsp;[shape=record,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label="{{&lt;rp1&gt;START|&lt;rp2&gt;STOP|&lt;rp3&gt;READ|&lt;rp4&gt;WRITE|\</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rp5&gt;DATA_RD|&lt;rp6&gt;DATA_WR|&lt;gp&gt;GD}|PRO-i}"];</Line>
<Line>
&nbsp;&nbsp;SCHED:g1&nbsp;-&gt;&nbsp;PRO:gp;</Line>
<Line>
&nbsp;&nbsp;PRO:rp1&nbsp;-&gt;&nbsp;SCHED:r1;</Line>
<Line>
&nbsp;&nbsp;PRO:rp2&nbsp;-&gt;&nbsp;SCHED:r2;</Line>
<Line>
&nbsp;&nbsp;PRO:rp3&nbsp;-&gt;&nbsp;SCHED:r3;</Line>
<Line>
&nbsp;&nbsp;PRO:rp4&nbsp;-&gt;&nbsp;SCHED:r4;</Line>
<Line>
&nbsp;&nbsp;SCHED:r5&nbsp;-&gt;&nbsp;PRO:rp5;&nbsp;</Line>
<Line>
&nbsp;&nbsp;PRO:rp6&nbsp;-&gt;&nbsp;SCHED:r6;</Line>
<Line>
&nbsp;&nbsp;SCHED:s1&nbsp;-&gt;&nbsp;LINKOUT:s1;</Line>
<Line>
&nbsp;&nbsp;SCHED:s2&nbsp;-&gt;&nbsp;LINKOUT:s2;</Line>
<Line>
&nbsp;&nbsp;LINKOUT:s3&nbsp;-&gt;&nbsp;SCHED:s3;</Line>
<Line>
&nbsp;&nbsp;SCHED:s5&nbsp;-&gt;&nbsp;LINKIN:s2;</Line>
<Line>
&nbsp;&nbsp;LINKIN:s1&nbsp;-&gt;&nbsp;SCHED:s4;</Line>
<Line>
&nbsp;&nbsp;LINKIN:s3&nbsp;-&gt;&nbsp;SCHED:s6;</Line>
<Line>
&nbsp;&nbsp;LINKOUT:e1&nbsp;-&gt;&nbsp;PORT:s1;</Line>
<Line>
&nbsp;&nbsp;PORT:s2&nbsp;-&gt;&nbsp;LINKOUT:e2;</Line>
<Line>
&nbsp;&nbsp;PORT:s3&nbsp;-&gt;&nbsp;LINKIN:e1;</Line>
<Line>
&nbsp;&nbsp;LINKIN:e2&nbsp;-&gt;&nbsp;PORT:s4;</Line>
<Line>
}</Line>
</Environment>
</Section>
</Section>
<Section Id = "S5S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Types</SectionTitle>
<Para>
...</Para>
<Section Id = "S5S7S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Data Types</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S7S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Abstract Object Types</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S7S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Product Types: Array</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S7S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Product Types: Structure</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S7S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Sum Types: Enumeration</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S7S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Exceptions</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section Id = "S5S8" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Control Statements</SectionTitle>
<Section Id = "S5S8S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Counting for-Loop</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Conditional while-Loop</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Endless always-Loop</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Blocking wait-for-Loop</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Conditional if-else-Branch</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Multicase match-Branch</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S8S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Exception Handler</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section Id = "S5S9" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
I/O: Hardware Port Interface</SectionTitle>
<Section Id = "S5S9S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Components: Interfacing HDL</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S5S9S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
External Module Interface: Embedding HDL</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
</Section>
<Section Id = "S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
External Module Interface EMI</SectionTitle>
<Para>
The External Module Interface (EMI) is used to connect and merge VHDL modelled components with the CONPRO process framework. </Para>
<Para>
The purpose of the EMI module interface is to embedd and connect external VHDL code directly into a ConPro implementation with direct access from inside ConPro
processes using the Abstract Data Type Object (ADTO) method interface and method calls. In contrast to  external VHDL components requiring signal objects for
interconnection with ConPro, here VHDL processes are linked invisible and transparent to the programmer view with the ConPro ADTO interface.</Para>
<Para>
An EMI module can be opened and compiled using the <Terminal> open</Terminal> statement.</Para>
<Para>
The EMI module is splitted in the access and implementation part of an abstract object.  The EMI module file (file suffix .mod) defines</Para>
<List Type = "Numbered">
<Item>
<Para>
all methods available for object access,</Para>
</Item>
<Item>
<Para>
the method access, on ConPro process level defining data and control path parts and the implementation (scheduling) of the object access, too,</Para>
</Item>
<Item>
<Para>
all required signals for process interconnect and implementation,</Para>
</Item>
<Item>
<Para>
the implementation of the abstract object using VHDL processes.</Para>
</Item>
</List>
<Para>
Each EMI module defines a new abstract object type. Objects can be created from this new type. </Para>
<Para>
The EMI language is a modified subset of VHDL, aligned to ConPro programming language concepts. The language semantic is layered on  hardware behaviour level
using signal objects.</Para>
<Para>
</Para>
<Section Id = "S6S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Parameter Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #parameter</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;$pname;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;$pname&nbsp;&lt;=&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;$pname[n1,n2,n3,...]&nbsp;&lt;=&nbsp;m;&nbsp;&nbsp;--&nbsp;(3)</Line>
<Line>
&nbsp;&nbsp;$pname[a&nbsp;to&nbsp;b]&nbsp;&lt;=&nbsp;m;&nbsp;&nbsp;--&nbsp;(4)</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
This is the paramter section.  Parameters can be used inside the EMI module file. New values can be assigned either on object creation or using method calls
(set method class). </Para>
<Para>
This section defines the parameter variables used in an external module interface definition .  Different forms of parameter definitions are provided:</Para>
<List Type = "Numbered">
<Item>
<Para>
Giving only the parameter name preceeded by the $ character defines a variable without any default and initialized value.  On object instantiation the parameter
must be assigned a value otherwise an error occurs during synthesis, or using the set class method alternatively.</Para>
</Item>
<Item>
<Para>
In this case the parameter variable gets a default value. Parameter value assignment on object instantiation is optional.</Para>
</Item>
<Item>
<Para>
In this case the parameter variable gets a default value. Parameter value assignment on object instantiation is optional. Additional  a set  of allowed values
is included in paranthesises after the parameter name. </Para>
</Item>
<Item>
<Para>
In this case the parameter variable gets a default value. Parameter value assignment on object instantiation is optional. Additional  a range  of allowed values
is included in paranthesises after the parameter name. </Para>
</Item>
</List>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;$datawidth[8,10,12,14,16]&nbsp;&lt;=&nbsp;8;</Line>
<Line>
&nbsp;&nbsp;$seed&nbsp;&lt;=&nbsp;0xffff;</Line>
<Line>
&nbsp;&nbsp;$arch001["fifo","static"]&nbsp;&lt;=&nbsp;"fifo"</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Methods Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #methods</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#methods</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;mname(exprside:datatype&nbsp;[,exprside:datatype]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
exprside&nbsp;::=&nbsp;'#lhs'&nbsp;|&nbsp;'#rhs'&nbsp;|&nbsp;'#lrhs'</Line>
<Line>
datatype&nbsp;::=&nbsp;'logic'&nbsp;|&nbsp;'logic['&nbsp;width&nbsp;']'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'int['&nbsp;width&nbsp;']'&nbsp;|&nbsp;'bool'&nbsp;|&nbsp;'natural'</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
This is the method programming interface declaration section of the EMI module file. This section defines all exported and accessible methods,  specifying  the
method name and the method call parameter type declaration:</Para>
<List Type = "Numbered">
<Item>
<Para>
the way the argument objects are used during method call, either on left-hand-side (LHS) or right-hand-side (RHS) (or both) of an expression, meaning read or
write access respectively of the object used as an argument,</Para>
</Item>
<Item>
<Para>
the expected data type of the argument object,  though width scaling of the actual argument used in method call to the expected method paramter used in the ADTO
implementation is supported by the EMI compiler.</Para>
</Item>
</List>
<Para>
If a method doesn't expect an argument, an empty paranthesis pair () is used in the definition. Up to 9 method call parameters can be specified.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;$datawidth[8&nbsp;to&nbsp;16]&nbsp;&lt;=&nbsp;8;</Line>
<Line>
&nbsp;&nbsp;$addrwidth&nbsp;&lt;=&nbsp;16;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
#methods</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;init();</Line>
<Line>
&nbsp;&nbsp;read(#lhs:logic[12]);</Line>
<Line>
&nbsp;&nbsp;time(#rhs:natural);</Line>
<Line>
&nbsp;&nbsp;read2(#lhs:logic[$datawidth],#rhs:logic[$addrwidth]);</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Interface Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #interface</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#interface</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;sname_$O&nbsp;:&nbsp;dir&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;sname_$O&nbsp;:&nbsp;dir&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.meth&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(3)</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;sname_$O&nbsp;:&nbsp;dir&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
dir&nbsp;::=&nbsp;'in'&nbsp;|&nbsp;'out'&nbsp;|&nbsp;'inout'</Line>
<Line>
datatype&nbsp;::=&nbsp;'logic'&nbsp;|&nbsp;'logic['&nbsp;width&nbsp;']'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'int['&nbsp;width&nbsp;']'&nbsp;|&nbsp;bool&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'std_logic'&nbsp;|&nbsp;'std_logic_vector['&nbsp;width&nbsp;']'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'signed['&nbsp;width&nbsp;']'</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
<Highlight>ConPro-Process-Level</Highlight></Para>
<Para>
This interface section defines the part of the VHDL component port interface required for implementation of ConPro processes accessing methods of this ADT
object. ConPro processes are synthesized to VHDL components and RTL and a finite-state-machine (FSM). The ConPro module toplevel is synthesized and mapped to a
VHDL  component, too, implementing ConPro toplevel objects. Additionally, the synthesized ConPro-process VHDL-components are structurally connected on this
module level. An abstract object access requires data and control signals, routed up from the ConPro-process level to the ConPro-module level where the abstract
object is implemented, except of abstract objects defined on ConPro process level.</Para>
<Para>
There are two ways for adding process port signals:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
(1,2)</ItemLabel>
<Para>
Generic signals independent on a particular method access. These signals are added to the VHDL process port for each process using the abstract object.  The
signal name can contain  the object name variable <Terminal> $O</Terminal>. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(3)</ItemLabel>
<Para>
Signals depending  on ConPro processes accessing this object and a specific method. The signal name can contain  the object name variable <Terminal>
$O</Terminal>. The signal definifion adds  the signal only  for  ConPro processes  using this object method. </Para>
</DescriptionItem></DescriptionList>
<Para>
The signal port direction and the signal type must be specified. </Para>
<Para>
Supported signal directions are:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
in</ItemLabel>
<Para>
The related process  reads from this signal.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
out</ItemLabel>
<Para>
The related process writes to this signal. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
inout</ItemLabel>
<Para>
The related process both reads from and writes to the signal. This is the bidirectional bus behaviour.</Para>
</DescriptionItem></DescriptionList>
<Para>
Supported signal types are aligned to the core ConPro data type system, and they are:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
logic</ItemLabel>
<Para>
ConPro <Terminal> logic</Terminal> data type,  width 1 bit, mapped in general to the VHDL std_logic type. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
logic[n]</ItemLabel>
<Para>
ConPro <Terminal> logic</Terminal> data type, width n bit, index range is in general [n-1 downto 0], mapped in general to the VHDL std_logic_vector(n-1 downto
0)  type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
int[n]</ItemLabel>
<Para>
ConPro signed integer (<Terminal> int</Terminal>) data type, width n bit, index range is in general <Terminal> [n-1 downto 0]</Terminal>, mapped in general to
the VHDL <Terminal> signed(n-1 downto 0)</Terminal>  type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
bool</ItemLabel>
<Para>
ConPro boolean (bool) data type,   mapped in general to the VHDL <Terminal> std_logic</Terminal> type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
std_logic</ItemLabel>
<Para>
VHDL <Terminal> std_logic type</Terminal> </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
std_logic_vector[n]</ItemLabel>
<Para>
VHDL <Terminal> std_logic_vector(n-1 downto 0)</Terminal> type. Index direction and range depends also on ConPro synthesis settings.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
signed[n]</ItemLabel>
<Para>
VHDL <Terminal> signed(n-1 downto 0)</Terminal>  type. Index direction and range depends also on ConPro synthesis settings.</Para>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#interface</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.read&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_RE:&nbsp;out&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_RD:&nbsp;in&nbsp;std_logic_vector[$datawidth];</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.init&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_INIT:&nbsp;out&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_GD:&nbsp;in&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Mapping Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #mapping</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#mapping</Line>
<Line>
begin&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signame_$O&nbsp;=&gt;&nbsp;signame_$O_$p;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.meth&nbsp;do&nbsp;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signame_$O&nbsp;=&gt;&nbsp;signame_$O_$p;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
<Highlight>ConPro-Module-Level</Highlight></Para>
<Para>
This mapping section defines the part of the VHDL component port mapping required for implementation of ConPro processes accessing methods of this ADT object.
ConPro processes are synthesized to VHDL components and RTL and a finite-state-machine (FSM). The ConPro module toplevel is synthesized and mapped to a VHDL 
component, too, implementing ConPro toplevel objects. Additionally, the synthesized ConPro-process VHDL-components are structurally connected and mapped on this
module level. An abstract object access requires data and control signals, routed up from the ConPro-process level to the ConPro-module level where the abstract
object is implemented, except of abstract objects defined on ConPro process level.</Para>
<Para>
On the left hand side there is the (local) ConPro-process context level (VHDL entity port interface) signal, on the right hand side there is the (global)
ConPro-module context level signal (VHDL component port mapping on instantiation).  The object name $O and process name $P are replaced respectively. All signal
mappings appearing in this section  must be defined in the <Terminal> #interface</Terminal>  section.</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
(1)</ItemLabel>
<Para>
The signal mapping is applied to each process accessing this object.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(2)</ItemLabel>
<Para>
The signal mapping is applied to each process accessing this object with a specified method.</Para>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#mapping</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$P.read&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_RE&nbsp;=&gt;&nbsp;F_$O_$P_RE;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_RD&nbsp;=&gt;&nbsp;F_$O_$P_RD;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$P.init&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_INIT&nbsp;=&gt;&nbsp;F_$O_$P_INIT;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_GD&nbsp;=&gt;&nbsp;F_$O_$P_GD;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Access Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #access</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
method:#access</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;#data</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;signame_$O&nbsp;&lt;=&nbsp;expr1&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;expr0;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;&nbsp;$ARG#&nbsp;&lt;=&nbsp;signame_$O&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;expr0;&nbsp;--&nbsp;(1b)</Line>
<Line>
&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;#control&nbsp;</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;null;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;cond-expr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(3)</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;#set</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;$param&nbsp;&lt;=&nbsp;$ARG#;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(4)</Line>
<Line>
&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
<Highlight>ConPro-Process-Level</Highlight></Para>
<Para>
ConPro processes are synthesized to VHDL components and RTL and a finite-state-machine (FSM). The ConPro module toplevel is synthesized and mapped to a VHDL 
component, too, implementing ConPro toplevel objects. Additionally, the synthesized ConPro-process VHDL-components are structurally connected and mapped on this
module level. An abstract object access requires data and control signals, routed up from the ConPro-process level to the ConPro-module level where the abstract
object is implemented, except of abstract objects defined on ConPro process level.For each method defined in the<Terminal>  #methods</Terminal> section there is
an access definition. </Para>
<Para>
An access definition consists of the data and control path of a ConPro-process defined in subsections #data and #control respectively.  There are methods only
required for setting object parameters on toplevel. In this case the #set subsection is used instead, but can be used additionally to data and control path
sections.</Para>
<Para>
The data path defines expression assignments 1. of local signals, 2. of values to  object access signals defined in the <Terminal> #interface</Terminal>
section, or 3. alternatively assigning  these object access signals to a method call argument. The method call arguments are related with the variables 
<Terminal> $ARG1, $ARG2, $ARG3...</Terminal> for the first, the second, the third ... method call argument. </Para>
<Para>
The control path is used to suspend the ConPro process control state machine (calling this method) untill a condition is satisfied, mainly the object
guard.</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
(1)</ItemLabel>
<Para>
Expression expr1 is assigned to the LHS signal during access, expression expr0 otherwise. Independent of the data type of the LHS, expr0 can be the natural
number 0.  The data type of the LHS object is determined automatically in this case, and hence the VHDL value to be assigned, too.</Para>
<Para>
The LHS is an object access signal. The RHS can be an object access signal, a method call argument or a constant value.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(1b)</ItemLabel>
<Para>
An object access signal or a constant value is assigned to the method call argument <Terminal> $ARG#</Terminal>.  The variable <Terminal> $ARG#</Terminal> is
substituted with the actual argument signal name. Control signals required for the method argument acces (like the write enable signal)  are generated
automatically by the synthesis compiler!</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(2)</ItemLabel>
<Para>
There is no control path statement. Object access never blocks control path and consumes exactly on time unit. Else case (3) must be applied:</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(3)</ItemLabel>
<Para>
The method access  blocks the control path of the calling ConPro process untill condition cond-expr is satisfied. Else case (2) must be applied. Usually the
object guard signal is used for blocking:</Para>
<Para>
<Terminal> signame_$o_GD = '0'</Terminal>;</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(4)</ItemLabel>
<Para>
The actual argument value is assigned to the parameter variable on the LHS.  This is a method call statement used only for configuration of the object, either
on toplevel outside processes or inisde a process! Either an integer value can be assigned or a data object can be imported and accessed inside the ADTO
implementation (actually only signals and registers with read access only).</Para>
</DescriptionItem></DescriptionList>
<Para>
Environment variables are always array types. Each time the set subsection is used to assign argument values to an environment variable, the actual value is
added to this array. Therefore some array functions exists which can be used in expressions. For example it is desired to work with different baud rates of a
serial communication link, and the baud rate should be changeable during runtime. In this case it is not usefull to pass the original baud rate value eacht time
a aspecified set method occurs in ConPro-processes, it is more likely to pass an index value requiring much less bits to each method call.  Here is an example
to implement such an method access (time) for the case of a timer (using the environment variable $time):</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
time:&nbsp;#access</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;#set</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$time&nbsp;&lt;=&nbsp;$arg1;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;#data</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_TIME_SET&nbsp;&lt;=&nbsp;'1'&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_TIME&nbsp;&lt;=&nbsp;#index($time,$ARG1)&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;#control</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;TIMER_$O_GD&nbsp;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;&nbsp;</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
init:&nbsp;#access</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;#data</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_INIT&nbsp;&lt;=&nbsp;'1'&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;#control</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;null;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
read:&nbsp;#access</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;#data</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;F_$O_RE&nbsp;&lt;=&nbsp;'1'&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$ARG1&nbsp;&lt;=&nbsp;F_$O_RD&nbsp;when&nbsp;$ACC&nbsp;else&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;#control</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;F_$O_GD&nbsp;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
time:&nbsp;#access</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;#set</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$time&nbsp;&lt;=&nbsp;$ARG1;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Signals Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #signals</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#signals&nbsp;&nbsp;&nbsp;[(cond)]</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;$signame_$O&nbsp;:&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;$signame_$O_$p&nbsp;:&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.meth&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;$signame_$O_$p&nbsp;:&nbsp;datatype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(3)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;type&nbsp;typname&nbsp;is&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(4)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;el1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;el2;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;};</Line>
<Line>
&nbsp;&nbsp;type&nbsp;typname&nbsp;array[range]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(5)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;datatype;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
datatype&nbsp;::=&nbsp;'logic'&nbsp;|&nbsp;'logic['&nbsp;width&nbsp;']'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'int['&nbsp;width&nbsp;']'&nbsp;|&nbsp;bool&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'std_logic'&nbsp;|&nbsp;'std_logic_vector['&nbsp;width&nbsp;']'&nbsp;|</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'signed['&nbsp;width&nbsp;']'</Line>
<Line>
cond&nbsp;::=&nbsp;'$'&nbsp;param&nbsp;'='&nbsp;value&nbsp;[&nbsp;'and'&nbsp;'$'&nbsp;param&nbsp;'='&nbsp;value...]</Line>
<Line>
range&nbsp;::=&nbsp;a&nbsp;'to'&nbsp;b&nbsp;|&nbsp;a&nbsp;'downto'&nbsp;b&nbsp;|&nbsp;size</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
<Highlight>ConPro-Module-Level</Highlight></Para>
<Para>
This section defines VHDL signals required for object implementation on global module level, and data and control signals required for method access from ConPro
processes. Remember the ConPro system hierarchy: there is a process level and a module level containing processes. Each ConPro process is synthesized into a
VHDL component entity. A ConPro module is also synthesized into a VHDL component entity, providing the interconnections for all contained ConPro processes. Each
process accessing this ADT object requires it own set of data and control signals.</Para>
<Para>
There can be exist more than one signals section. There are unconditional (the usual case) and conditional signals sections, only applied if parameter
conditions are satisfied. </Para>
<Para>
There are three different signal classes:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
(1)</ItemLabel>
<Para>
Generic signals independent on ConPro processes and method access, mainly implementation dependent.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(2)</ItemLabel>
<Para>
Signals depending on ConPro processes accessing this object. The signal name can contain the ConPro process name variable <Terminal> $P</Terminal> (array,
foreach statement required) and the object name variable <Terminal> $O</Terminal>. The signal definifion adds for each ConPro process accessing this object the
specified signal, the process variable is replaced by the related process name. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(3)</ItemLabel>
<Para>
Signals depending  on ConPro processes and method access. The signal name can contain the ConPro process name variable <Terminal> $P</Terminal> (array, foreach
statement required) and the object name variable <Terminal> $O.</Terminal> The signal definifion adds for each ConPro process accessing this object and applying
the specified method the specified signal, the process variable is replaced by the related process name. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(4)</ItemLabel>
<Para>
Definition of an enumerated symbolic type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
(5)</ItemLabel>
<Para>
Definition of an array type.</Para>
</DescriptionItem></DescriptionList>
<Para>
Supported signal types are aligned to the core ConPro data type system, and they are:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
logic</ItemLabel>
<Para>
ConPro <Terminal> logic</Terminal> data type,  width 1 bit, mapped in general to the VHDL std_logic type. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
logic[n]</ItemLabel>
<Para>
ConPro <Terminal> logic</Terminal> data type, width n bit, index range is in general [n-1 downto 0], mapped in general to the VHDL std_logic_vector(n-1 downto
0)  type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
int[n]</ItemLabel>
<Para>
ConPro signed integer (<Terminal> int</Terminal>) data type, width n bit, index range is in general <Terminal> [n-1 downto 0]</Terminal>, mapped in general to
the VHDL <Terminal> signed(n-1 downto 0)</Terminal>  type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
bool</ItemLabel>
<Para>
ConPro boolean (bool) data type,   mapped in general to the VHDL <Terminal> std_logic</Terminal> type.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
std_logic</ItemLabel>
<Para>
VHDL <Terminal> std_logic type</Terminal> </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
std_logic_vector[n]</ItemLabel>
<Para>
VHDL <Terminal> std_logic_vector(n-1 downto 0)</Terminal> type. Index direction and range depends also on ConPro synthesis settings.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
signed[n]</ItemLabel>
<Para>
VHDL <Terminal> signed(n-1 downto 0)</Terminal>  type. Index direction and range depends also on ConPro synthesis settings.</Para>
</DescriptionItem></DescriptionList>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#signals</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;--&nbsp;Implementation&nbsp;signals</Line>
<Line>
&nbsp;&nbsp;--</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_d_in:&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_data_shift:&nbsp;std_logic_vector[$datawidth];</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_data:&nbsp;std_logic_vector[$datawidth*2-1];</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_shift:&nbsp;std_logic;&nbsp;</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_init:&nbsp;std_logic;&nbsp;</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_avail:&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.read&nbsp;do&nbsp;</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_$p_RE:&nbsp;std_logic;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_$p_RD:&nbsp;std_logic_vector[$datawidth];</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.init&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_$p_INIT:&nbsp;std_logic;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;end;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;F_$O_$p_GD:&nbsp;std_logic;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
#signals&nbsp;($datawidth=8)</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_count:&nbsp;std_logic_vector[3];</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
#signals&nbsp;($datawidth=10)</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;signal&nbsp;F_$O_count:&nbsp;std_logic_vector[4];</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S6S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Process Section</SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #process</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
procname:#process&nbsp;&nbsp;&nbsp;[(cond)]</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
cond&nbsp;::=&nbsp;'$'&nbsp;param&nbsp;'='&nbsp;value&nbsp;['and'&nbsp;'$'&nbsp;param&nbsp;'='&nbsp;value...]</Line>
<Line>
</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
<Highlight>ConPro-Module-Level</Highlight></Para>
<Para>
This section defines a named  VHDL hardware process (procname) required for the implementation of an object on hardwae behaviour level. There can be several
process sections, each defining one process appearing on ConPro-module level, or in some limited cases on ConPro-process level iff the object  has only a ConPro
process local context and was defined inside a ConPro process.  A VHDL hardware process implementation can be conditional (cond).</Para>
<Para>
At least one process must exist for the object implementation: the access scheduler guarding the (usually) shared object. Several ConPro processes can access a
shared object, therefore some kind of mutual exclusion lock must be implemented. The main object implementation, modelling the behaviour of this ADTO,  is
usually modelled within a separate VHDL process definition. </Para>
<Para>
Parameter variables are extensively used inside the VHDL hardware process definition:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
$CLK</ItemLabel>
<Para>
This parameter is used inside conditional expressions and is only true if there is a system clock event. The clock edge is determined by the ConPro program and
compiler settings, and expands to VHDL:</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
$CLK&nbsp;=&gt;&nbsp;conpro_system_clk'event&nbsp;and&nbsp;conpro_system_clk&nbsp;=&nbsp;'1'&nbsp;--&nbsp;rising&nbsp;edge&nbsp;</Line>
<Line>
$CLK&nbsp;=&gt;&nbsp;conpro_system_clk'event&nbsp;and&nbsp;conpro_system_clk&nbsp;=&nbsp;'0'&nbsp;--&nbsp;falling&nbsp;edge&nbsp;&nbsp;</Line>
</Environment>
<Para>
The clock signals are already defined and may not be defined in the  <Terminal> #signals</Terminal> section.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$RES</ItemLabel>
<Para>
This parameter is used inside conditional expressions and is only true if the system reset is active. The active reset signal  logic level is determined by the
ConPro program and compiler settings, and expands to VHDL:</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
$RES&nbsp;=&gt;&nbsp;conpro_system_reset&nbsp;=&nbsp;'1'&nbsp;&nbsp;</Line>
<Line>
$RES&nbsp;=&gt;&nbsp;conpro_system_reset&nbsp;=&nbsp;'0'&nbsp;&nbsp;&nbsp;</Line>
</Environment>
<Para>
The reset signals are already defined and may not be defined in the  <Terminal> #signals</Terminal> section.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$myreg</ItemLabel>
<Para>
ConPro data objects (actually only signals) can be imported into an object module. For example a module implements a bus interface, than external bus signals
must be imported. They are attached to a module parameter $myreg (or any other name excpet reserved parameters) using the access set method, defined in the
<Terminal>  #access</Terminal> section.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
EMI:</Line>
<Line>
&nbsp;&nbsp;#methods</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;set(#rhs:logic[8]);</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;set:#access</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;#set:</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$myreg&nbsp;&lt;=&nbsp;$ARG1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;#process</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;&lt;=&nbsp;$myreg;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$myreg&nbsp;&lt;=&nbsp;s;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
...</Line>
<Line>
ConPro:&nbsp;</Line>
<Line>
&nbsp;&nbsp;myobj.set(sigx1y);</Line>
<Line>
</Line>
<Line>
VHDL:</Line>
<Line>
&nbsp;&nbsp;s&nbsp;&lt;=&nbsp;$myreg;&nbsp;=&gt;&nbsp;s&nbsp;&lt;=&nbsp;sigx1y_RD;</Line>
<Line>
&nbsp;&nbsp;$myreg&nbsp;&lt;=&nbsp;s;&nbsp;=&gt;&nbsp;sigx1y_WR&nbsp;&lt;=&nbsp;s;</Line>
<Line>
</Line>
</Environment>
<Para>
The imported signals are already defined and may not be defined in the  <Terminal> #signals</Terminal> section.</Para>
</DescriptionItem></DescriptionList>
<Para>
The sensivity list of the VHDL process is computed automatically.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
VHDL Subset</ItemLabel>
<Para>
Only a subset of VHDL is supported, and there are some adjustments on syntax level to the ConPro programming language.</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
if-then-else</ItemLabel>
<Para>
Syntax is slightly modified. A group of statements requires block environment begin-end. </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;;</Line>
<Line>
if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;else&nbsp;statement;</Line>
<Line>
statement&nbsp;::=&nbsp;single-statement&nbsp;|&nbsp;'begin'&nbsp;statement-list&nbsp;'end'</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
if-then-else-cascade</ItemLabel>
<Para>
Either modelled using the elsif VHDL or else if ConPro construct or modelled with the sequence construct. </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;else&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;...;</Line>
<Line>
if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;elsif&nbsp;expr&nbsp;then&nbsp;statement&nbsp;...;</Line>
<Line>
statement&nbsp;::=&nbsp;single-statement&nbsp;|&nbsp;'begin'&nbsp;statement-list&nbsp;'end'</Line>
<Line>
</Line>
<Line>
sequence</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.meth&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;if&nbsp;others&nbsp;then&nbsp;statement;</Line>
<Line>
end;</Line>
</Environment>
<Para>
The sequence is expanded to a if-then-elsif cascade.  The last case (optional) is the default case if no other conditional expression can be applied.</Para>
<Para>
Example:</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
sequence</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;a&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;if&nbsp;b&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;2;</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.init&nbsp;do&nbsp;</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;c_$p&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;3;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;if&nbsp;others&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;4;</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
<Highlight>=&gt;&nbsp;expands&nbsp;to&nbsp;=&gt;</Highlight></Line>
<Line>
</Line>
<Line>
if&nbsp;a&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;0</Line>
<Line>
elsif&nbsp;b&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;2</Line>
<Line>
elsif&nbsp;c_p1&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;3</Line>
<Line>
elsif&nbsp;c_p2&nbsp;=&nbsp;'1'&nbsp;then&nbsp;s&nbsp;&lt;=&nbsp;3</Line>
<Line>
else&nbsp;s&nbsp;&lt;=&nbsp;4;&nbsp;</Line>
</Environment>
<Para>
During synthesis, conditional expressions, containing only constant values and environment variables, are tried to be evaluated to constant values. Depending on
the result either the true or the false case statements are replaced by the conditional statement. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
case</ItemLabel>
<Para>
Syntax is slightly modified and aligned to the ConPro programming language. A group of statements requires block environment begin-end.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
case&nbsp;expr&nbsp;is</Line>
<Line>
begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;when&nbsp;val1&nbsp;:&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;when&nbsp;val2&nbsp;:&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
&nbsp;&nbsp;when&nbsp;others&nbsp;:&nbsp;statement;</Line>
<Line>
end;</Line>
<Line>
statement&nbsp;::=&nbsp;single-statement&nbsp;|&nbsp;'begin'&nbsp;statement-list&nbsp;'end'&nbsp;|&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'null'</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
for</ItemLabel>
<Para>
Syntax is slightly modified and aligned to the ConPro programming language. A group of statements requires block environment begin-end.  The loop variable i can
be used in expressions within the loop body. Environment array variables  (preceeded with a $) can be iterated in a for-loop, too.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
for&nbsp;i&nbsp;=&nbsp;expr&nbsp;dir&nbsp;expr&nbsp;do</Line>
<Line>
&nbsp;&nbsp;statement;</Line>
<Line>
for&nbsp;$i&nbsp;in&nbsp;$array&nbsp;do</Line>
<Line>
&nbsp;&nbsp;statement;</Line>
<Line>
dir&nbsp;::=&nbsp;'to'&nbsp;|&nbsp;'downto'&nbsp;</Line>
<Line>
statement&nbsp;=&nbsp;single-statement&nbsp;|&nbsp;'begin'&nbsp;statement-list&nbsp;'end'&nbsp;</Line>
<Line>
</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
constant values</ItemLabel>
<Para>
Syntax  is slightly modified:  </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
...</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
process variables</ItemLabel>
<Para>
VHDL process variables are defined at the beginning of the process section body:</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#process:</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;variable&nbsp;vname:&nbsp;datatype;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Expressions</ItemLabel>
<Para>
VHDL expressions can contain any VHDL operator (arithmetic, logic, relational, boolean), vector subranges [] and the object selector '''. </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
+&nbsp;-&nbsp;*&nbsp;/&nbsp;...</Line>
<Line>
&lt;&nbsp;&gt;&nbsp;=&nbsp;/=&nbsp;&lt;=&nbsp;&gt;=&nbsp;</Line>
<Line>
and&nbsp;or&nbsp;xor&nbsp;...</Line>
<Line>
obj[range]</Line>
<Line>
obj'sel</Line>
<Line>
range&nbsp;::=&nbsp;&nbsp;a&nbsp;'to'&nbsp;b&nbsp;|&nbsp;a&nbsp;'downto'&nbsp;b&nbsp;</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Environment Variables</ItemLabel>
<Para>
VHDL expressions can contain environment variables, those names are preceeded by a $, both on left-hand- and right-hand-side of expressions. </Para>
<Para>
Usually values are assigned in <Terminal> #parameter</Terminal> sections, on object creation and within <Terminal> #set</Terminal> subsections of <Terminal>
#access </Terminal>sections. Environment variables are always of array type. That means each time a new value is assigned to an environment variable, a new
array element is created an appended.  A scalar read access of an environment variable returns the top of the array (the last element stored). But there are
builtin functions to access array elements. </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
$name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;scalar&nbsp;read&nbsp;access&nbsp;of&nbsp;an&nbsp;</Line>
<Line>
&nbsp;&nbsp;environment&nbsp;variable&nbsp;</Line>
<Line>
size($array)&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;number&nbsp;of&nbsp;array&nbsp;elements&nbsp;</Line>
<Line>
&nbsp;&nbsp;actually&nbsp;stored&nbsp;in&nbsp;the&nbsp;array</Line>
<Line>
width($array)&nbsp;&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;number&nbsp;of&nbsp;bits&nbsp;required&nbsp;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;the&nbsp;maximal&nbsp;value&nbsp;in&nbsp;array&nbsp;</Line>
<Line>
&nbsp;&nbsp;and&nbsp;weighted&nbsp;binary&nbsp;coding</Line>
<Line>
index_width($array)&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;number&nbsp;of&nbsp;bits&nbsp;required&nbsp;</Line>
<Line>
&nbsp;&nbsp;for&nbsp;the&nbsp;index&nbsp;of&nbsp;an&nbsp;array</Line>
<Line>
&nbsp;&nbsp;and&nbsp;weighted&nbsp;binary&nbsp;coding</Line>
<Line>
index($array,value)&nbsp;&nbsp;&lt;=&gt;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;the&nbsp;binary&nbsp;coded&nbsp;index&nbsp;</Line>
<Line>
&nbsp;&nbsp;selector&nbsp;for&nbsp;value&nbsp;element</Line>
<Line>
&nbsp;&nbsp;contained&nbsp;in&nbsp;array</Line>
<Line>
min($array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;minimal&nbsp;value&nbsp;of&nbsp;all&nbsp;</Line>
<Line>
&nbsp;&nbsp;elements&nbsp;in&nbsp;the&nbsp;array</Line>
<Line>
max($array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;=&gt;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;returns&nbsp;maximal&nbsp;value&nbsp;of&nbsp;all&nbsp;</Line>
<Line>
&nbsp;&nbsp;elements&nbsp;in&nbsp;the&nbsp;array</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Printing</ItemLabel>
<Para>
During object synthesis informational text lines can be printed to the standard output channel using the <Terminal> print</Terminal> function.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#print("Achieved&nbsp;baud&nbsp;rate&nbsp;accuracy&nbsp;[bit/s]:&nbsp;",</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"[actual&nbsp;=&nbsp;",$clock&nbsp;/&nbsp;(($clock&nbsp;/&nbsp;(16&nbsp;*&nbsp;$ARG1))*16),"]&nbsp;",</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"[requested&nbsp;=&nbsp;",$ARG1,"]&nbsp;",</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"[error&nbsp;=&nbsp;",((($clock&nbsp;/&nbsp;(($clock&nbsp;/&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(16&nbsp;*&nbsp;$ARG1))*16))*1000)/$ARG1)-1000,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;%%]"&nbsp;);</Line>
</Environment>
</DescriptionItem></DescriptionList>
</DescriptionItem><DescriptionItem><ItemLabel>
Process Access and Scheduler</ItemLabel>
<Para>
Access of ADT objects  requires control and data signals. In the case of data based objects (for example a queue or RAM), ConPro method calls activate control
signals, and either write to or read from data signals, commonly:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Control Signals</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
T_$O_RE:&nbsp;Read&nbsp;Request&nbsp;Enable</Line>
<Line>
T_$O_WE:&nbsp;Write&nbsp;Request&nbsp;Enable</Line>
<Line>
T_$O_GD:&nbsp;Object&nbsp;Guard</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Data Signals</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
T_$O_RD:&nbsp;Read&nbsp;Data&nbsp;Signal&nbsp;Vector</Line>
<Line>
T_$O_WR:&nbsp;Write&nbsp;Data&nbsp;Signal&nbsp;Vector</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
In the case of pure control objects (for example a semaphore), only control signals are activated. Of course for special purpose objects different signals are
required. </Para>
<Para>
Because several ConPro processes can access a shared object, access serialization and blocking of method caller processes are required. If there is actually
already an object access, method call from other processes must be blocked untill the reosurce is available. For this purpose the gurad signal is used. As long
as the signal is in state '1', the calling process FSM will be blocked. </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Warning and Limitations</ItemLabel>
<Para>
Only a subset of VHDL is supported, and there are some adjustments on syntax level to the ConPro programming language. Mainly, the EMI-language is context free.
That means that function call arguments are enclosed in round paranthesis, thereby range expressions (both in signal declarations and within expression) are
enclosed in bracket paranthesis!</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
TIMER_$O_SCHED:&nbsp;#process&nbsp;</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;if&nbsp;$CLK&nbsp;then</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$RES&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_ENABLED&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_MODE&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(0,width((max($time)*$clock)/1000000000));</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNT&nbsp;&lt;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic((nth($time,1)*$clock)/1000000000,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width((max($time)*$clock)/1000000000));</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.await&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$arch002&nbsp;=&nbsp;2&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_ENABLED&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_COUNTER&nbsp;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(0,width((max($time)*$clock)/1000000000))&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.await&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_LOCKed&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_MODE&nbsp;=&nbsp;'0'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;TIMER_$O_COUNT;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_ENABLED&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;TIMER_$O_COUNTER&nbsp;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.init&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_INIT&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(0,width((max($time)*$clock)/1000000000));</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNT&nbsp;&lt;=&nbsp;to_logic((nth($tim</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$arch001&nbsp;=&nbsp;1&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.await&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_AWAIT&nbsp;=&nbsp;'1'&nbsp;and&nbsp;TIMER_$O_$p_LOCKed&nbsp;&nbsp;=&nbsp;'0'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$arch001&nbsp;=&nbsp;2&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;expand($P.await,$p,or,TIME_$O_$p_AWAIT&nbsp;=&nbsp;'1'&nbsp;and&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;=&nbsp;'0')&nbsp;then&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.await&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_AWAIT&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.start&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_START&nbsp;=&nbsp;'1'&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;TIMER_$O_COUNT;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_ENABLED&nbsp;&lt;=&nbsp;'1';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.stop&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_STOP&nbsp;=&nbsp;'1'&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(0,width((max($time)*$clock)/1000000000));</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_ENABLED&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.time&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_TIME_SET&nbsp;=&nbsp;'1'&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$this_time&nbsp;in&nbsp;$time&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_TIME&nbsp;=&nbsp;index($time,$this_time)&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNT&nbsp;&lt;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(($this_time*$clock)/1000000000,</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width((max($time)*$clock)/1000000000));</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.mode&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_MODE_SET&nbsp;=&nbsp;'1'&nbsp;&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_MODE&nbsp;&lt;=&nbsp;TIMER_$O_$p_MODE;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;$arch002&nbsp;=&nbsp;1&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;others&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_ENABLED&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_COUNTER&nbsp;=&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_logic(0,width((max($time)*$clock)/1000000000))&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;$p&nbsp;in&nbsp;$P.await&nbsp;do</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_$p_LOCKed&nbsp;=&nbsp;'1'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_LOCKed&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_$p_GD&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;TIMER_$O_MODE&nbsp;=&nbsp;'0'&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;TIMER_$O_COUNT;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_ENABLED&nbsp;&lt;=&nbsp;'0';</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER_$O_COUNTER&nbsp;&lt;=&nbsp;TIMER_$O_COUNTER&nbsp;-&nbsp;1;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;end;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Tool Description Interface TDI</SectionTitle>
<Para>
The Tool Description Interface (TDI) is used to emit project specific synthesis and technology tool scripts.</Para>
<Para>
Using the TDI tool interface provides a unique and easy way to emit project tool script files for post hardware synthesis and simulation. Different target
script languages are supported, for example bash and make.</Para>
<Para>
The TDI tool file (file suffix .tool) defines</Para>
<List Type = "Numbered">
<Item>
<Para>
environment parameters (immutable) and variables (mutable),</Para>
</Item>
<Item>
<Para>
target and auxilliary functions,</Para>
</Item>
<Item>
<Para>
and a target scheduler.</Para>
</Item>
</List>
<Para>
Each TDI tool defines a new tool description. There are different output language targets. Actually only BASH scripts are supported. </Para>
<Para>
</Para>
<Section Id = "S7S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Parameter section </SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #parameter</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;$pname&nbsp;&lt;=&nbsp;expr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(1)</Line>
<Line>
&nbsp;&nbsp;if&nbsp;expr&nbsp;then&nbsp;statement&nbsp;else&nbsp;statement;&nbsp;&nbsp;--&nbsp;(2)</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$iname&nbsp;in&nbsp;$array&nbsp;do&nbsp;&nbsp;--&nbsp;(3)</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
statement&nbsp;::=&nbsp;assign&nbsp;';'&nbsp;|&nbsp;'begin'&nbsp;assign-list&nbsp;'end'&nbsp;';'</Line>
<Line>
assign-list&nbsp;::=&nbsp;assign&nbsp;';'&nbsp;assign&nbsp;';'&nbsp;...</Line>
<Line>
assign&nbsp;::=&nbsp;$pname&nbsp;'&lt;='&nbsp;expr</Line>
<Line>
expr&nbsp;::=&nbsp;value&nbsp;|&nbsp;function&nbsp;|&nbsp;arith-expr&nbsp;|&nbsp;bool-expr&nbsp;|&nbsp;relat-expr</Line>
<Line>
value&nbsp;::=&nbsp;string&nbsp;|&nbsp;char&nbsp;|&nbsp;int</Line>
<Line>
string&nbsp;::=&nbsp;"..."</Line>
<Line>
char&nbsp;::=&nbsp;'.'</Line>
<Line>
int&nbsp;::=&nbsp;[0..9]+</Line>
<Line>
function&nbsp;::=&nbsp;fname&nbsp;'('&nbsp;arg-list&nbsp;')'</Line>
<Line>
arg-list&nbsp;::=&nbsp;expr&nbsp;,&nbsp;expr&nbsp;,&nbsp;...</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
Environment parameter and variable definition section. Parameters are assigned only one time a (constant) value, variables are assigned different values.
Parameters are replaced in expression with their actual value, whereby variables are used in expressions as real variables.</Para>
<Para>
Global variables are always arrays. That means each time a new value is assigned to this variable a new array element is created and appended to the array.
</Para>
<Para>
Operations on environment parameters:</Para>
<List Type = "Numbered">
<Item>
<Para>
Assignments and definition of an environment parameter.</Para>
</Item>
<Item>
<Para>
Conditional assignments.</Para>
</Item>
<Item>
<Para>
Array iteration. The loop body execution is performed with the iteration variable $iname with actual value from the array element set.  </Para>
</Item>
</List>
<Para>
There are some predefined parameters and parameter arrays:</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
$proj</ItemLabel>
<Para>
This project name</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$vhdl</ItemLabel>
<Para>
Parameter array containg all  synthesized and imported VHDL files of this project.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$port</ItemLabel>
<Para>
Parameter array containg all VHDL toplevel port signals of this project.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$target</ItemLabel>
<Para>
Parameter array containg all  hardware target devices of this project.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$clock_edge</ItemLabel>
<Para>
System clock signal activity level.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$reset_state</ItemLabel>
<Para>
Reset signal activity level.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$simu_cycles</ItemLabel>
<Para>
Number of simulation clock cycles.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$simu_period</ItemLabel>
<Para>
Period of simulation clock cyclce in nanoseconds.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
$encoding</ItemLabel>
<Para>
Default encoding format.</Para>
</DescriptionItem></DescriptionList>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;$TOP&nbsp;&lt;=&nbsp;$proj;</Line>
<Line>
&nbsp;&nbsp;$OBJDIR&nbsp;&lt;=&nbsp;"obj";</Line>
<Line>
&nbsp;&nbsp;$SRCDIR&nbsp;&lt;=&nbsp;".";</Line>
<Line>
&nbsp;&nbsp;$DESIGN&nbsp;&lt;=&nbsp;$proj;</Line>
<Line>
&nbsp;&nbsp;$LOG&nbsp;&lt;=&nbsp;$TOP&nbsp;+&nbsp;".log";</Line>
<Line>
&nbsp;&nbsp;$DUP&nbsp;&lt;=&nbsp;"tee";</Line>
<Line>
&nbsp;&nbsp;$PWD&nbsp;&lt;=&nbsp;get_env($PWD,"/");</Line>
<Line>
&nbsp;&nbsp;$ALLIANCE_TOP&nbsp;&lt;=&nbsp;get_env($ALLIANCE_TOP,"/opt/alliance-5.0");</Line>
<Line>
&nbsp;&nbsp;$BIN&nbsp;&lt;=&nbsp;$ALLIANCE_TOP&nbsp;+&nbsp;"/bin";</Line>
<Line>
&nbsp;&nbsp;$CELLS&nbsp;&lt;=&nbsp;$ALLIANCE_TOP&nbsp;+&nbsp;"/cells";</Line>
<Line>
&nbsp;&nbsp;$MBK_CATA_LIB&nbsp;&lt;=&nbsp;$CELLS&nbsp;+&nbsp;"/sxlib";</Line>
<Line>
&nbsp;&nbsp;$SCRAM&nbsp;&lt;=&nbsp;$BIN&nbsp;+&nbsp;"/scram";</Line>
<Line>
&nbsp;&nbsp;$VHD2&nbsp;&lt;=&nbsp;$BIN&nbsp;+&nbsp;"/vhd2vst";</Line>
<Line>
&nbsp;&nbsp;$SXLIB_COMP&nbsp;&lt;=&nbsp;$CELLS&nbsp;+"/sxlib/sxlib_components.vhd";</Line>
<Line>
&nbsp;&nbsp;$EXEMPLAR&nbsp;&lt;=&nbsp;get_env($EXEMPLAR,"/export/home/leonardo");</Line>
<Line>
&nbsp;&nbsp;$LEONARDO_TOP&nbsp;&lt;=&nbsp;$EXEMPLAR;</Line>
<Line>
&nbsp;&nbsp;$SPECTRUM&nbsp;&lt;=&nbsp;$LEONARDO_TOP&nbsp;+&nbsp;"/bin/spectrum";</Line>
<Line>
&nbsp;&nbsp;$LIBRARY&nbsp;&lt;=&nbsp;"sxlib";</Line>
<Line>
&nbsp;&nbsp;$ENCODING&nbsp;&lt;=&nbsp;get_opt($encoding,"binary");</Line>
<Line>
&nbsp;&nbsp;$res&nbsp;&lt;=&nbsp;0;</Line>
<Line>
&nbsp;&nbsp;$PATH&nbsp;&lt;=&nbsp;get_env($PATH,"/bin");</Line>
<Line>
&nbsp;&nbsp;$PATH&nbsp;&lt;=&nbsp;$PATH&nbsp;+&nbsp;":"&nbsp;+&nbsp;"/usr/ccs/bin";</Line>
<Line>
&nbsp;&nbsp;$SIM_CYCLES&nbsp;&lt;=&nbsp;get_opt($simu_cycles,"100");</Line>
<Line>
&nbsp;&nbsp;$SIM_PERIOD&nbsp;&lt;=&nbsp;get_opt($simu_period,"100");</Line>
<Line>
&nbsp;&nbsp;$SIM_RES&nbsp;&lt;=&nbsp;get_opt($simu_res,"5");</Line>
<Line>
&nbsp;&nbsp;$CLOCK_EDGE&nbsp;&lt;=&nbsp;get_opt($clock_edge,"1");</Line>
<Line>
&nbsp;&nbsp;if&nbsp;$CLOCK_EDGE&nbsp;=&nbsp;"1"&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$CLOCK_EDGE_NEG&nbsp;&lt;=&nbsp;"0"</Line>
<Line>
&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$CLOCK_EDGE_NEG&nbsp;&lt;=&nbsp;"1";</Line>
<Line>
&nbsp;&nbsp;$RESET_STATE&nbsp;&lt;=&nbsp;get_opt($reset_state,"1");</Line>
<Line>
&nbsp;&nbsp;if&nbsp;$RESET_STATE&nbsp;=&nbsp;"1"&nbsp;then</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$RESET_STATE_NEG&nbsp;&lt;=&nbsp;"0"</Line>
<Line>
&nbsp;&nbsp;else</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$RESET_STATE_NEG&nbsp;&lt;=&nbsp;"1";</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
#parameter</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;--&nbsp;VHDL&nbsp;sources</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$file&nbsp;in&nbsp;$vhdl&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$VHDL.[$I]&nbsp;&lt;=&nbsp;chop_extension($file);</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
end;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S7S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Function section </SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> #function</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
label:#fun</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;statement;</Line>
<Line>
&nbsp;&nbsp;statement;&nbsp;</Line>
<Line>
&nbsp;&nbsp;...</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
statement&nbsp;::=&nbsp;assign&nbsp;|&nbsp;conditional&nbsp;|&nbsp;loop&nbsp;|&nbsp;function&nbsp;|&nbsp;block</Line>
<Line>
block&nbsp;::=&nbsp;'begin'&nbsp;statement-list&nbsp;'end'&nbsp;';'</Line>
<Line>
statement-list&nbsp;::=&nbsp;statement&nbsp;';'&nbsp;statement;...</Line>
<Line>
</Line>
<Line>
assign&nbsp;::=&nbsp;$pname&nbsp;'&lt;='&nbsp;expr</Line>
<Line>
conditional&nbsp;::=&nbsp;'if'&nbsp;expr&nbsp;'then'&nbsp;statement&nbsp;['else'&nbsp;statement]&nbsp;';'</Line>
<Line>
loop&nbsp;::=&nbsp;for-loop&nbsp;|&nbsp;foreach-loop</Line>
<Line>
foreach-loop&nbsp;=&nbsp;'foreach'&nbsp;$iname&nbsp;'in'&nbsp;$aname&nbsp;'do'&nbsp;statement&nbsp;';'</Line>
<Line>
for-loop&nbsp;=&nbsp;'for'&nbsp;a&nbsp;'to'&nbsp;|&nbsp;'downto'&nbsp;b&nbsp;'do'&nbsp;statement&nbsp;';'</Line>
<Line>
</Line>
<Line>
expr&nbsp;::=&nbsp;value&nbsp;|&nbsp;function&nbsp;|&nbsp;arith-expr&nbsp;|&nbsp;bool-expr&nbsp;|&nbsp;relat-expr</Line>
<Line>
value&nbsp;::=&nbsp;string&nbsp;|&nbsp;char&nbsp;|&nbsp;int</Line>
<Line>
string&nbsp;::=&nbsp;"..."</Line>
<Line>
char&nbsp;::=&nbsp;'.'</Line>
<Line>
int&nbsp;::=&nbsp;[0..9]+</Line>
<Line>
function&nbsp;::=&nbsp;fname(arg-list)</Line>
<Line>
arg-list&nbsp;::=&nbsp;expr&nbsp;,&nbsp;expr&nbsp;,&nbsp;...</Line>
<Line>
</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
This section defines a user function. User defined  functions can be called from any other function and used inside the #target section. User defined functions
actually expect no arguments!</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
foreach</ItemLabel>
<Para>
This loop is used to iterate the set of all elements of the array $aname. Each loop iteration changes the iteration variable $iname to the actual array element
value. This variable can be used in expressions. There is an additional variable $I which holds the actual loop iteration number, starting with value 1.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
for</ItemLabel>
<Para>
This loop is used with numerical ranges [a,b]. Each loop iteration changes the iteration variable $iname to the actual value of  the set of range values. This
variable can be used in expressions. After each loop iteration, the iteration variable is incremented by one (to-direction) or decremented by one
(downto-direction). </Para>
</DescriptionItem><DescriptionItem><ItemLabel>
if-then-else</ItemLabel>
<Para>
The conditional expression expr is evaluated.  If the result is true, the first then-statement is executed, if it is false the else-statement, which is
optional.</Para>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Warnings and Limitations</ItemLabel>
<Para>
Some target scripting languages don't support lokal variables. Lokal variable names therefore are prefixed with the function name. Global variables and
parameters, especially shell environment variables, must be assigned a value outside functions on top level, at least using the get_env or get_opt builtin
function!</Para>
<Para>
</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
do_synth:#fun</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;print&nbsp;("[Creating&nbsp;Leonardo&nbsp;Spectrum&nbsp;command&nbsp;file...]");</Line>
<Line>
&nbsp;&nbsp;$TCL&nbsp;&lt;=&nbsp;$TOP&nbsp;&nbsp;+&nbsp;".tcl";</Line>
<Line>
&nbsp;&nbsp;$FILES&nbsp;&lt;=&nbsp;"";</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$file&nbsp;in&nbsp;$VHDL&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$SRC&nbsp;&lt;=&nbsp;$file&nbsp;+&nbsp;".vhdl";</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$FILES&nbsp;&lt;=&nbsp;"../"&nbsp;+&nbsp;$SRC&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;$FILES;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;create_file&nbsp;($TCL);</Line>
<Line>
&nbsp;&nbsp;$PWD&nbsp;&lt;=&nbsp;get_env($PWD,"/");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set_working_dir&nbsp;"&nbsp;+&nbsp;$PWD);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;hierarchy_flatten&nbsp;TRUE");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;output_file&nbsp;"+&nbsp;$TOP&nbsp;+&nbsp;".vhd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;novendor_constraint_file&nbsp;FALSE");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;bubble_tristates&nbsp;FALSE");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;encoding&nbsp;"+&nbsp;$ENCODING);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"load_library&nbsp;"+&nbsp;$LIBRARY);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"read&nbsp;-dont_elaborate&nbsp;{"+&nbsp;$FILES&nbsp;+&nbsp;"}");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"read&nbsp;-technology&nbsp;"&nbsp;+&nbsp;$LIBRARY&nbsp;+&nbsp;"&nbsp;{"&nbsp;+&nbsp;$FILES&nbsp;+&nbsp;"}");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pre_optimize&nbsp;-common_logic&nbsp;-unused_logic&nbsp;-boundary&nbsp;-xor_comparator_optimize");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pre_optimize&nbsp;-extract");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"optimize&nbsp;.work.MOD_"+&nbsp;$TOP&nbsp;+&nbsp;</Line>
<Line>
&nbsp;&nbsp;$CMD&nbsp;&lt;=&nbsp;$SPECTRUM&nbsp;+&nbsp;"&nbsp;-f&nbsp;"+$TCL;</Line>
<Line>
&nbsp;&nbsp;write_line($LOG,"["+$CMD+"]");</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;$res&nbsp;&lt;=&nbsp;exec($CMD);</Line>
<Line>
&nbsp;&nbsp;check();</Line>
<Line>
&nbsp;&nbsp;append_file&nbsp;("leospec.log",$LOG);</Line>
<Line>
end;</Line>
<Line>
&nbsp;&nbsp;</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
<Section Id = "S7S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Builtin Core Functions </SectionTitle>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Name</ItemLabel>
<Para>
<Terminal> TDI core functions</Terminal></Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Syntax</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
call-fun&nbsp;::=&nbsp;fname&nbsp;'('&nbsp;arg-list&nbsp;')'</Line>
<Line>
arg-list&nbsp;::=&nbsp;par1&nbsp;','&nbsp;par2&nbsp;','&nbsp;...</Line>
<Line>
infix-fun&nbsp;::=&nbsp;'+'&nbsp;'-'&nbsp;'/'&nbsp;'*'&nbsp;'='&nbsp;'&lt;&gt;'&nbsp;'&lt;'&nbsp;'&gt;'&nbsp;'&gt;='&nbsp;'&lt;='</Line>
<Line>
prefix-fun&nbsp;::=&nbsp;'-'</Line>
<Line>
</Line>
<Line>
type&nbsp;file&nbsp;::=&nbsp;string</Line>
<Line>
type&nbsp;path&nbsp;::=&nbsp;string</Line>
<Line>
</Line>
</Environment>
</DescriptionItem><DescriptionItem><ItemLabel>
Description</ItemLabel>
<Para>
There are a large set of builtin functions wich can be used within expressions. There are functions  with a variable number of arguments indicated with dots
'...'. All following arguments of same type as the last specified before the dots are optional. Files are always identified by their name. </Para>
<Para>
The following function type declarations have some special notations: Functions without returning a result, commonly procedures,  return the dummy type unit, 
polymorph functions are typed with type'a. All function arguments are placed within paranthesis pairs '()'.</Para>
<DescriptionList Type = "Argument">
<DescriptionItem><ItemLabel>
Operators</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;+:&nbsp;type'a&nbsp;-&gt;&nbsp;type'a&nbsp;-&gt;&nbsp;type'a&nbsp;</Line>
</Environment>
<Para>
If <Terminal> type'a=int</Terminal> this operation adds the two operands with result type integer.</Para>
<Para>
If <Terminal> type'a=string</Terminal>  this  operation concatenates both string operands with result type string.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
IO</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;print:&nbsp;(string,...)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Print string arguments concatenated to one line to standard output channel.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;print_line:&nbsp;(string,...)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Print string arguments each in one line to standard output channel.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;write:&nbsp;(file,string,...)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Print string arguments concatenated to one line to a file specified with the first argument. </Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;write_line:&nbsp;(file,string,...)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Print string arguments each in one line to a file specified with the first argument.</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
File Management</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;create_file:&nbsp;(file)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Create a file whose file-name and path is specified with the first argument.</Para>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
fun&nbsp;open_file:&nbsp;(file)&nbsp;-&gt;&nbsp;unit</Line>
</Environment>
<Para>
Open an existing file whose file-name and path is specified with the first argument.</Para>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
Example</ItemLabel>
<Environment ID = "E13" XRefLabel = "Environment" Type = "Example" LineNumbers = "No" Imported = "No">
<Line>
do_synth:#fun</Line>
<Line>
begin</Line>
<Line>
&nbsp;&nbsp;print&nbsp;("[Creating&nbsp;Leonardo&nbsp;Spectrum&nbsp;command&nbsp;file...]");</Line>
<Line>
&nbsp;&nbsp;$TCL&nbsp;&lt;=&nbsp;$TOP&nbsp;&nbsp;+&nbsp;".tcl";</Line>
<Line>
&nbsp;&nbsp;$FILES&nbsp;&lt;=&nbsp;"";</Line>
<Line>
&nbsp;&nbsp;foreach&nbsp;$file&nbsp;in&nbsp;$VHDL&nbsp;do</Line>
<Line>
&nbsp;&nbsp;begin</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$SRC&nbsp;&lt;=&nbsp;$file&nbsp;+&nbsp;".vhdl";</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;$FILES&nbsp;&lt;=&nbsp;"../"&nbsp;+&nbsp;$SRC&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;$FILES;</Line>
<Line>
&nbsp;&nbsp;end;</Line>
<Line>
</Line>
<Line>
&nbsp;&nbsp;create_file&nbsp;($TCL);</Line>
<Line>
&nbsp;&nbsp;$PWD&nbsp;&lt;=&nbsp;get_env($PWD,"/");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set_working_dir&nbsp;"&nbsp;+&nbsp;$PWD);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;hierarchy_flatten&nbsp;TRUE");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;output_file&nbsp;"+&nbsp;$TOP&nbsp;+&nbsp;".vhd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;bubble_tristates&nbsp;FALSE");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;encoding&nbsp;"+&nbsp;$ENCODING);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"load_library&nbsp;"+&nbsp;$LIBRARY);</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"read&nbsp;-dont_elaborate&nbsp;{"+&nbsp;$FILES&nbsp;+&nbsp;"}");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"read&nbsp;-technology&nbsp;"&nbsp;+&nbsp;$LIBRARY&nbsp;+&nbsp;"&nbsp;{"&nbsp;+&nbsp;$FILES&nbsp;+&nbsp;"}");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pre_optimize&nbsp;-common_logic&nbsp;-unused_logic&nbsp;-boundary&nbsp;-xor_comparator_optimize");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pre_optimize&nbsp;-extract");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"pd");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"optimize&nbsp;.work.MOD_"+&nbsp;$TOP&nbsp;+&nbsp;</Line>
<Line>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".main&nbsp;-target&nbsp;sxlib&nbsp;-macro&nbsp;-area&nbsp;-effort&nbsp;quick&nbsp;-hierarchy&nbsp;flatten");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"optimize_timing&nbsp;.work.MOD_"+$TOP+".main");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"report_area&nbsp;-cell_usage&nbsp;-hierarchy&nbsp;-all_leafs");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"report_delay&nbsp;&nbsp;-num_paths&nbsp;1&nbsp;-critical_paths&nbsp;-clock_frequency");</Line>
<Line>
&nbsp;&nbsp;write_line&nbsp;($TCL,"auto_write&nbsp;-format&nbsp;VHD&nbsp;"+$TOP+".vhd");</Line>
<Line>
&nbsp;&nbsp;print_line&nbsp;("[Forking&nbsp;Leonardo&nbsp;Spectrum...]");</Line>
<Line>
&nbsp;&nbsp;$CMD&nbsp;&lt;=&nbsp;$SPECTRUM&nbsp;+&nbsp;"&nbsp;-f&nbsp;"+$TCL;</Line>
<Line>
&nbsp;&nbsp;write_line($LOG,"["+$CMD+"]");</Line>
<Line>
&nbsp;&nbsp;</Line>
<Line>
&nbsp;&nbsp;$res&nbsp;&lt;=&nbsp;exec($&nbsp;&nbsp;write_line&nbsp;($TCL,"set&nbsp;novendor_constraint_file&nbsp;FALSE");</Line>
<Line>
&nbsp;&nbsp;check();</Line>
<Line>
&nbsp;&nbsp;append_file&nbsp;("leospec.log",$LOG);</Line>
<Line>
end;</Line>
<Line>
</Line>
<Line>
</Line>
</Environment>
</DescriptionItem></DescriptionList>
<Para>
</Para>
</Section>
</Section>
<Section Id = "S8" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
<Symbol>&#x6d;</Symbol>Code</SectionTitle>
<Para>
...</Para>
<Para>
</Para>
</Section>
<Section Id = "S9" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden= "No">
<SectionTitle>
Synthesis</SectionTitle>
<Section Id = "S9S1" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Basic Scheduling Model</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S2" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Synthesis RulesSynthesis Rules</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S3" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Expression Modells and Allocation</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S4" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
<Symbol>&#x6d;</Symbol>Code Transformation</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S5" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Reference Stack Scheduler</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S6" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Basic Block Scheduler</SectionTitle>
<Para>
...</Para>
</Section>
<Section Id = "S9S7" XRefLabel = "Section" Numbered = "Yes" Columns = "One" Hidden = "No">
<SectionTitle>
Expression Scheduler</SectionTitle>
<Para>
...</Para>
</Section>
</Section>
<Section XRefLabel = "Section" Numbered = "No" Columns = "Two" Hidden= "No">
<SectionTitle>
Internal Notes</SectionTitle>
<Para>
...</Para>
</Section>
<Section XRefLabel = "Section" Numbered = "No" Columns = "Two" Hidden= "No">
<SectionTitle>Bibliography</SectionTitle>
<DescriptionList Type = "Bibliography">
<DescriptionItem><ItemLabel>
[RU87]</ItemLabel>
<Para>
Steven M. Rubini  
<Emphasis> Computer Aids For VLSI Design
</Emphasis>Addision Wesley 1987</Para>
</DescriptionItem><DescriptionItem><ItemLabel>
</ItemLabel>
</DescriptionItem></DescriptionList>
</Section>
</Article>
