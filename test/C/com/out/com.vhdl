--
-- Automatically generated by
-- CONPRO: Hardware Synthesis with an Imperative High Level Multiprocess Approach
--         (c) 2006-2010 by BSSLAB, Dr. Stefan Bosse
--         Version: 2.1 Revision: D149 Genetic size: 2681845
--         Compile date: Wed Apr 28 18:22:40 CEST 2010
--         Compiled by:  sbosse
--         Compiled on:  SunOS sunsil 5.10 Generic_137137-09 sun4u sparc SUNW,Sun-Blade-2500

-- Implementation of Module <Com>.
--
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_unsigned.all;
use work.ConPRO.all;
entity MOD_com is
port(
  -- Connections to the outside world
  signal stat_led_RD: out std_logic;
  signal dev_io_RX: in std_logic;
  signal dev_io_TX: out std_logic;
  signal CLK: in std_logic;
  signal RESET: in std_logic
);
end MOD_com;
architecture main of MOD_com is
  -- Process instances
  component com_sys_status_proc
  port(
    -- Connections to external objects, components and the outside world
    signal REG_sys_status_RD: in std_logic_vector(2 downto 0);
    signal REG_sys_status_WR: out std_logic_vector(2 downto 0);
    signal REG_sys_status_WE: out std_logic;
    signal REG_sys_status_GD: in std_logic;
    signal REG_stat_led_WR: out std_logic;
    signal REG_stat_led_WE: out std_logic;
    signal REG_sys_status_next_RD: in std_logic_vector(2 downto 0);
    signal REG_sys_status_next_WR: out std_logic_vector(2 downto 0);
    signal REG_sys_status_next_WE: out std_logic;
    signal REG_sys_status_next_GD: in std_logic;
    signal TIMER_watch_timer_INIT: out std_logic;
    signal TIMER_watch_timer_AWAIT: out std_logic;
    signal TIMER_watch_timer_START: out std_logic;
    signal TIMER_watch_timer_GD: in std_logic;
    signal PRO_sys_status_proc_ENABLE: in std_logic;
    signal PRO_sys_status_proc_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_com_tmo
  port(
    -- Connections to external objects, components and the outside world
    signal REG_com_timeout_WR: out std_logic;
    signal REG_com_timeout_WE: out std_logic;
    signal QUEUE_rx_q_UNLOCK: out std_logic;
    signal QUEUE_rx_q_GD: in std_logic;
    signal PRO_com_tmo_ENABLE: in std_logic;
    signal PRO_com_tmo_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_com_rx
  port(
    -- Connections to external objects, components and the outside world
    signal REG_sys_status_WR: out std_logic_vector(2 downto 0);
    signal REG_sys_status_WE: out std_logic;
    signal REG_sys_status_GD: in std_logic;
    signal UART_com_RE: out std_logic;
    signal UART_com_RD: in std_logic_vector(7 downto 0);
    signal UART_com_RD_ERR: in std_logic;
    signal UART_com_GD: in std_logic;
    signal QUEUE_rx_q_WR: out std_logic_vector(7 downto 0);
    signal QUEUE_rx_q_WE: out std_logic;
    signal QUEUE_rx_q_GD: in std_logic;
    signal PRO_com_rx_ENABLE: in std_logic;
    signal PRO_com_rx_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_com_tx
  port(
    -- Connections to external objects, components and the outside world
    signal UART_com_WE: out std_logic;
    signal UART_com_WR: out std_logic_vector(7 downto 0);
    signal UART_com_WR_ERR: in std_logic;
    signal UART_com_GD: in std_logic;
    signal QUEUE_tx_q_RD: in std_logic_vector(7 downto 0);
    signal QUEUE_tx_q_RE: out std_logic;
    signal QUEUE_tx_q_GD: in std_logic;
    signal PRO_com_tx_ENABLE: in std_logic;
    signal PRO_com_tx_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_interpreter
  port(
    -- Connections to external objects, components and the outside world
    signal REG_sys_status_WR: out std_logic_vector(2 downto 0);
    signal REG_sys_status_WE: out std_logic;
    signal REG_sys_status_GD: in std_logic;
    signal REG_sys_status_next_WR: out std_logic_vector(2 downto 0);
    signal REG_sys_status_next_WE: out std_logic;
    signal REG_sys_status_next_GD: in std_logic;
    signal PRO_com_rx_START: out std_logic;
    signal PRO_com_rx_GD: in std_logic;
    signal REG_com_timeout_RD: in std_logic;
    signal UART_com_INIT: out std_logic;
    signal UART_com_START: out std_logic;
    signal UART_com_GD: in std_logic;
    signal PRO_com_tmo_START: out std_logic;
    signal PRO_com_tmo_STOP: out std_logic;
    signal PRO_com_tmo_GD: in std_logic;
    signal QUEUE_rx_q_RD: in std_logic_vector(7 downto 0);
    signal QUEUE_rx_q_RE: out std_logic;
    signal QUEUE_rx_q_GD: in std_logic;
    signal QUEUE_tx_q_WR: out std_logic_vector(7 downto 0);
    signal QUEUE_tx_q_WE: out std_logic;
    signal QUEUE_tx_q_GD: in std_logic;
    signal PRO_com_tx_START: out std_logic;
    signal PRO_com_tx_GD: in std_logic;
    signal EVENT_rep_INIT: out std_logic;
    signal EVENT_rep_WAKEUP: out std_logic;
    signal EVENT_rep_GD: in std_logic;
    signal REG_rep_d_WR: out std_logic_vector(7 downto 0);
    signal REG_rep_d_WE: out std_logic;
    signal PRO_interpreter_ENABLE: in std_logic;
    signal PRO_interpreter_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_FUN_request
  port(
    -- Connections to external objects, components and the outside world
    signal REG_RET_FUN_request_d2_WR: out std_logic_vector(7 downto 0);
    signal REG_RET_FUN_request_d2_WE: out std_logic;
    signal REG_ARG_FUN_request_d1_RD: in std_logic_vector(7 downto 0);
    signal QUEUE_tx_q_WR: out std_logic_vector(7 downto 0);
    signal QUEUE_tx_q_WE: out std_logic;
    signal QUEUE_tx_q_GD: in std_logic;
    signal EVENT_rep_AWAIT: out std_logic;
    signal EVENT_rep_GD: in std_logic;
    signal REG_rep_d_RD: in std_logic_vector(7 downto 0);
    signal PRO_FUN_request_ENABLE: in std_logic;
    signal PRO_FUN_request_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component com_main
  port(
    -- Connections to external objects, components and the outside world
    signal PRO_interpreter_START: out std_logic;
    signal PRO_interpreter_GD: in std_logic;
    signal PRO_sys_status_proc_START: out std_logic;
    signal PRO_sys_status_proc_GD: in std_logic;
    signal REG_RET_FUN_request_d2_RD: in std_logic_vector(7 downto 0);
    signal REG_ARG_FUN_request_d1_WR: out std_logic_vector(7 downto 0);
    signal REG_ARG_FUN_request_d1_WE: out std_logic;
    signal MUTEX_LOCK_FUN_request_INIT: out std_logic;
    signal MUTEX_LOCK_FUN_request_LOCK: out std_logic;
    signal MUTEX_LOCK_FUN_request_UNLOCK: out std_logic;
    signal MUTEX_LOCK_FUN_request_GD: in std_logic;
    signal PRO_FUN_request_CALL: out std_logic;
    signal PRO_FUN_request_GD: in std_logic;
    signal PRO_main_ENABLE: in std_logic;
    signal PRO_main_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  -- Local and temporary data objects
  signal REG_sys_status: std_logic_vector(2 downto 0);
  signal REG_sys_status_LOCKED: std_logic;
  signal REG_sys_status_RD: std_logic_vector(2 downto 0);
  signal REG_sys_status_sys_status_proc_WR: std_logic_vector(2 downto 0);
  signal REG_sys_status_sys_status_proc_WE: std_logic;
  signal REG_sys_status_com_rx_WR: std_logic_vector(2 downto 0);
  signal REG_sys_status_com_rx_WE: std_logic;
  signal REG_sys_status_interpreter_WR: std_logic_vector(2 downto 0);
  signal REG_sys_status_interpreter_WE: std_logic;
  signal REG_sys_status_sys_status_proc_GD: std_logic;
  signal REG_sys_status_com_rx_GD: std_logic;
  signal REG_sys_status_interpreter_GD: std_logic;
  signal REG_stat_led: std_logic;
  signal REG_stat_led_sys_status_proc_WR: std_logic;
  signal REG_stat_led_sys_status_proc_WE: std_logic;
  signal REG_sys_status_next: std_logic_vector(2 downto 0);
  signal REG_sys_status_next_LOCKED: std_logic;
  signal REG_sys_status_next_RD: std_logic_vector(2 downto 0);
  signal REG_sys_status_next_sys_status_proc_WR: std_logic_vector(2 downto 0);
  signal REG_sys_status_next_sys_status_proc_WE: std_logic;
  signal REG_sys_status_next_interpreter_WR: std_logic_vector(2 downto 0);
  signal REG_sys_status_next_interpreter_WE: std_logic;
  signal REG_sys_status_next_sys_status_proc_GD: std_logic;
  signal REG_sys_status_next_interpreter_GD: std_logic;
  signal PRO_sys_status_proc_ENABLE: std_logic;
  signal PRO_sys_status_proc_END: std_logic;
  signal PRO_sys_status_proc_main_START: std_logic;
  signal PRO_sys_status_proc_main_GD: std_logic;
  signal PRO_com_tx_ENABLE: std_logic;
  signal PRO_com_tx_END: std_logic;
  signal PRO_com_tx_interpreter_START: std_logic;
  signal PRO_com_tx_interpreter_GD: std_logic;
  signal TIMER_watch_timer_COUNTER: std_logic_vector(19 downto 0);
  signal TIMER_watch_timer_COUNT: std_logic_vector(19 downto 0);
  signal TIMER_watch_timer_ENABLED: std_logic;
  signal TIMER_watch_timer_MODE: std_logic;
  signal TIMER_watch_timer_sys_status_proc_AWAIT: std_logic;
  signal TIMER_watch_timer_sys_status_proc_LOCKed: std_logic;
  signal TIMER_watch_timer_sys_status_proc_INIT: std_logic;
  signal TIMER_watch_timer_sys_status_proc_START: std_logic;
  signal TIMER_watch_timer_sys_status_proc_GD: std_logic;
  signal dev_io_TX_WR: std_logic;
  signal PRO_interpreter_ENABLE: std_logic;
  signal PRO_interpreter_END: std_logic;
  signal PRO_interpreter_main_START: std_logic;
  signal PRO_interpreter_main_GD: std_logic;
  signal PRO_com_tmo_ENABLE: std_logic;
  signal PRO_com_tmo_END: std_logic;
  signal PRO_com_tmo_interpreter_START: std_logic;
  signal PRO_com_tmo_interpreter_STOP: std_logic;
  signal PRO_com_tmo_interpreter_GD: std_logic;
  signal REG_RET_FUN_request_d2: std_logic_vector(7 downto 0);
  signal REG_RET_FUN_request_d2_RD: std_logic_vector(7 downto 0);
  signal REG_RET_FUN_request_d2_FUN_request_WR: std_logic_vector(7 downto 0);
  signal REG_RET_FUN_request_d2_FUN_request_WE: std_logic;
  signal REG_ARG_FUN_request_d1: std_logic_vector(7 downto 0);
  signal REG_ARG_FUN_request_d1_RD: std_logic_vector(7 downto 0);
  signal REG_ARG_FUN_request_d1_main_WR: std_logic_vector(7 downto 0);
  signal REG_ARG_FUN_request_d1_main_WE: std_logic;
  signal REG_com_timeout: std_logic;
  signal REG_com_timeout_RD: std_logic;
  signal REG_com_timeout_com_tmo_WR: std_logic;
  signal REG_com_timeout_com_tmo_WE: std_logic;
  signal PRO_main_ENABLE: std_logic;
  signal PRO_main_END: std_logic;
  signal UART_com_interpreter_INIT: std_logic;
  signal UART_com_interpreter_START: std_logic;
  signal UART_com_com_rx_RE: std_logic;
  signal UART_com_com_rx_RD: std_logic_vector(7 downto 0);
  signal UART_com_com_rx_RD_ERR: std_logic;
  signal UART_com_com_tx_WE: std_logic;
  signal UART_com_com_tx_WR: std_logic_vector(7 downto 0);
  signal UART_com_com_tx_WR_ERR: std_logic;
  signal UART_com_interpreter_GD: std_logic;
  signal UART_com_interpreter_LOCKed: std_logic;
  signal UART_com_com_tx_GD: std_logic;
  signal UART_com_com_tx_LOCKed: std_logic;
  signal UART_com_com_rx_GD: std_logic;
  signal UART_com_com_rx_LOCKed: std_logic;
  signal UART_com_RXD: std_logic;
  signal UART_com_TXD: std_logic;
  signal UART_com_RX_EN: std_logic;
  signal UART_com_TX_EN: std_logic;
  signal UART_com_TX_DATA: std_logic_vector(7 downto 0);
  signal UART_com_RX_DATA: std_logic_vector(7 downto 0);
  signal UART_com_BAUD_COUNT: std_logic_vector(3 downto 0);
  signal UART_com_BAUD16: std_logic;
  signal UART_com_RX_RE: std_logic;
  signal UART_com_BUSY: std_logic;
  signal UART_com_RX_SAMPLED: std_logic;
  signal UART_com_RX_COMPL: std_logic;
  signal UART_com_RX_ERR: std_logic;
  signal UART_com_RX_BIT_PHASE: std_logic_vector(3 downto 0);
  signal UART_com_RX_BIT_COUNT: std_logic_vector(4 downto 0);
  signal UART_com_RX_SHIFT: std_logic_vector(7 downto 0);
  signal UART_com_TX_COMPL: std_logic;
  signal UART_com_TX_DRE: std_logic;
  signal UART_com_TX_WE: std_logic;
  signal UART_com_TX_ERR: std_logic;
  signal UART_com_TX_TICK: std_logic;
  signal UART_com_TX_BIT_COUNT: std_logic_vector(4 downto 0);
  signal UART_com_TX_SHIFT: std_logic_vector(8 downto 0);
  signal UART_com_com_tx_TX_AWAIT: std_logic;
  type QRAM_rx_q_type is array(0 to 15)
    of std_logic_vector(7 downto 0);
  signal QRAM_rx_q: QRAM_rx_q_type;
  signal QUEUE_rx_q_EMPTY: std_logic;
  signal QUEUE_rx_q_FULL: std_logic;
  signal QUEUE_rx_q_LOCKED: std_logic;
  signal QUEUE_rx_q_ADDR_RD: std_logic_vector(3 downto 0);
  signal QUEUE_rx_q_ADDR_WR: std_logic_vector(3 downto 0);
  signal QRAM_rx_q_ADDR_AUX: std_logic_vector(3 downto 0);
  signal QRAM_rx_q_RD_ADDR: std_logic_vector(3 downto 0);
  signal QRAM_rx_q_DIN_AUX: std_logic_vector(7 downto 0);
  signal QRAM_rx_q_DOUT_AUX: std_logic_vector(7 downto 0);
  signal QRAM_rx_q_WE_AUX: std_logic;
  signal QUEUE_rx_q_com_rx_WR: std_logic_vector(7 downto 0);
  signal QUEUE_rx_q_com_rx_WE: std_logic;
  signal QUEUE_rx_q_interpreter_RD: std_logic_vector(7 downto 0);
  signal QUEUE_rx_q_interpreter_RE: std_logic;
  signal QUEUE_rx_q_com_rx_GD: std_logic;
  signal QUEUE_rx_q_interpreter_GD: std_logic;
  signal QUEUE_rx_q_com_tmo_GD: std_logic;
  signal QUEUE_rx_q_com_tmo_UNLOCK: std_logic;
  signal MUTEX_LOCK_FUN_request_main_LOCK: std_logic;
  signal MUTEX_LOCK_FUN_request_main_UNLOCK: std_logic;
  signal MUTEX_LOCK_FUN_request_main_INIT: std_logic;
  signal MUTEX_LOCK_FUN_request_main_GD: std_logic;
  signal MUTEX_LOCK_FUN_request_main_LOCKed: std_logic;
  signal MUTEX_LOCK_FUN_request_LOCKed: std_logic;
  signal PRO_FUN_request_ENABLE: std_logic;
  signal PRO_FUN_request_END: std_logic;
  signal PRO_FUN_request_main_CALL: std_logic;
  signal PRO_FUN_request_main_GD: std_logic;
  type QRAM_tx_q_type is array(0 to 15)
    of std_logic_vector(7 downto 0);
  signal QRAM_tx_q: QRAM_tx_q_type;
  signal QUEUE_tx_q_EMPTY: std_logic;
  signal QUEUE_tx_q_FULL: std_logic;
  signal QUEUE_tx_q_LOCKED: std_logic;
  signal QUEUE_tx_q_ADDR_RD: std_logic_vector(3 downto 0);
  signal QUEUE_tx_q_ADDR_WR: std_logic_vector(3 downto 0);
  signal QRAM_tx_q_ADDR_AUX: std_logic_vector(3 downto 0);
  signal QRAM_tx_q_RD_ADDR: std_logic_vector(3 downto 0);
  signal QRAM_tx_q_DIN_AUX: std_logic_vector(7 downto 0);
  signal QRAM_tx_q_DOUT_AUX: std_logic_vector(7 downto 0);
  signal QRAM_tx_q_WE_AUX: std_logic;
  signal QUEUE_tx_q_FUN_request_WR: std_logic_vector(7 downto 0);
  signal QUEUE_tx_q_FUN_request_WE: std_logic;
  signal QUEUE_tx_q_interpreter_WR: std_logic_vector(7 downto 0);
  signal QUEUE_tx_q_interpreter_WE: std_logic;
  signal QUEUE_tx_q_com_tx_RD: std_logic_vector(7 downto 0);
  signal QUEUE_tx_q_com_tx_RE: std_logic;
  signal QUEUE_tx_q_FUN_request_GD: std_logic;
  signal QUEUE_tx_q_interpreter_GD: std_logic;
  signal QUEUE_tx_q_com_tx_GD: std_logic;
  signal EVENT_rep_FUN_request_AWAIT: std_logic;
  signal EVENT_rep_FUN_request_LOCKed: std_logic;
  signal EVENT_rep_interpreter_WAKEUP: std_logic;
  signal EVENT_rep_interpreter_INIT: std_logic;
  signal EVENT_rep_interpreter_GD: std_logic;
  signal EVENT_rep_FUN_request_GD: std_logic;
  signal PRO_com_rx_ENABLE: std_logic;
  signal PRO_com_rx_END: std_logic;
  signal PRO_com_rx_interpreter_START: std_logic;
  signal PRO_com_rx_interpreter_GD: std_logic;
  signal REG_rep_d: std_logic_vector(7 downto 0);
  signal REG_rep_d_RD: std_logic_vector(7 downto 0);
  signal REG_rep_d_interpreter_WR: std_logic_vector(7 downto 0);
  signal REG_rep_d_interpreter_WE: std_logic;
  signal dev_io_RX_RD: std_logic;
  -- State Processing
  -- Aux. signals
  signal conpro_system_clk: std_logic;
  signal conpro_system_reset: std_logic;
begin
  -- Module implementation
  -- Guarded Register
  IMPL_REG_sys_status: process(
          REG_sys_status_sys_status_proc_WR,
          REG_sys_status_sys_status_proc_WE,
          REG_sys_status_com_rx_WR,
          REG_sys_status_com_rx_WE,
          REG_sys_status_interpreter_WR,
          REG_sys_status_interpreter_WE,
          REG_sys_status_LOCKED,
          REG_sys_status,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_sys_status_RD <= REG_sys_status;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_sys_status <= "000";
      REG_sys_status_LOCKED <= '0';
      REG_sys_status_sys_status_proc_GD <= '1';
      REG_sys_status_com_rx_GD <= '1';
      REG_sys_status_interpreter_GD <= '1';
     else
      REG_sys_status_sys_status_proc_GD <= '1';
      REG_sys_status_com_rx_GD <= '1';
      REG_sys_status_interpreter_GD <= '1';
      if REG_sys_status_LOCKED = '0' and REG_sys_status_sys_status_proc_WE='1' then
       REG_sys_status <= REG_sys_status_sys_status_proc_WR;
       REG_sys_status_sys_status_proc_GD <= '0';
       REG_sys_status_LOCKED <= '1';
      elsif REG_sys_status_LOCKED = '0' and REG_sys_status_com_rx_WE='1' then
       REG_sys_status <= REG_sys_status_com_rx_WR;
       REG_sys_status_com_rx_GD <= '0';
       REG_sys_status_LOCKED <= '1';
      elsif REG_sys_status_LOCKED = '0' and REG_sys_status_interpreter_WE='1' then
       REG_sys_status <= REG_sys_status_interpreter_WR;
       REG_sys_status_interpreter_GD <= '0';
       REG_sys_status_LOCKED <= '1';
      elsif REG_sys_status_LOCKED = '1' then
       REG_sys_status_LOCKED <= '0';
       REG_sys_status_sys_status_proc_GD <= '1';
       REG_sys_status_com_rx_GD <= '1';
       REG_sys_status_interpreter_GD <= '1';
      end if;
     end if;
    end if;
  end process IMPL_REG_sys_status;
  
  -- Register
  IMPL_REG_stat_led: process(
          REG_stat_led_sys_status_proc_WR,
          REG_stat_led_sys_status_proc_WE,
          REG_stat_led,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_stat_led <= '0';
     elsif REG_stat_led_sys_status_proc_WE='1' then
      REG_stat_led <= REG_stat_led_sys_status_proc_WR;
     end if;
    end if;
  end process IMPL_REG_stat_led;
  
  -- Guarded Register
  IMPL_REG_sys_status_next: process(
          REG_sys_status_next_sys_status_proc_WR,
          REG_sys_status_next_sys_status_proc_WE,
          REG_sys_status_next_interpreter_WR,
          REG_sys_status_next_interpreter_WE,
          REG_sys_status_next_LOCKED,
          REG_sys_status_next,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_sys_status_next_RD <= REG_sys_status_next;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_sys_status_next <= "000";
      REG_sys_status_next_LOCKED <= '0';
      REG_sys_status_next_sys_status_proc_GD <= '1';
      REG_sys_status_next_interpreter_GD <= '1';
     else
      REG_sys_status_next_sys_status_proc_GD <= '1';
      REG_sys_status_next_interpreter_GD <= '1';
      if REG_sys_status_next_LOCKED = '0' and REG_sys_status_next_sys_status_proc_WE='1' then
       REG_sys_status_next <= REG_sys_status_next_sys_status_proc_WR;
       REG_sys_status_next_sys_status_proc_GD <= '0';
       REG_sys_status_next_LOCKED <= '1';
      elsif REG_sys_status_next_LOCKED = '0' and REG_sys_status_next_interpreter_WE='1' then
       REG_sys_status_next <= REG_sys_status_next_interpreter_WR;
       REG_sys_status_next_interpreter_GD <= '0';
       REG_sys_status_next_LOCKED <= '1';
      elsif REG_sys_status_next_LOCKED = '1' then
       REG_sys_status_next_LOCKED <= '0';
       REG_sys_status_next_sys_status_proc_GD <= '1';
       REG_sys_status_next_interpreter_GD <= '1';
      end if;
     end if;
    end if;
  end process IMPL_REG_sys_status_next;
  
  -- Process control
  PRO_CONTROL_sys_status_proc: process(
          PRO_sys_status_proc_main_START,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_sys_status_proc_ENABLE <= '0';
        PRO_sys_status_proc_main_GD <= '1';
      elsif PRO_sys_status_proc_main_START = '1' then
        PRO_sys_status_proc_ENABLE <= '1';
        PRO_sys_status_proc_main_GD <= '0';
      else
        PRO_sys_status_proc_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_sys_status_proc;
  
  -- Process control
  PRO_CONTROL_com_tx: process(
          PRO_com_tx_interpreter_START,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_com_tx_ENABLE <= '0';
        PRO_com_tx_interpreter_GD <= '1';
      elsif PRO_com_tx_interpreter_START = '1' then
        PRO_com_tx_ENABLE <= '1';
        PRO_com_tx_interpreter_GD <= '0';
      else
        PRO_com_tx_interpreter_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_com_tx;
  
  --
  --  ConPro V2.1.D149 EMI Timer.timer V2.11
  --
  
  --
  -- EMI <Object Timer.timer.watch_timer> Process
  --
  TIMER_watch_timer_SCHED: process(conpro_system_clk,
    conpro_system_reset,
    TIMER_watch_timer_ENABLED,
    TIMER_watch_timer_COUNTER,
    TIMER_watch_timer_sys_status_proc_LOCKed,
    TIMER_watch_timer_MODE,
    TIMER_watch_timer_COUNT,
    TIMER_watch_timer_sys_status_proc_INIT,
    TIMER_watch_timer_sys_status_proc_AWAIT,
    TIMER_watch_timer_sys_status_proc_START)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        TIMER_watch_timer_ENABLED <= '0';
        TIMER_watch_timer_MODE <= '0';
        TIMER_watch_timer_COUNTER <= "00000000000000000000";
        TIMER_watch_timer_COUNT <= "11100001110101001000";
        TIMER_watch_timer_sys_status_proc_GD <= '1';
        TIMER_watch_timer_sys_status_proc_LOCKed <= '0';
      else
        TIMER_watch_timer_sys_status_proc_GD <= '1';
        if (TIMER_watch_timer_ENABLED) = ('1') then
          if (TIMER_watch_timer_COUNTER) = ("00000000000000000000") then
            if (TIMER_watch_timer_sys_status_proc_LOCKed) = ('1') then
              TIMER_watch_timer_sys_status_proc_LOCKed <= '0';
              TIMER_watch_timer_sys_status_proc_GD <= '0';
            end if;
            if (TIMER_watch_timer_MODE) = ('0') then
              TIMER_watch_timer_COUNTER <= TIMER_watch_timer_COUNT;
            else
              TIMER_watch_timer_ENABLED <= '0';
            end if;
          else
            TIMER_watch_timer_COUNTER <= (TIMER_watch_timer_COUNTER) - (1);
          end if;
        end if;
        if (TIMER_watch_timer_sys_status_proc_INIT) = ('1') then
          TIMER_watch_timer_COUNTER <= "00000000000000000000";
          TIMER_watch_timer_COUNT <= "11100001110101001000";
          TIMER_watch_timer_ENABLED <= '0';
          TIMER_watch_timer_MODE <= '0';
          TIMER_watch_timer_sys_status_proc_GD <= '0';
          if (TIMER_watch_timer_sys_status_proc_LOCKed) = ('1') then
            TIMER_watch_timer_sys_status_proc_LOCKed <= '0';
            TIMER_watch_timer_sys_status_proc_GD <= '0';
          end if;
        elsif ((TIMER_watch_timer_sys_status_proc_AWAIT) = ('1')) and ((TIMER_watch_timer_sys_status_proc_LOCKed) = ('0')) then
          TIMER_watch_timer_sys_status_proc_LOCKed <= '1';
        elsif (TIMER_watch_timer_sys_status_proc_START) = ('1') then
          TIMER_watch_timer_COUNTER <= TIMER_watch_timer_COUNT;
          TIMER_watch_timer_ENABLED <= '1';
          TIMER_watch_timer_sys_status_proc_GD <= '0';
        end if;
      end if;
    end if;
  end process TIMER_watch_timer_SCHED;
  --
  -- EMI <Object Timer.timer.watch_timer>
  --
  --
  -- End of <Object Timer.timer.watch_timer>
  --
  
  -- Process control
  PRO_CONTROL_interpreter: process(
          PRO_interpreter_main_START,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_interpreter_ENABLE <= '0';
        PRO_interpreter_main_GD <= '1';
      elsif PRO_interpreter_main_START = '1' then
        PRO_interpreter_ENABLE <= '1';
        PRO_interpreter_main_GD <= '0';
      else
        PRO_interpreter_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_interpreter;
  
  -- Process control
  PRO_CONTROL_com_tmo: process(
          PRO_com_tmo_interpreter_START,
          PRO_com_tmo_interpreter_STOP,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_com_tmo_ENABLE <= '0';
        PRO_com_tmo_interpreter_GD <= '1';
      elsif PRO_com_tmo_interpreter_START = '1' then
        PRO_com_tmo_ENABLE <= '1';
        PRO_com_tmo_interpreter_GD <= '0';
      elsif PRO_com_tmo_interpreter_STOP = '1' then
        PRO_com_tmo_ENABLE <= '0';
        PRO_com_tmo_interpreter_GD <= '0';
      else
        PRO_com_tmo_interpreter_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_com_tmo;
  
  -- Register
  IMPL_REG_RET_FUN_request_d2: process(
          REG_RET_FUN_request_d2_FUN_request_WR,
          REG_RET_FUN_request_d2_FUN_request_WE,
          REG_RET_FUN_request_d2,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_RET_FUN_request_d2_RD <= REG_RET_FUN_request_d2;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_RET_FUN_request_d2 <= "00000000";
     elsif REG_RET_FUN_request_d2_FUN_request_WE='1' then
      REG_RET_FUN_request_d2 <= REG_RET_FUN_request_d2_FUN_request_WR;
     end if;
    end if;
  end process IMPL_REG_RET_FUN_request_d2;
  
  -- Register
  IMPL_REG_ARG_FUN_request_d1: process(
          REG_ARG_FUN_request_d1_main_WR,
          REG_ARG_FUN_request_d1_main_WE,
          REG_ARG_FUN_request_d1,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_ARG_FUN_request_d1_RD <= REG_ARG_FUN_request_d1;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_ARG_FUN_request_d1 <= "00000000";
     elsif REG_ARG_FUN_request_d1_main_WE='1' then
      REG_ARG_FUN_request_d1 <= REG_ARG_FUN_request_d1_main_WR;
     end if;
    end if;
  end process IMPL_REG_ARG_FUN_request_d1;
  
  -- Register
  IMPL_REG_com_timeout: process(
          REG_com_timeout_com_tmo_WR,
          REG_com_timeout_com_tmo_WE,
          REG_com_timeout,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_com_timeout_RD <= REG_com_timeout;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_com_timeout <= '0';
     elsif REG_com_timeout_com_tmo_WE='1' then
      REG_com_timeout <= REG_com_timeout_com_tmo_WR;
     end if;
    end if;
  end process IMPL_REG_com_timeout;
  
  -- Process control
  PRO_CONTROL_main: process(
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_main_ENABLE <= '1'; -- main process activated on reset
      end if;
    end if;
  end process PRO_CONTROL_main;
  
  --
  --  ConPro V2.1.D149 EMI Uart.uart V2.15
  --
  
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_BAUD_GEN: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_BAUD_COUNT)
    variable baud_cnt: std_logic_vector(3 downto 0);
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        baud_cnt := "0000";
        UART_com_BAUD16 <= '0';
      elsif (baud_cnt) = ("0000") then
        UART_com_BAUD16 <= '1';
        baud_cnt := UART_com_BAUD_COUNT;
      else
        baud_cnt := (baud_cnt) - (1);
        UART_com_BAUD16 <= '0';
      end if;
    end if;
  end process UART_com_BAUD_GEN;
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_RX_SAMPLER: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_BAUD16,
    UART_com_RXD)
    variable samples: std_logic_vector(1 downto 0);
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        samples := "11";
        UART_com_RX_SAMPLED <= '1';
      elsif (UART_com_BAUD16) = ('1') then
        samples(1) := samples(0);
        samples(0) := UART_com_RXD;
      end if;
      if (samples) = ("00") then
        UART_com_RX_SAMPLED <= '0';
      end if;
      if (samples) = ("11") then
        UART_com_RX_SAMPLED <= '1';
      end if;
    end if;
  end process UART_com_RX_SAMPLER;
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_RX_CONTROLLER: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_RX_RE,
    UART_com_BAUD16,
    UART_com_RX_BIT_COUNT,
    UART_com_RX_SAMPLED,
    UART_com_RX_BIT_PHASE,
    UART_com_RX_SHIFT,
    UART_com_RX_EN,
    UART_com_RX_COMPL)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        UART_com_RX_COMPL <= '0';
        UART_com_RX_ERR <= '0';
        UART_com_RX_BIT_PHASE <= "0000";
        UART_com_RX_SHIFT <= "00000000";
        UART_com_RX_BIT_COUNT <= "00000";
      elsif (UART_com_RX_RE) = ('1') then
        UART_com_RX_COMPL <= '0';
        UART_com_RX_ERR <= '0';
      end if;
      if (UART_com_BAUD16) = ('1') then
        if ((UART_com_RX_BIT_COUNT) = ("00000")) and (((UART_com_RX_SAMPLED) = ('1')) or ((UART_com_RX_BIT_PHASE) = ("0111"))) then
          UART_com_RX_BIT_PHASE <= "0000";
        else
          UART_com_RX_BIT_PHASE <= (UART_com_RX_BIT_PHASE) + (1);
        end if;
        if (UART_com_RX_BIT_COUNT) = ("00000") then
          if (UART_com_RX_BIT_PHASE) = ("0111") then
            UART_com_RX_BIT_COUNT <= (UART_com_RX_BIT_COUNT) + (1);
          end if;
        elsif (UART_com_RX_BIT_PHASE) = ("1111") then
          UART_com_RX_BIT_COUNT <= (UART_com_RX_BIT_COUNT) + (1);
          if (UART_com_RX_BIT_COUNT) = ("01001") then
            UART_com_RX_BIT_COUNT <= "00000";
            if (UART_com_RX_EN) = ('1') then
              UART_com_RX_COMPL <= '1';
              UART_com_RX_ERR <= (not (UART_com_RX_SAMPLED)) or (UART_com_RX_COMPL);
              if ((UART_com_RX_COMPL) = ('0')) or ((UART_com_RX_RE) = ('1')) then
                UART_com_RX_DATA <= UART_com_RX_SHIFT(7 downto 0);
              end if;
            end if;
          else
            UART_com_RX_SHIFT(6 downto 0) <= UART_com_RX_SHIFT(7 downto 1);
            UART_com_RX_SHIFT(7) <= UART_com_RX_SAMPLED;
          end if;
        end if;
      end if;
    end if;
  end process UART_com_RX_CONTROLLER;
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_TX_SAMPLER: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_BAUD16)
    variable tx_cnt: std_logic_vector(3 downto 0);
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        tx_cnt := "0000";
        UART_com_TX_TICK <= '0';
      elsif (UART_com_BAUD16) = ('1') then
        if (tx_cnt) = ("1111") then
          UART_com_TX_TICK <= '1';
        end if;
        tx_cnt := (tx_cnt) + (1);
      else
        UART_com_TX_TICK <= '0';
      end if;
    end if;
  end process UART_com_TX_SAMPLER;
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_TX_CONTROLLER: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_TX_WE,
    UART_com_TX_EN,
    UART_com_TX_DATA,
    UART_com_TX_TICK,
    UART_com_TX_BIT_COUNT,
    UART_com_TX_DRE,
    UART_com_TX_SHIFT)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        UART_com_TX_COMPL <= '0';
        UART_com_TX_DRE <= '1';
        UART_com_TX_BIT_COUNT <= "00000";
        UART_com_TX_SHIFT <= "000000000";
        UART_com_TXD <= '1';
        UART_com_TX_ERR <= '0';
      else
        if ((UART_com_TX_WE) = ('1')) and ((UART_com_TX_EN) = ('1')) then
          UART_com_TX_DRE <= '0';
          UART_com_TX_COMPL <= '0';
          UART_com_TX_SHIFT(7 downto 0) <= UART_com_TX_DATA;
          UART_com_TX_SHIFT(8) <= '0';
        elsif ((UART_com_TX_WE) = ('1')) and ((UART_com_TX_EN) = ('0')) then
          UART_com_TX_ERR <= '1';
        end if;
      end if;
      if (UART_com_TX_TICK) = ('1') then
        case UART_com_TX_BIT_COUNT is
          when "00000" =>
            if (UART_com_TX_DRE) = ('0') then
              UART_com_TX_BIT_COUNT <= "00001";
            end if;
            UART_com_TXD <= '1';
          when "00001" =>
            UART_com_TXD <= '0';
            UART_com_TX_BIT_COUNT <= "00010";
          when others =>
            UART_com_TX_BIT_COUNT <= (UART_com_TX_BIT_COUNT) + (1);
            if (UART_com_TX_BIT_COUNT) = ("01001") then
              UART_com_TX_DRE <= '1';
              UART_com_TX_BIT_COUNT <= "00000";
              UART_com_TX_COMPL <= '1';
            end if;
            UART_com_TXD <= UART_com_TX_SHIFT(0);
            UART_com_TX_SHIFT(7 downto 0) <= UART_com_TX_SHIFT(8 downto 1);
        end case;
      end if;
    end if;
  end process UART_com_TX_CONTROLLER;
  --
  -- EMI <Object Uart.uart.com> Process
  --
  UART_com_SCHED: process(conpro_system_clk,
    conpro_system_reset,
    UART_com_BUSY,
    UART_com_interpreter_INIT,
    UART_com_interpreter_LOCKed,
    UART_com_com_tx_LOCKed,
    UART_com_com_rx_LOCKed,
    UART_com_interpreter_START,
    UART_com_com_rx_RE,
    UART_com_RX_COMPL,
    UART_com_RX_DATA,
    UART_com_RX_ERR,
    UART_com_com_tx_WE,
    UART_com_TX_COMPL,
    UART_com_TX_ERR,
    UART_com_TX_DRE,
    UART_com_com_tx_WR)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        UART_com_BUSY <= '0';
        UART_com_interpreter_GD <= '1';
        UART_com_com_tx_GD <= '1';
        UART_com_com_rx_GD <= '1';
        UART_com_interpreter_LOCKed <= '0';
        UART_com_com_tx_LOCKed <= '0';
        UART_com_com_rx_LOCKed <= '0';
        UART_com_RX_EN <= '0';
        UART_com_TX_EN <= '0';
        UART_com_RX_RE <= '0';
        UART_com_TX_WE <= '0';
        UART_com_BAUD_COUNT <= "1001";
      elsif (UART_com_BUSY) = ('0') then
        if (UART_com_interpreter_INIT) = ('1') then
          UART_com_interpreter_GD <= '0';
          UART_com_BUSY <= '1';
          if (UART_com_interpreter_LOCKed) = ('1') then
            UART_com_interpreter_LOCKed <= '0';
            UART_com_interpreter_GD <= '0';
          end if;
          if (UART_com_com_tx_LOCKed) = ('1') then
            UART_com_com_tx_LOCKed <= '0';
            UART_com_com_tx_GD <= '0';
          end if;
          if (UART_com_com_rx_LOCKed) = ('1') then
            UART_com_com_rx_LOCKed <= '0';
            UART_com_com_rx_GD <= '0';
          end if;
        elsif (UART_com_interpreter_START) = ('1') then
          UART_com_BUSY <= '1';
          UART_com_interpreter_GD <= '0';
          UART_com_RX_EN <= '1';
          UART_com_TX_EN <= '1';
        elsif (((UART_com_com_rx_RE) = ('1')) and ((UART_com_com_rx_LOCKed) = ('1'))) and ((UART_com_RX_COMPL) = ('1')) then
          UART_com_com_rx_RD <= UART_com_RX_DATA;
          UART_com_com_rx_RD_ERR <= UART_com_RX_ERR;
          UART_com_com_rx_GD <= '0';
          UART_com_com_rx_LOCKed <= '0';
          UART_com_RX_RE <= '1';
          UART_com_BUSY <= '1';
        elsif (((UART_com_com_tx_WE) = ('1')) and ((UART_com_com_tx_LOCKed) = ('1'))) and ((UART_com_TX_COMPL) = ('1')) then
          UART_com_com_tx_WR_ERR <= UART_com_TX_ERR;
          UART_com_com_tx_GD <= '0';
          UART_com_com_tx_LOCKed <= '0';
          UART_com_BUSY <= '1';
        elsif ((UART_com_com_rx_RE) = ('1')) and ((UART_com_com_rx_LOCKed) = ('0')) then
          if (UART_com_RX_COMPL) = ('1') then
            UART_com_com_rx_RD <= UART_com_RX_DATA;
            UART_com_com_rx_RD_ERR <= UART_com_RX_ERR;
            UART_com_com_rx_GD <= '0';
            UART_com_RX_RE <= '1';
            UART_com_BUSY <= '1';
          else
            UART_com_com_rx_LOCKed <= '1';
          end if;
        elsif (((UART_com_com_tx_WE) = ('1')) and ((UART_com_com_tx_LOCKed) = ('0'))) and ((UART_com_TX_DRE) = ('1')) then
          UART_com_TX_DATA <= UART_com_com_tx_WR;
          UART_com_TX_WE <= '1';
          UART_com_BUSY <= '1';
          UART_com_com_tx_LOCKed <= '1';
        end if;
      else
        UART_com_interpreter_GD <= '1';
        UART_com_com_tx_GD <= '1';
        UART_com_com_rx_GD <= '1';
        UART_com_RX_RE <= '0';
        UART_com_TX_WE <= '0';
        UART_com_BUSY <= '0';
      end if;
    end if;
  end process UART_com_SCHED;
  --
  -- EMI <Object Uart.uart.com>
  --
  UART_com_RXD <= dev_io_RX_RD;
  dev_io_TX_WR <= UART_com_TXD;
  --
  -- End of <Object Uart.uart.com>
  --
  
  -- Single Port Queue-RAM Implementation
  IMPL_QRAM_rx_q: process(
          QRAM_rx_q_ADDR_AUX,
          QRAM_rx_q_DIN_AUX,
          QRAM_rx_q_WE_AUX,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk='1' then
     if QRAM_rx_q_WE_AUX = '1' then
      QRAM_rx_q(L_to_N(QRAM_rx_q_ADDR_AUX)) <= QRAM_rx_q_DIN_AUX;
     end if;
     QRAM_rx_q_RD_ADDR <= QRAM_rx_q_ADDR_AUX;
    end if;
  end process IMPL_QRAM_rx_q;
  QRAM_rx_q_DOUT_AUX <= QRAM_rx_q(L_to_N(QRAM_rx_q_RD_ADDR));
  -- Queue scheduler
  IMPL_QUEUE_rx_q: process(
          QUEUE_rx_q_interpreter_RE,
          QUEUE_rx_q_com_rx_WE,
          QUEUE_rx_q_com_tmo_UNLOCK,
          QUEUE_rx_q_ADDR_RD,
          QUEUE_rx_q_ADDR_WR,
          conpro_system_clk,
          conpro_system_reset
          )
    variable wr_next: std_logic_vector(3 downto 0);
    variable rd_next: std_logic_vector(3 downto 0);
  begin
    wr_next := QUEUE_rx_q_ADDR_WR + 1;
    rd_next := QUEUE_rx_q_ADDR_RD + 1;
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0'
      then
        QUEUE_rx_q_com_rx_GD <= '1';
        QUEUE_rx_q_interpreter_GD <= '1';
        QUEUE_rx_q_EMPTY <= '1';
        QUEUE_rx_q_FULL <= '0';
        QUEUE_rx_q_ADDR_RD <= "0000";
        QUEUE_rx_q_ADDR_WR <= "0000";
        QUEUE_rx_q_LOCKED <= '0';
        QRAM_rx_q_WE_AUX <= '0';
        QRAM_rx_q_ADDR_AUX <= "0000";
        QRAM_rx_q_DIN_AUX <= "00000000";
      else
        QRAM_rx_q_ADDR_AUX <= QUEUE_rx_q_ADDR_RD;
        if QUEUE_rx_q_LOCKED = '0' and QUEUE_rx_q_com_rx_WE = '1' and QUEUE_rx_q_FULL = '0' then
          if wr_next = QUEUE_rx_q_ADDR_RD then QUEUE_rx_q_FULL <= '1'; end if;
          QRAM_rx_q_DIN_AUX <= QUEUE_rx_q_com_rx_WR;
          QRAM_rx_q_ADDR_AUX <= QUEUE_rx_q_ADDR_WR;
          QRAM_rx_q_WE_AUX <= '1';
          QUEUE_rx_q_ADDR_WR <= wr_next;
          QUEUE_rx_q_LOCKED <= '1';
          QUEUE_rx_q_com_rx_GD <= '0';
          QUEUE_rx_q_EMPTY <= '0';
        elsif QUEUE_rx_q_LOCKED = '0' and QUEUE_rx_q_interpreter_RE = '1' and QUEUE_rx_q_EMPTY = '0' then
          if rd_next = QUEUE_rx_q_ADDR_WR then QUEUE_rx_q_EMPTY <= '1'; end if;
          QUEUE_rx_q_ADDR_RD <= rd_next;
          QUEUE_rx_q_LOCKED <= '1';
          QUEUE_rx_q_interpreter_GD <= '0';
          QUEUE_rx_q_FULL <= '0';
        elsif (QUEUE_rx_q_LOCKED = '0' and QUEUE_rx_q_com_tmo_UNLOCK = '1') then
          QUEUE_rx_q_com_rx_GD <= '0';
          QUEUE_rx_q_interpreter_GD <= '0';
          QUEUE_rx_q_LOCKED <= '1';
        elsif QUEUE_rx_q_LOCKED = '1' then
          QUEUE_rx_q_LOCKED <= '0';
          QRAM_rx_q_WE_AUX <= '0';
          QUEUE_rx_q_com_rx_GD <= '1';
          QUEUE_rx_q_interpreter_GD <= '1';
          end if;
      end if;
    end if;
  end process IMPL_QUEUE_rx_q;
  QUEUE_rx_q_interpreter_RD <= QRAM_rx_q_DOUT_AUX;
  
  --
  --  ConPro V2.1.D149 EMI Mutex.mutex V2.11
  --
  
  --
  -- EMI <Object Mutex.mutex.LOCK_FUN_request> Process
  --
  MUTEX_LOCK_FUN_request_SCHED: process(conpro_system_clk,
    conpro_system_reset,
    MUTEX_LOCK_FUN_request_main_INIT,
    MUTEX_LOCK_FUN_request_main_LOCKed,
    MUTEX_LOCK_FUN_request_main_LOCK,
    MUTEX_LOCK_FUN_request_LOCKed,
    MUTEX_LOCK_FUN_request_main_UNLOCK)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        MUTEX_LOCK_FUN_request_LOCKed <= '0';
        MUTEX_LOCK_FUN_request_main_GD <= '1';
        MUTEX_LOCK_FUN_request_main_LOCKed <= '0';
      else
        MUTEX_LOCK_FUN_request_main_GD <= '1';
        if (MUTEX_LOCK_FUN_request_main_INIT) = ('1') then
          MUTEX_LOCK_FUN_request_LOCKed <= '0';
          MUTEX_LOCK_FUN_request_main_GD <= '0';
          if (MUTEX_LOCK_FUN_request_main_LOCKed) = ('1') then
            MUTEX_LOCK_FUN_request_main_LOCKed <= '0';
            MUTEX_LOCK_FUN_request_main_GD <= '0';
          end if;
        elsif ((MUTEX_LOCK_FUN_request_main_LOCK) = ('1')) and ((MUTEX_LOCK_FUN_request_LOCKed) = ('0')) then
          MUTEX_LOCK_FUN_request_LOCKed <= '1';
          MUTEX_LOCK_FUN_request_main_LOCKed <= '1';
          MUTEX_LOCK_FUN_request_main_GD <= '0';
        elsif (MUTEX_LOCK_FUN_request_main_UNLOCK) = ('1') then
          MUTEX_LOCK_FUN_request_LOCKed <= '0';
          MUTEX_LOCK_FUN_request_main_LOCKed <= '0';
          MUTEX_LOCK_FUN_request_main_GD <= '0';
        end if;
      end if;
    end if;
  end process MUTEX_LOCK_FUN_request_SCHED;
  --
  -- End of <Object Mutex.mutex.LOCK_FUN_request>
  --
  
  -- Process control
  PRO_CONTROL_FUN_request: process(
          PRO_FUN_request_main_CALL,
          PRO_FUN_request_END,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_FUN_request_ENABLE <= '0';
        PRO_FUN_request_main_GD <= '1';
      elsif PRO_FUN_request_main_CALL = '1' and PRO_FUN_request_END = '1' then
        PRO_FUN_request_main_GD <= '0';
        PRO_FUN_request_ENABLE <= '0';
      elsif PRO_FUN_request_main_CALL = '1' and PRO_FUN_request_END = '0' then
        PRO_FUN_request_ENABLE <= '1';
      else
        PRO_FUN_request_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_FUN_request;
  
  -- Single Port Queue-RAM Implementation
  IMPL_QRAM_tx_q: process(
          QRAM_tx_q_ADDR_AUX,
          QRAM_tx_q_DIN_AUX,
          QRAM_tx_q_WE_AUX,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk='1' then
     if QRAM_tx_q_WE_AUX = '1' then
      QRAM_tx_q(L_to_N(QRAM_tx_q_ADDR_AUX)) <= QRAM_tx_q_DIN_AUX;
     end if;
     QRAM_tx_q_RD_ADDR <= QRAM_tx_q_ADDR_AUX;
    end if;
  end process IMPL_QRAM_tx_q;
  QRAM_tx_q_DOUT_AUX <= QRAM_tx_q(L_to_N(QRAM_tx_q_RD_ADDR));
  -- Queue scheduler
  IMPL_QUEUE_tx_q: process(
          QUEUE_tx_q_com_tx_RE,
          QUEUE_tx_q_FUN_request_WE,
          QUEUE_tx_q_interpreter_WE,
          QUEUE_tx_q_ADDR_RD,
          QUEUE_tx_q_ADDR_WR,
          conpro_system_clk,
          conpro_system_reset
          )
    variable wr_next: std_logic_vector(3 downto 0);
    variable rd_next: std_logic_vector(3 downto 0);
  begin
    wr_next := QUEUE_tx_q_ADDR_WR + 1;
    rd_next := QUEUE_tx_q_ADDR_RD + 1;
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0'
      then
        QUEUE_tx_q_FUN_request_GD <= '1';
        QUEUE_tx_q_interpreter_GD <= '1';
        QUEUE_tx_q_com_tx_GD <= '1';
        QUEUE_tx_q_EMPTY <= '1';
        QUEUE_tx_q_FULL <= '0';
        QUEUE_tx_q_ADDR_RD <= "0000";
        QUEUE_tx_q_ADDR_WR <= "0000";
        QUEUE_tx_q_LOCKED <= '0';
        QRAM_tx_q_WE_AUX <= '0';
        QRAM_tx_q_ADDR_AUX <= "0000";
        QRAM_tx_q_DIN_AUX <= "00000000";
      else
        QRAM_tx_q_ADDR_AUX <= QUEUE_tx_q_ADDR_RD;
        if QUEUE_tx_q_LOCKED = '0' and QUEUE_tx_q_FUN_request_WE = '1' and QUEUE_tx_q_FULL = '0' then
          if wr_next = QUEUE_tx_q_ADDR_RD then QUEUE_tx_q_FULL <= '1'; end if;
          QRAM_tx_q_DIN_AUX <= QUEUE_tx_q_FUN_request_WR;
          QRAM_tx_q_ADDR_AUX <= QUEUE_tx_q_ADDR_WR;
          QRAM_tx_q_WE_AUX <= '1';
          QUEUE_tx_q_ADDR_WR <= wr_next;
          QUEUE_tx_q_LOCKED <= '1';
          QUEUE_tx_q_FUN_request_GD <= '0';
          QUEUE_tx_q_EMPTY <= '0';
        elsif QUEUE_tx_q_LOCKED = '0' and QUEUE_tx_q_interpreter_WE = '1' and QUEUE_tx_q_FULL = '0' then
          if wr_next = QUEUE_tx_q_ADDR_RD then QUEUE_tx_q_FULL <= '1'; end if;
          QRAM_tx_q_DIN_AUX <= QUEUE_tx_q_interpreter_WR;
          QRAM_tx_q_ADDR_AUX <= QUEUE_tx_q_ADDR_WR;
          QRAM_tx_q_WE_AUX <= '1';
          QUEUE_tx_q_ADDR_WR <= wr_next;
          QUEUE_tx_q_LOCKED <= '1';
          QUEUE_tx_q_interpreter_GD <= '0';
          QUEUE_tx_q_EMPTY <= '0';
        elsif QUEUE_tx_q_LOCKED = '0' and QUEUE_tx_q_com_tx_RE = '1' and QUEUE_tx_q_EMPTY = '0' then
          if rd_next = QUEUE_tx_q_ADDR_WR then QUEUE_tx_q_EMPTY <= '1'; end if;
          QUEUE_tx_q_ADDR_RD <= rd_next;
          QUEUE_tx_q_LOCKED <= '1';
          QUEUE_tx_q_com_tx_GD <= '0';
          QUEUE_tx_q_FULL <= '0';
        elsif QUEUE_tx_q_LOCKED = '1' then
          QUEUE_tx_q_LOCKED <= '0';
          QRAM_tx_q_WE_AUX <= '0';
          QUEUE_tx_q_FUN_request_GD <= '1';
          QUEUE_tx_q_interpreter_GD <= '1';
          QUEUE_tx_q_com_tx_GD <= '1';
          end if;
      end if;
    end if;
  end process IMPL_QUEUE_tx_q;
  QUEUE_tx_q_com_tx_RD <= QRAM_tx_q_DOUT_AUX;
  
  --
  --  ConPro V2.1.D149 EMI Event.event V2.06
  --
  
  --
  -- EMI <Object Event.event.rep> Process
  --
  EVENT_rep_SCHED: process(conpro_system_clk,
    conpro_system_reset,
    EVENT_rep_interpreter_INIT,
    EVENT_rep_FUN_request_LOCKed,
    EVENT_rep_FUN_request_AWAIT,
    EVENT_rep_interpreter_WAKEUP)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('0') then
        EVENT_rep_interpreter_GD <= '1';
        EVENT_rep_FUN_request_GD <= '1';
        EVENT_rep_FUN_request_LOCKed <= '0';
      else
        EVENT_rep_interpreter_GD <= '1';
        EVENT_rep_FUN_request_GD <= '1';
        if (EVENT_rep_interpreter_INIT) = ('1') then
          EVENT_rep_interpreter_GD <= '0';
          if (EVENT_rep_FUN_request_LOCKed) = ('1') then
            EVENT_rep_FUN_request_LOCKed <= '0';
            EVENT_rep_FUN_request_GD <= '0';
          end if;
        elsif ((EVENT_rep_FUN_request_AWAIT) = ('1')) and ((EVENT_rep_FUN_request_LOCKed) = ('0')) then
          EVENT_rep_FUN_request_LOCKed <= '1';
        elsif (EVENT_rep_interpreter_WAKEUP) = ('1') then
          if (EVENT_rep_interpreter_WAKEUP) = ('1') then
            EVENT_rep_interpreter_GD <= '0';
          end if;
          if (EVENT_rep_FUN_request_LOCKed) = ('1') then
            EVENT_rep_FUN_request_LOCKed <= '0';
            EVENT_rep_FUN_request_GD <= '0';
          end if;
        end if;
      end if;
    end if;
  end process EVENT_rep_SCHED;
  --
  -- End of <Object Event.event.rep>
  --
  
  -- Process control
  PRO_CONTROL_com_rx: process(
          PRO_com_rx_interpreter_START,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '0' then
        PRO_com_rx_ENABLE <= '0';
        PRO_com_rx_interpreter_GD <= '1';
      elsif PRO_com_rx_interpreter_START = '1' then
        PRO_com_rx_ENABLE <= '1';
        PRO_com_rx_interpreter_GD <= '0';
      else
        PRO_com_rx_interpreter_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_com_rx;
  
  -- Register
  IMPL_REG_rep_d: process(
          REG_rep_d_interpreter_WR,
          REG_rep_d_interpreter_WE,
          REG_rep_d,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_rep_d_RD <= REG_rep_d;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='0' then
      REG_rep_d <= "00000000";
     elsif REG_rep_d_interpreter_WE='1' then
      REG_rep_d <= REG_rep_d_interpreter_WR;
     end if;
    end if;
  end process IMPL_REG_rep_d;
  
  
  -- Process instantiations
  PRO_MAP_sys_status_proc: com_sys_status_proc port map(
    REG_sys_status_RD => REG_sys_status_RD,
    REG_sys_status_WR => REG_sys_status_sys_status_proc_WR,
    REG_sys_status_WE => REG_sys_status_sys_status_proc_WE,
    REG_sys_status_GD => REG_sys_status_sys_status_proc_GD,
    REG_stat_led_WR => REG_stat_led_sys_status_proc_WR,
    REG_stat_led_WE => REG_stat_led_sys_status_proc_WE,
    REG_sys_status_next_RD => REG_sys_status_next_RD,
    REG_sys_status_next_WR => REG_sys_status_next_sys_status_proc_WR,
    REG_sys_status_next_WE => REG_sys_status_next_sys_status_proc_WE,
    REG_sys_status_next_GD => REG_sys_status_next_sys_status_proc_GD,
    TIMER_watch_timer_INIT => TIMER_watch_timer_sys_status_proc_INIT,
    TIMER_watch_timer_AWAIT => TIMER_watch_timer_sys_status_proc_AWAIT,
    TIMER_watch_timer_START => TIMER_watch_timer_sys_status_proc_START,
    TIMER_watch_timer_GD => TIMER_watch_timer_sys_status_proc_GD,
    PRO_sys_status_proc_ENABLE => PRO_sys_status_proc_ENABLE,
    PRO_sys_status_proc_END => PRO_sys_status_proc_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_com_tmo: com_com_tmo port map(
    REG_com_timeout_WR => REG_com_timeout_com_tmo_WR,
    REG_com_timeout_WE => REG_com_timeout_com_tmo_WE,
    QUEUE_rx_q_UNLOCK => QUEUE_rx_q_com_tmo_UNLOCK,
    QUEUE_rx_q_GD => QUEUE_rx_q_com_tmo_GD,
    PRO_com_tmo_ENABLE => PRO_com_tmo_ENABLE,
    PRO_com_tmo_END => PRO_com_tmo_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_com_rx: com_com_rx port map(
    REG_sys_status_WR => REG_sys_status_com_rx_WR,
    REG_sys_status_WE => REG_sys_status_com_rx_WE,
    REG_sys_status_GD => REG_sys_status_com_rx_GD,
    UART_com_RE => UART_com_com_rx_RE,
    UART_com_RD => UART_com_com_rx_RD,
    UART_com_RD_ERR => UART_com_com_rx_RD_ERR,
    UART_com_GD => UART_com_com_rx_GD,
    QUEUE_rx_q_WR => QUEUE_rx_q_com_rx_WR,
    QUEUE_rx_q_WE => QUEUE_rx_q_com_rx_WE,
    QUEUE_rx_q_GD => QUEUE_rx_q_com_rx_GD,
    PRO_com_rx_ENABLE => PRO_com_rx_ENABLE,
    PRO_com_rx_END => PRO_com_rx_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_com_tx: com_com_tx port map(
    UART_com_WE => UART_com_com_tx_WE,
    UART_com_WR => UART_com_com_tx_WR,
    UART_com_WR_ERR => UART_com_com_tx_WR_ERR,
    UART_com_GD => UART_com_com_tx_GD,
    QUEUE_tx_q_RD => QUEUE_tx_q_com_tx_RD,
    QUEUE_tx_q_RE => QUEUE_tx_q_com_tx_RE,
    QUEUE_tx_q_GD => QUEUE_tx_q_com_tx_GD,
    PRO_com_tx_ENABLE => PRO_com_tx_ENABLE,
    PRO_com_tx_END => PRO_com_tx_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_interpreter: com_interpreter port map(
    REG_sys_status_WR => REG_sys_status_interpreter_WR,
    REG_sys_status_WE => REG_sys_status_interpreter_WE,
    REG_sys_status_GD => REG_sys_status_interpreter_GD,
    REG_sys_status_next_WR => REG_sys_status_next_interpreter_WR,
    REG_sys_status_next_WE => REG_sys_status_next_interpreter_WE,
    REG_sys_status_next_GD => REG_sys_status_next_interpreter_GD,
    PRO_com_rx_START => PRO_com_rx_interpreter_START,
    PRO_com_rx_GD => PRO_com_rx_interpreter_GD,
    REG_com_timeout_RD => REG_com_timeout_RD,
    UART_com_INIT => UART_com_interpreter_INIT,
    UART_com_START => UART_com_interpreter_START,
    UART_com_GD => UART_com_interpreter_GD,
    PRO_com_tmo_START => PRO_com_tmo_interpreter_START,
    PRO_com_tmo_STOP => PRO_com_tmo_interpreter_STOP,
    PRO_com_tmo_GD => PRO_com_tmo_interpreter_GD,
    QUEUE_rx_q_RD => QUEUE_rx_q_interpreter_RD,
    QUEUE_rx_q_RE => QUEUE_rx_q_interpreter_RE,
    QUEUE_rx_q_GD => QUEUE_rx_q_interpreter_GD,
    QUEUE_tx_q_WR => QUEUE_tx_q_interpreter_WR,
    QUEUE_tx_q_WE => QUEUE_tx_q_interpreter_WE,
    QUEUE_tx_q_GD => QUEUE_tx_q_interpreter_GD,
    PRO_com_tx_START => PRO_com_tx_interpreter_START,
    PRO_com_tx_GD => PRO_com_tx_interpreter_GD,
    EVENT_rep_INIT => EVENT_rep_interpreter_INIT,
    EVENT_rep_WAKEUP => EVENT_rep_interpreter_WAKEUP,
    EVENT_rep_GD => EVENT_rep_interpreter_GD,
    REG_rep_d_WR => REG_rep_d_interpreter_WR,
    REG_rep_d_WE => REG_rep_d_interpreter_WE,
    PRO_interpreter_ENABLE => PRO_interpreter_ENABLE,
    PRO_interpreter_END => PRO_interpreter_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_FUN_request: com_FUN_request port map(
    REG_RET_FUN_request_d2_WR => REG_RET_FUN_request_d2_FUN_request_WR,
    REG_RET_FUN_request_d2_WE => REG_RET_FUN_request_d2_FUN_request_WE,
    REG_ARG_FUN_request_d1_RD => REG_ARG_FUN_request_d1_RD,
    QUEUE_tx_q_WR => QUEUE_tx_q_FUN_request_WR,
    QUEUE_tx_q_WE => QUEUE_tx_q_FUN_request_WE,
    QUEUE_tx_q_GD => QUEUE_tx_q_FUN_request_GD,
    EVENT_rep_AWAIT => EVENT_rep_FUN_request_AWAIT,
    EVENT_rep_GD => EVENT_rep_FUN_request_GD,
    REG_rep_d_RD => REG_rep_d_RD,
    PRO_FUN_request_ENABLE => PRO_FUN_request_ENABLE,
    PRO_FUN_request_END => PRO_FUN_request_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_main: com_main port map(
    PRO_interpreter_START => PRO_interpreter_main_START,
    PRO_interpreter_GD => PRO_interpreter_main_GD,
    PRO_sys_status_proc_START => PRO_sys_status_proc_main_START,
    PRO_sys_status_proc_GD => PRO_sys_status_proc_main_GD,
    REG_RET_FUN_request_d2_RD => REG_RET_FUN_request_d2_RD,
    REG_ARG_FUN_request_d1_WR => REG_ARG_FUN_request_d1_main_WR,
    REG_ARG_FUN_request_d1_WE => REG_ARG_FUN_request_d1_main_WE,
    MUTEX_LOCK_FUN_request_INIT => MUTEX_LOCK_FUN_request_main_INIT,
    MUTEX_LOCK_FUN_request_LOCK => MUTEX_LOCK_FUN_request_main_LOCK,
    MUTEX_LOCK_FUN_request_UNLOCK => MUTEX_LOCK_FUN_request_main_UNLOCK,
    MUTEX_LOCK_FUN_request_GD => MUTEX_LOCK_FUN_request_main_GD,
    PRO_FUN_request_CALL => PRO_FUN_request_main_CALL,
    PRO_FUN_request_GD => PRO_FUN_request_main_GD,
    PRO_main_ENABLE => PRO_main_ENABLE,
    PRO_main_END => PRO_main_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  
  -- Toplevel assignments
  -- Monitors
  stat_led_RD <= REG_stat_led;
  dev_io_RX_RD <= dev_io_RX;
  dev_io_TX <= dev_io_TX_WR;
  conpro_system_clk <= CLK;
  conpro_system_reset <= RESET;
end main;
