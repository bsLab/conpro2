--
-- Automatically generated by
-- CONPRO: Hardware Synthesis with an Imperative High Level Multiprocess Approach
--         (c) 2006-2009 by BSSLAB, Dr. Stefan Bosse
--         Version: 2.1 Revision: D133 Genetic size: 2558806
--         Compile date: Fri Jan  8 10:17:58 CET 2010
--         Compiled by:  sbosse
--         Compiled on:  SunOS sunsil 5.10 Generic_137137-09 sun4u sparc SUNW,Sun-Blade-2500

-- Implementation of Module <R>.
--
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;
use work.ConPRO.all;
entity MOD_r is
port(
  -- Connections to the outside world
  signal d_RD: out std_logic_vector(7 downto 0);
  signal MON_PRO_p1_ENABLE: out std_logic;
  signal MON_PRO_p1_state: out std_logic_vector(2 downto 0);
  signal MON_PRO_p2_ENABLE: out std_logic;
  signal MON_PRO_p2_state: out std_logic_vector(3 downto 0);
  signal CLK: in std_logic;
  signal RESET: in std_logic
);
end MOD_r;
architecture main of MOD_r is
  -- Process instances
  component r_p1
  port(
    -- Connections to external objects, components and the outside world
    signal MON_PRO_p1_state: out std_logic_vector(2 downto 0);
    signal RAM_ram1_WR: out std_logic_vector(7 downto 0);
    signal RAM_ram1_WE: out std_logic;
    signal RAM_ram1_ADDR: out std_logic_vector(3 downto 0);
    signal RAM_ram1_GD: in std_logic;
    signal PRO_p1_ENABLE: in std_logic;
    signal PRO_p1_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component r_p2
  port(
    -- Connections to external objects, components and the outside world
    signal MON_PRO_p2_state: out std_logic_vector(3 downto 0);
    signal RAM_ram1_WR: out std_logic_vector(7 downto 0);
    signal RAM_ram1_WE: out std_logic;
    signal RAM_ram1_RD: in std_logic_vector(7 downto 0);
    signal RAM_ram1_RE: out std_logic;
    signal RAM_ram1_ADDR: out std_logic_vector(3 downto 0);
    signal RAM_ram1_GD: in std_logic;
    signal PRO_p2_ENABLE: in std_logic;
    signal PRO_p2_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component r_main
  port(
    -- Connections to external objects, components and the outside world
    signal REG_d_WR: out signed(7 downto 0);
    signal REG_d_WE: out std_logic;
    signal PRO_p1_CALL: out std_logic;
    signal PRO_p1_GD: in std_logic;
    signal PRO_p2_CALL: out std_logic;
    signal PRO_p2_GD: in std_logic;
    signal PRO_main_ENABLE: in std_logic;
    signal PRO_main_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  -- Local and temporary data objects
  signal REG_d: signed(7 downto 0);
  signal REG_d_main_WR: signed(7 downto 0);
  signal REG_d_main_WE: std_logic;
  signal PRO_main_ENABLE: std_logic;
  signal PRO_main_END: std_logic;
  type RAM_ram1_TYPE is array (0 to 15) of std_logic_vector(7 downto 0);
  signal RAM_ram1_p2_RE: std_logic;
  signal RAM_ram1_p2_RD: std_logic_vector(7 downto 0);
  signal RAM_ram1_p1_WE: std_logic;
  signal RAM_ram1_p1_WR: std_logic_vector(7 downto 0);
  signal RAM_ram1_p2_WE: std_logic;
  signal RAM_ram1_p2_WR: std_logic_vector(7 downto 0);
  signal RAM_ram1_p1_ADDR: std_logic_vector(3 downto 0);
  signal RAM_ram1_p1_GD: std_logic;
  signal RAM_ram1_p2_ADDR: std_logic_vector(3 downto 0);
  signal RAM_ram1_p2_GD: std_logic;
  signal RAM_ram1_ENABLE: std_logic;
  signal RAM_ram1_WRITE: std_logic;
  signal RAM_ram1_COMPL: std_logic;
  signal RAM_ram1_ADDRSEL: std_logic_vector(3 downto 0);
  signal RAM_ram1_DATA_IN: std_logic_vector(7 downto 0);
  signal RAM_ram1_DATA_OUT: std_logic_vector(7 downto 0);
  signal RAM_ram1: RAM_ram1_TYPE;
  signal RAM_ram1_BUSY: std_logic;
  signal RAM_ram1_p1_LOCKed: std_logic;
  signal RAM_ram1_p2_LOCKed: std_logic;
  signal PRO_p1_ENABLE: std_logic;
  signal PRO_p1_END: std_logic;
  signal PRO_p1_main_CALL: std_logic;
  signal PRO_p1_main_GD: std_logic;
  signal PRO_p2_ENABLE: std_logic;
  signal PRO_p2_END: std_logic;
  signal PRO_p2_main_CALL: std_logic;
  signal PRO_p2_main_GD: std_logic;
  -- State Processing
  -- Aux. signals
  signal conpro_system_clk: std_logic;
  signal conpro_system_reset: std_logic;
begin
  -- Module implementation
  -- Register
  IMPL_REG_d: process(
          REG_d_main_WR,
          REG_d_main_WE,
          REG_d,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='1' then
      REG_d <= to_signed(0,8);
     elsif REG_d_main_WE='1' then
      REG_d <= REG_d_main_WR;
     end if;
    end if;
  end process IMPL_REG_d;
  
  -- Process control
  PRO_CONTROL_main: process(
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '1' then
        PRO_main_ENABLE <= '1'; -- main process activated on reset
      end if;
    end if;
  end process PRO_CONTROL_main;
  
  --
  --  ConPro V2.1.D133 EMI Ram.ram V2.09
  --
  
  --
  -- EMI <Object Ram.ram.ram1> Process
  --
  RAM_ram1_RAM_IMPL: process(conpro_system_clk,
    RAM_ram1_ENABLE,
    RAM_ram1_WRITE,
    RAM_ram1_DATA_IN,
    RAM_ram1,
    RAM_ram1_COMPL,
    conpro_system_reset)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (RAM_ram1_ENABLE) = ('1') then
        if (RAM_ram1_WRITE) = ('1') then
          RAM_ram1((L_to_N(RAM_ram1_ADDRSEL))) <= RAM_ram1_DATA_IN;
        end if;
        RAM_ram1_DATA_OUT <= RAM_ram1((L_to_N(RAM_ram1_ADDRSEL)));
        RAM_ram1_COMPL <= '1';
      end if;
      if ((RAM_ram1_COMPL) = ('1')) or ((conpro_system_reset) = ('1')) then
        RAM_ram1_COMPL <= '0';
      end if;
    end if;
  end process RAM_ram1_RAM_IMPL;
  --
  -- EMI <Object Ram.ram.ram1> Process
  --
  RAM_ram1_SCHED: process(RAM_ram1_p2_LOCKed,
    RAM_ram1_COMPL,
    RAM_ram1_DATA_OUT,
    RAM_ram1_p1_LOCKed,
    RAM_ram1_p2_RE,
    RAM_ram1_p2_ADDR,
    RAM_ram1_p1_WE,
    RAM_ram1_p1_WR,
    RAM_ram1_p1_ADDR,
    RAM_ram1_p2_WE,
    RAM_ram1_p2_WR,
    conpro_system_clk,
    conpro_system_reset)
  begin
    RAM_ram1_p1_GD <= '1';
    RAM_ram1_p2_GD <= '1';
    RAM_ram1_DATA_IN <= "00000000";
    RAM_ram1_ADDRSEL <= "0000";
    RAM_ram1_ENABLE <= '0';
    RAM_ram1_WRITE <= '0';
    if ((RAM_ram1_p2_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
      RAM_ram1_p2_RD <= RAM_ram1_DATA_OUT;
      RAM_ram1_p2_GD <= '0';
    elsif ((RAM_ram1_p1_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
      RAM_ram1_p1_GD <= '0';
    elsif ((RAM_ram1_p2_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
      RAM_ram1_p2_GD <= '0';
    elsif (((RAM_ram1_p2_RE) = ('1')) and ((RAM_ram1_p2_LOCKed) = ('0'))) and ((RAM_ram1_COMPL) = ('0')) then
      RAM_ram1_ENABLE <= '1';
      RAM_ram1_ADDRSEL <= RAM_ram1_p2_ADDR;
    elsif (((RAM_ram1_p1_WE) = ('1')) and ((RAM_ram1_p1_LOCKed) = ('0'))) and ((RAM_ram1_COMPL) = ('0')) then
      RAM_ram1_DATA_IN <= RAM_ram1_p1_WR;
      RAM_ram1_ADDRSEL <= RAM_ram1_p1_ADDR;
      RAM_ram1_ENABLE <= '1';
      RAM_ram1_WRITE <= '1';
    elsif (((RAM_ram1_p2_WE) = ('1')) and ((RAM_ram1_p2_LOCKed) = ('0'))) and ((RAM_ram1_COMPL) = ('0')) then
      RAM_ram1_DATA_IN <= RAM_ram1_p2_WR;
      RAM_ram1_ADDRSEL <= RAM_ram1_p2_ADDR;
      RAM_ram1_ENABLE <= '1';
      RAM_ram1_WRITE <= '1';
    end if;
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('1') then
        RAM_ram1_p1_LOCKed <= '0';
        RAM_ram1_p2_LOCKed <= '0';
      else
        if ((RAM_ram1_p2_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
          RAM_ram1_p2_LOCKed <= '0';
        elsif ((RAM_ram1_p1_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
          RAM_ram1_p1_LOCKed <= '0';
        elsif ((RAM_ram1_p2_LOCKed) = ('1')) and ((RAM_ram1_COMPL) = ('1')) then
          RAM_ram1_p2_LOCKed <= '0';
        elsif ((RAM_ram1_p2_RE) = ('1')) and ((RAM_ram1_p2_LOCKed) = ('0')) then
          RAM_ram1_p2_LOCKed <= '1';
        elsif ((RAM_ram1_p1_WE) = ('1')) and ((RAM_ram1_p1_LOCKed) = ('0')) then
          RAM_ram1_p1_LOCKed <= '1';
        elsif ((RAM_ram1_p2_WE) = ('1')) and ((RAM_ram1_p2_LOCKed) = ('0')) then
          RAM_ram1_p2_LOCKed <= '1';
        end if;
      end if;
    end if;
  end process RAM_ram1_SCHED;
  --
  -- End of <Object Ram.ram.ram1>
  --
  
  -- Process control
  PRO_CONTROL_p1: process(
          PRO_p1_main_CALL,
          PRO_p1_END,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '1' then
        PRO_p1_ENABLE <= '0';
        PRO_p1_main_GD <= '1';
      elsif PRO_p1_main_CALL = '1' and PRO_p1_END = '1' then
        PRO_p1_main_GD <= '0';
        PRO_p1_ENABLE <= '0';
      elsif PRO_p1_main_CALL = '1' and PRO_p1_END = '0' then
        PRO_p1_ENABLE <= '1';
      else
        PRO_p1_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_p1;
  
  -- Process control
  PRO_CONTROL_p2: process(
          PRO_p2_main_CALL,
          PRO_p2_END,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '1' then
        PRO_p2_ENABLE <= '0';
        PRO_p2_main_GD <= '1';
      elsif PRO_p2_main_CALL = '1' and PRO_p2_END = '1' then
        PRO_p2_main_GD <= '0';
        PRO_p2_ENABLE <= '0';
      elsif PRO_p2_main_CALL = '1' and PRO_p2_END = '0' then
        PRO_p2_ENABLE <= '1';
      else
        PRO_p2_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_p2;
  
  
  -- Process instantiations
  PRO_MAP_p1: r_p1 port map(
    MON_PRO_p1_state => MON_PRO_p1_state,
    RAM_ram1_WR => RAM_ram1_p1_WR,
    RAM_ram1_WE => RAM_ram1_p1_WE,
    RAM_ram1_ADDR => RAM_ram1_p1_ADDR,
    RAM_ram1_GD => RAM_ram1_p1_GD,
    PRO_p1_ENABLE => PRO_p1_ENABLE,
    PRO_p1_END => PRO_p1_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_p2: r_p2 port map(
    MON_PRO_p2_state => MON_PRO_p2_state,
    RAM_ram1_WR => RAM_ram1_p2_WR,
    RAM_ram1_WE => RAM_ram1_p2_WE,
    RAM_ram1_RD => RAM_ram1_p2_RD,
    RAM_ram1_RE => RAM_ram1_p2_RE,
    RAM_ram1_ADDR => RAM_ram1_p2_ADDR,
    RAM_ram1_GD => RAM_ram1_p2_GD,
    PRO_p2_ENABLE => PRO_p2_ENABLE,
    PRO_p2_END => PRO_p2_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_main: r_main port map(
    REG_d_WR => REG_d_main_WR,
    REG_d_WE => REG_d_main_WE,
    PRO_p1_CALL => PRO_p1_main_CALL,
    PRO_p1_GD => PRO_p1_main_GD,
    PRO_p2_CALL => PRO_p2_main_CALL,
    PRO_p2_GD => PRO_p2_main_GD,
    PRO_main_ENABLE => PRO_main_ENABLE,
    PRO_main_END => PRO_main_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  
  -- Toplevel assignments
  -- Monitors
  d_RD <= std_logic_vector(REG_d);
  MON_PRO_p1_ENABLE <= PRO_p1_ENABLE;
  MON_PRO_p2_ENABLE <= PRO_p2_ENABLE;
  conpro_system_clk <= CLK;
  conpro_system_reset <= RESET;
end main;
