--
-- Automatically generated by
-- CONPRO: Hardware Synthesis with an Imperative High Level Multiprocess Approach
--         (c) 2006-2010 by BSSLAB, Dr. Stefan Bosse
--         Version: 2.1 Revision: D149 Genetic size: 2681183
--         Compile date: Wed Apr 28 16:29:24 CEST 2010
--         Compiled by:  sbosse
--         Compiled on:  SunOS sunsil 5.10 Generic_137137-09 sun4u sparc SUNW,Sun-Blade-2500

-- Implementation of Module <T>.
--
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;
use work.ConPRO.all;
entity MOD_t is
port(
  -- Connections to the outside world
  signal x: out signed(9 downto 0);
  signal y: out signed(9 downto 0);
  signal rl: in std_logic_vector(9 downto 0);
  signal CLK: in std_logic;
  signal RESET: in std_logic
);
end MOD_t;
architecture main of MOD_t is
  -- Process instances
  component t_p1
  port(
    -- Connections to external objects, components and the outside world
    signal REG_d_RD: in signed(9 downto 0);
    signal REG_d_WR: out signed(9 downto 0);
    signal REG_d_WE: out std_logic;
    signal x_WR: out signed(9 downto 0);
    signal y_WR: out signed(9 downto 0);
    signal F_f1_RE: out std_logic;
    signal F_f1_RD: in std_logic_vector(9 downto 0);
    signal F_f1_GD: in std_logic;
    signal F_f1_WE: out std_logic;
    signal F_f1_TIME_SET: out std_logic_vector(2 downto 0);
    signal RAM_b_WR: out std_logic_vector(7 downto 0);
    signal RAM_b_WE: out std_logic;
    signal RAM_b_RD: in std_logic_vector(7 downto 0);
    signal RAM_b_RE: out std_logic;
    signal RAM_b_ADDR: out std_logic_vector(1 downto 0);
    signal RAM_b_GD: in std_logic;
    signal PRO_p1_ENABLE: in std_logic;
    signal PRO_p1_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  component t_main
  port(
    -- Connections to external objects, components and the outside world
    signal rl_RD: in std_logic_vector(9 downto 0);
    signal PRO_p1_START: out std_logic;
    signal PRO_p1_GD: in std_logic;
    signal F_f1_INIT: out std_logic;
    signal F_f1_GD: in std_logic;
    signal F_f1_WE: out std_logic;
    signal F_f1_TIME_SET: out std_logic_vector(2 downto 0);
    signal PRO_main_ENABLE: in std_logic;
    signal PRO_main_END: out std_logic;
    signal conpro_system_clk: in std_logic;
    signal conpro_system_reset: in std_logic
  );
  end component;
  -- Local and temporary data objects
  signal REG_d: signed(9 downto 0);
  signal REG_d_RD: signed(9 downto 0);
  signal REG_d_p1_WR: signed(9 downto 0);
  signal REG_d_p1_WE: std_logic;
  signal x_WR: signed(9 downto 0);
  signal y_WR: signed(9 downto 0);
  signal PRO_main_ENABLE: std_logic;
  signal PRO_main_END: std_logic;
  signal rl_RD: std_logic_vector(9 downto 0);
  signal PRO_p1_ENABLE: std_logic;
  signal PRO_p1_END: std_logic;
  signal PRO_p1_main_START: std_logic;
  signal PRO_p1_main_GD: std_logic;
  constant v1: integer := 32;
  constant V: integer := 16;
  constant REQ: integer := 1;
  constant REP: integer := 2;
  type pro_states is (S_pat_1_start,
    S_i1_fun,
    S_i2_assign,
    S_i3_assign,
    S_i5_branch,
    S_i6_for_loop);
  type ARRAY_pat_counter_TYPE is array (0 to 3) of std_logic_vector(11 downto 0);
  type ARRAY_pat_main_counter_TYPE is array (0 to 3) of std_logic_vector(11 downto 0);
  type ARRAY_pat_p1_counter_TYPE is array (0 to 3) of std_logic_vector(11 downto 0);
  signal F_f1_d_in: std_logic;
  signal F_f1_data_shift: std_logic_vector(9 downto 0);
  signal F_f1_data: std_logic_vector(9 downto 0);
  signal F_f1_shift: std_logic;
  signal F_f1_init: std_logic;
  signal F_avail: std_logic;
  signal F_f1_p1_RE: std_logic;
  signal F_f1_p1_RD: std_logic_vector(9 downto 0);
  signal F_f1_main_INIT: std_logic;
  signal F_f1_main_GD: std_logic;
  signal F_f1_p1_GD: std_logic;
  signal F_f1_main_TIME_SET: std_logic_vector(2 downto 0);
  signal F_f1_p1_TIME_SET: std_logic_vector(2 downto 0);
  signal ARRAY_pat_counter: ARRAY_pat_counter_TYPE;
  signal F_f1_timer: std_logic_vector(9 downto 0);
  signal F_f1_count: std_logic_vector(3 downto 0);
  type RAM_b_TYPE is array (0 to 3) of std_logic_vector(7 downto 0);
  signal RAM_b_p1_RE: std_logic;
  signal RAM_b_p1_RD: std_logic_vector(7 downto 0);
  signal RAM_b_p1_WE: std_logic;
  signal RAM_b_p1_WR: std_logic_vector(7 downto 0);
  signal RAM_b_p1_ADDR: std_logic_vector(1 downto 0);
  signal RAM_b_p1_GD: std_logic;
  signal RAM_b_ENABLE: std_logic;
  signal RAM_b_WRITE: std_logic;
  signal RAM_b_COMPL: std_logic;
  signal RAM_b_ADDRSEL: std_logic_vector(1 downto 0);
  signal RAM_b_DATA_IN: std_logic_vector(7 downto 0);
  signal RAM_b_DATA_OUT: std_logic_vector(7 downto 0);
  signal RAM_b: RAM_b_TYPE;
  signal RAM_b_BUSY: std_logic;
  signal RAM_b_p1_LOCKed: std_logic;
  -- State Processing
  -- Aux. signals
  signal conpro_system_clk: std_logic;
  signal conpro_system_reset: std_logic;
begin
  -- Module implementation
  -- Register
  IMPL_REG_d: process(
          REG_d_p1_WR,
          REG_d_p1_WE,
          REG_d,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    REG_d_RD <= REG_d;
    if conpro_system_clk'event and conpro_system_clk='1' then
     if conpro_system_reset='1' then
      REG_d <= to_signed(0,10);
     elsif REG_d_p1_WE='1' then
      REG_d <= REG_d_p1_WR;
     end if;
    end if;
  end process IMPL_REG_d;
  
  -- Process control
  PRO_CONTROL_main: process(
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '1' then
        PRO_main_ENABLE <= '1'; -- main process activated on reset
      end if;
    end if;
  end process PRO_CONTROL_main;
  
  -- Process control
  PRO_CONTROL_p1: process(
          PRO_p1_main_START,
          conpro_system_clk,
          conpro_system_reset
          )
  begin
    if conpro_system_clk'event and conpro_system_clk = '1' then
      if conpro_system_reset = '1' then
        PRO_p1_ENABLE <= '0';
        PRO_p1_main_GD <= '1';
      elsif PRO_p1_main_START = '1' then
        PRO_p1_ENABLE <= '1';
        PRO_p1_main_GD <= '0';
      else
        PRO_p1_main_GD <= '1';
      end if;
    end if;
  end process PRO_CONTROL_p1;
  
  --
  --  ConPro V2.1.D149 EMI F.f V?
  --
  
  --
  -- EMI <Object F.f.f1> Process
  --
  RANDOM: process(cmd,
    pro_state,
    S_p1_start,
    S_i1_for_loop,
    CONST_I5_1,
    S_i1_for_loop_cond,
    S_i2_fun,
    S_i3_bind_to_4,
    S_i1_for_loop_incr,
    LOOP_i_0,
    S_p1_end)
  begin
    case cmd is
      when "00000001" =>
        x <= '1';
      when "00000010" =>
        x <= '0';
    end case;
    case pro_state is
      when S_p1_start =>
        null;
      when S_i1_for_loop =>
        LOOP_i_0 <= CONST_I5_1;
      when S_i1_for_loop_cond =>
        LOOP_i_0 <= "00100000";
        LOOP_i_0 <= "00010000";
        LOOP_i_0 <= signed'("00100000");
      when S_i2_fun =>
        null;
      when S_i3_bind_to_4 =>
        null;
      when S_i1_for_loop_incr =>
        LOOP_i_0 <= (LOOP_i_0) + (CONST_I5_1);
      when S_p1_end =>
        null;
    end case;
  end process RANDOM;
  --
  -- EMI <Object F.f.f1> Process
  --
  RANDOM_f1_SCHED: process(conpro_system_clk,
    conpro_system_reset,
    F_f1_init,
    F_f1_main_INIT,
    F_f1_p1_RE,
    F_f1_avail,
    F_f1_data)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('1') then
        F_f1_shift <= '0';
        F_f1_init <= '0';
        F_f1_main_GD <= '1';
        F_f1_p1_GD <= '1';
      else
        F_f1_main_GD <= '1';
        F_f1_p1_GD <= '1';
        if (F_f1_init) = ('1') then
          F_f1_init <= '0';
        elsif (F_f1_main_INIT) = ('1') then
          F_f1_init <= '1';
          F_f1_main_GD <= '0';
        elsif (F_f1_p1_RE) = ('1') then
          F_f1_shift <= '1';
          if (F_f1_avail) = ('1') then
            F_f1_p1_RD <= F_f1_data;
            F_f1_p1_GD <= '0';
            F_f1_shift <= '0';
          end if;
        else  
          F_f1_shift <= '0';
        end if;
      end if;
    end if;
  end process RANDOM_f1_SCHED;
  --
  -- EMI <Object F.f.f1> Process
  --
  RANDOM_f1: process(conpro_system_clk,
    conpro_system_reset,
    F_f1_init,
    F_f1_shift,
    F_f1_d_in,
    F_f1_data_shift,
    F_f1_count)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if ((conpro_system_reset) = ('1')) or ((F_f1_init) = ('1')) then
        F_f1_data_shift <= "1111111111";
        F_f1_data <= rl_RD;
        F_f1_count(F_f1_count'high downto F_f1_count'low) <= "0000";
        for i in F_f1_count'high downto F_f1_count'low loop
          F_f1_count(i) <= '0';
        end loop;
        F_f1_avail <= '0';
      elsif (F_f1_shift) = ('1') then
        F_f1_data_shift <= (F_f1_d_in) & (F_f1_data_shift(9 downto 1));
        F_f1_count <= (F_f1_count) + (1);
        if (F_f1_count) = ("1001") then
          F_f1_avail <= '1';
          F_f1_data <= F_f1_data_shift;
        else
          F_f1_avail <= '0';
        end if;
      end if;
    end if;
  end process RANDOM_f1;
  --
  -- EMI <Object F.f.f1> Process
  --
  TIMER_f1: process(F_f1_TIME_SET)
  begin
    if (F_f1_TIME_SET) = ("000") then
      F_f1_timer <= "0010011100010000";
    elsif (F_f1_TIME_SET) = ("001") then
      F_f1_timer <= "0000110101000000";
    elsif (F_f1_TIME_SET) = ("010") then
      F_f1_timer <= "1001001111100000";
    elsif (F_f1_TIME_SET) = ("011") then
      F_f1_timer <= "0001101010000000";
    elsif (F_f1_TIME_SET) = ("100") then
      F_f1_timer <= "1000011010100000";
    end if;
  end process TIMER_f1;
  --
  -- EMI <Object F.f.f1>
  --
  F_f1_d_in <= (F_f1_data_shift(2)) xor (F_f1_data_shift(9));
  --
  -- End of <Object F.f.f1>
  --
  
  --
  --  ConPro V2.1.D149 EMI Ram.ram V2.11
  --
  
  --
  -- EMI <Object Ram.ram.b> Process
  --
  RAM_b_RAM_IMPL: process(conpro_system_clk,
    RAM_b_ENABLE,
    RAM_b_WRITE,
    RAM_b_DATA_IN,
    RAM_b,
    RAM_b_COMPL,
    conpro_system_reset)
  begin
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (RAM_b_ENABLE) = ('1') then
        if (RAM_b_WRITE) = ('1') then
          RAM_b((L_to_N(RAM_b_ADDRSEL))) <= RAM_b_DATA_IN;
        end if;
        RAM_b_DATA_OUT <= RAM_b((L_to_N(RAM_b_ADDRSEL)));
        RAM_b_COMPL <= '1';
      end if;
      if ((RAM_b_COMPL) = ('1')) or ((conpro_system_reset) = ('1')) then
        RAM_b_COMPL <= '0';
      end if;
    end if;
  end process RAM_b_RAM_IMPL;
  --
  -- EMI <Object Ram.ram.b> Process
  --
  RAM_b_SCHED: process(RAM_b_p1_LOCKed,
    RAM_b_COMPL,
    RAM_b_DATA_OUT,
    RAM_b_p1_RE,
    RAM_b_p1_ADDR,
    RAM_b_p1_WE,
    RAM_b_p1_WR,
    conpro_system_clk,
    conpro_system_reset)
  begin
    RAM_b_p1_GD <= '1';
    RAM_b_p1_RD <= "00000000";
    RAM_b_DATA_IN <= "00000000";
    RAM_b_ADDRSEL <= "00";
    RAM_b_ENABLE <= '0';
    RAM_b_WRITE <= '0';
    if ((RAM_b_p1_LOCKed) = ('1')) and ((RAM_b_COMPL) = ('1')) then
      RAM_b_p1_RD <= RAM_b_DATA_OUT;
      RAM_b_p1_GD <= '0';
    elsif ((RAM_b_p1_LOCKed) = ('1')) and ((RAM_b_COMPL) = ('1')) then
      RAM_b_p1_GD <= '0';
    elsif (((RAM_b_p1_RE) = ('1')) and ((RAM_b_p1_LOCKed) = ('0'))) and ((RAM_b_COMPL) = ('0')) then
      RAM_b_ENABLE <= '1';
      RAM_b_ADDRSEL <= RAM_b_p1_ADDR;
    elsif (((RAM_b_p1_WE) = ('1')) and ((RAM_b_p1_LOCKed) = ('0'))) and ((RAM_b_COMPL) = ('0')) then
      RAM_b_DATA_IN <= RAM_b_p1_WR;
      RAM_b_ADDRSEL <= RAM_b_p1_ADDR;
      RAM_b_ENABLE <= '1';
      RAM_b_WRITE <= '1';
    end if;
    if (conpro_system_clk'event) and ((conpro_system_clk) = ('1')) then
      if (conpro_system_reset) = ('1') then
        RAM_b_p1_LOCKed <= '0';
      else
        if ((RAM_b_p1_LOCKed) = ('1')) and ((RAM_b_COMPL) = ('1')) then
          RAM_b_p1_LOCKed <= '0';
        elsif ((RAM_b_p1_LOCKed) = ('1')) and ((RAM_b_COMPL) = ('1')) then
          RAM_b_p1_LOCKed <= '0';
        elsif ((RAM_b_p1_RE) = ('1')) and ((RAM_b_p1_LOCKed) = ('0')) then
          RAM_b_p1_LOCKed <= '1';
        elsif ((RAM_b_p1_WE) = ('1')) and ((RAM_b_p1_LOCKed) = ('0')) then
          RAM_b_p1_LOCKed <= '1';
        end if;
      end if;
    end if;
  end process RAM_b_SCHED;
  --
  -- End of <Object Ram.ram.b>
  --
  
  
  -- Process instantiations
  PRO_MAP_p1: t_p1 port map(
    REG_d_RD => REG_d_RD,
    REG_d_WR => REG_d_p1_WR,
    REG_d_WE => REG_d_p1_WE,
    x_WR => x_WR,
    y_WR => y_WR,
    F_f1_RE => F_f1_p1_RE,
    F_f1_RD => F_f1_p1_RD,
    F_f1_GD => F_f1_p1_GD,
    F_f1_WE => F_f1_p1_WE,
    F_f1_TIME_SET => F_f1_p1_TIME_SET,
    RAM_b_WR => RAM_b_p1_WR,
    RAM_b_WE => RAM_b_p1_WE,
    RAM_b_RD => RAM_b_p1_RD,
    RAM_b_RE => RAM_b_p1_RE,
    RAM_b_ADDR => RAM_b_p1_ADDR,
    RAM_b_GD => RAM_b_p1_GD,
    PRO_p1_ENABLE => PRO_p1_ENABLE,
    PRO_p1_END => PRO_p1_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  PRO_MAP_main: t_main port map(
    rl_RD => rl_RD,
    PRO_p1_START => PRO_p1_main_START,
    PRO_p1_GD => PRO_p1_main_GD,
    F_f1_INIT => F_f1_main_INIT,
    F_f1_GD => F_f1_main_GD,
    F_f1_WE => F_f1_main_WE,
    F_f1_TIME_SET => F_f1_main_TIME_SET,
    PRO_main_ENABLE => PRO_main_ENABLE,
    PRO_main_END => PRO_main_END,
    conpro_system_clk => conpro_system_clk,
    conpro_system_reset => conpro_system_reset
  );
  
  -- Toplevel assignments
  -- Monitors
  x <= x_WR;
  y <= y_WR;
  rl_RD <= rl;
  conpro_system_clk <= CLK;
  conpro_system_reset <= RESET;
end main;
