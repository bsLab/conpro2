(*
**      ==================================
**      OOOO   OOOO OOOO  O      O   OOOO
**      O   O  O    O     O     O O  O   O
**      O   O  O    O     O     O O  O   O
**      OOOO   OOOO OOOO  O     OOO  OOOO
**      O   O     O    O  O    O   O O   O
**      O   O     O    O  O    O   O O   O
**      OOOO   OOOO OOOO  OOOO O   O OOOO
**      ================================== 
**      BSSLAB, Dr. Stefan Bosse, http://www.bsslab.de
**
**      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED BY BSSLAB.
**                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
**                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
**                 OUTSIDE OF THE SOFTWARE SYSTEM.
**
**    $AUTHORS:     Stefan Bosse
**    $INITIAL:     (C) 2006-2014 BSSLAB
**    $CREATED:     16.5.2006
**    $VERSION:     2.14
**
**    $INFO:
**
**  CONPRO Module 
**
**    $ENDOFINFO
**
*)

open Cp_version
open Cp_common
open Cp_data
open Cp_symbol
open Cp_types
open Cp_utils
open Cp_analysis
open Cp_Core
open Cp_process
open Cp_alu
open Printf

(*
*******************************
** Behaviour Modules (RTL)
*******************************
*)

(*
** Emit module port header
*)   
let vhdl_port modu  =
    an.a_curpos <- nilsrc();
    let tops = ref [] in
    let main = List.mem Mod_main modu.mod_flags in
    let vhdl_ind = ref 0 in
    let strl = ref [] in
    let vhdl str =
        let spaces n =
            String.make n ' ' in
        strl := !strl @ [(spaces !vhdl_ind)^str]
        in
            
    vhdl "port(";
    (*
    ** Entity port declaration: Signal connect
    *)
    vhdl_ind := 2;
    if not main then
        vhdl "-- Connections to external objects, components and the outside world"
    else
        vhdl "-- Connections to the outside world";

    List.iter (fun sym ->
            let is_mon,is_debug,sym' = get_mon sym in
            match sym' with
            | Sym_obj obj ->
                let ports',tops'=(get_rules obj).rl_obj_port
                                sym modu None in
                tops := !tops @ tops';
                List.iter (fun str -> vhdl str) ports';
            | Sym_block db ->
                let ports',tops'= Cp_Core.rules.rl_obj_port   
                                sym modu None in
                tops := !tops @ tops';
                List.iter (fun str -> vhdl str) ports';
            | Sym_pro pro' ->
                if is_mon then
                begin
                    let states = get_state_names pro' in
                    let len = const_width (V_int (i64 (List.length states))) in
                    vhdl (sprintf "signal MON_PRO_%s_state: out %s_vector(%d downto 0);"
                          pro'.pro_name (get_env_str "logic_type")
                          (len-1));
                    vhdl (sprintf "signal MON_PRO_%s_enable: out %s;"
                          pro'.pro_name (get_env_str "logic_type"));
                end;
            | _ -> ();
          ) (list_of_sym modu.mod_export);


    (*
    ** Always present
    *)
    
    if not main then
    begin
        vhdl (sprintf "signal conpro_system_clk: in %s;"
                      (get_env_str "logic_type"));
        vhdl (sprintf "signal conpro_system_reset: in %s"
                      (get_env_str "logic_type"));
    end
    else
    begin
        vhdl (sprintf "signal CLK: in %s%s"
                      (get_env_str "logic_type")
                      (if not (get_env_bool "reset_internal") then ";" else ""));
        if not (get_env_bool "reset_internal") then
          vhdl (sprintf "signal RESET: in %s"
                        (get_env_str "logic_type"));
    end;

    vhdl_ind := 0;
    vhdl ");";
    !strl, !tops

    
(*
** Synthesize one module with all its processes inside.
*)
let vhdl_synth modu =
  out_ (sprintf "Synthesizing VHDL-RTL for module <%s>..." modu.mod_name);
  an.a_curpos <- nilsrc();
  let mn = modu.mod_name in
  let mod_main = List.mem Mod_main modu.mod_flags in
  let top_expr = ref [] in
  let top_def = ref [] in
  
  try
  begin

    (*
    ** Create for each process a separate entity and file
    *)
    List.iter (fun pro ->
        let pro = Cp_process.pro pro in
        pro#vhdl_synth;
      ) modu.mod_procs;
    
    (*
    ** Now module itself
    *)
    let en = of_mod mn in
    let ar = "main" in
    let fn = en^".vhdl" in
    
    out_ (sprintf "Creating library <conpro.vhdl>...");
    if not compiler.t_check then
    begin
        try
          vhdl_oc := open_out (sprintf "%sconpro.vhdl" compiler.t_output)
        with _ ->
          error 0 (sprintf "Can't open file <%sconpro.vhdl>." compiler.t_output);

    end;

    vhdl "--";
    vhdl "-- Automatically generated by";
    vhdl vhdl_version;
    vhdl (sprintf "-- ConPro VHDL Library." );
    vhdl "--";

    List.iter (fun l -> vhdl l) (ieee ());

    List.iter (fun l ->
      vhdl l;
      ) compiler.t_synth_tool.syn_vhdl_lib;

    if not compiler.t_check then
        close_out !vhdl_oc;
    vhdl_oc := Pervasives.stdout;


    out_ (sprintf "Creating entity <%s>..." fn);
    ind_incr ();


    if not compiler.t_check then
    begin
        try
          vhdl_oc := open_out (sprintf "%s%s" compiler.t_output fn)
        with _ ->
          error 0 (sprintf "Can't open file <%s%s>." compiler.t_output fn);
        
    end;

    let mod_pro = module_pro_main modu  in

    let obj_n = ref 0 in
    List.iter (fun sym ->
            match sym with
            | Sym_obj obj -> incr obj_n;
            | Sym_block _ -> incr obj_n;
            | Sym_pro _ -> incr obj_n;
            | _ -> ();
          ) (list_of_sym modu.mod_objs);
    out_ (sprintf "Synthesizing VHDL-RTL for toplevel <%s> ..." modu.mod_name);

    let el,dl = Cp_Core.top_code modu (Some mod_pro) in
    top_expr := !top_expr @ el;
    top_def := !top_def @ dl;

    vhdl "--";
    vhdl "-- Automatically generated by";
    vhdl vhdl_version;
    vhdl (sprintf "-- Implementation of Module <%s>." mn);
    vhdl "--";

    List.iter (fun l -> vhdl l) (ieee ());

    if compiler.t_synth_tool.syn_vhdl_lib <> [] then vhdl "use work.ConPRO.all;";
    vhdl (sprintf "entity MOD_%s is" en);

    let ports',tops' = vhdl_port modu in
    List.iter (fun line -> vhdl line) ports';
    top_expr := !top_expr @ tops';
    
    
    vhdl (sprintf "end MOD_%s;" en);
    vhdl (sprintf "architecture %s of MOD_%s is" ar en);
    (*
    ** Architecture declaration: Object creation 
    *)
    vhdl_incr ();
    vhdl "-- Process instances";

    List.iter (fun pro ->
        let pro = Cp_process.pro pro in

        let main = pro#name = "main" in
        vhdl (sprintf "component %s_%s" (of_mod modu.mod_name) pro#name);
        let ports',tops',port_bits = pro#vhdl_port in
        List.iter (fun line -> vhdl line) ports';
        vhdl (sprintf "end component;");
        ) modu.mod_procs;

    vhdl "-- Local and temporary data objects";
    
    List.iter (fun sym ->
            match sym with
            | Sym_obj obj ->
                let s,t = (get_rules obj).rl_obj_decl sym modu None in
                List.iter (fun str -> vhdl str) s;
                top_expr := !top_expr @ t;                  
            | Sym_block obj ->
                let s,t = Cp_Core.rules.rl_obj_decl sym modu None in
                List.iter (fun str -> vhdl str) s;
                top_expr := !top_expr @ t;                  
            | Sym_pro pro ->
                let s,t = Cp_Process.rules.rl_obj_decl sym modu None in
                List.iter (fun str -> vhdl str) s;
                top_expr := !top_expr @ t;                                  
            | _ -> ();
          ) (list_of_sym modu.mod_objs);
    
    vhdl "-- State Processing";
    
    vhdl "-- Aux. signals";
    List.iter (fun line -> vhdl line) !top_def;
    if mod_main then
    begin
        vhdl (sprintf "signal conpro_system_clk: %s;"
                      (get_env_str "logic_type"));
        vhdl (sprintf "signal conpro_system_reset: %s;"
                      (get_env_str "logic_type"));
    end;
    if (get_env_bool "reset_internal") then
    begin
      vhdl (sprintf "signal RESET: %s;" (get_env_str "logic_type"));
      vhdl (sprintf "type RESET_STATES is (RESET_S0,RESET_S1,RESET_S2,RESET_S3);");
      vhdl (sprintf "signal RESET_STATE: RESET_STATES := RESET_S0;");
    end;  
    vhdl_decr ();
    vhdl "begin";
    (*
    ** Process/Entity Content
    *)
    vhdl_incr ();
    vhdl "-- Module implementation";


    (*
    ** Object implementations
    *)
    let n = ref 0 in
    if compiler.t_notty then out_("  Synthesizing objects...");
    List.iter (fun sym ->
            
            match sym with
            | Sym_obj obj ->
                incr n;
                if compiler.t_silent && not compiler.t_notty then progress "  object" !n !obj_n;
                if compiler.t_silent && compiler.t_notty && (!n mod 10 = 0) then out_ (sprintf "  [%d/%d]" !n !obj_n);
                List.iter (fun str -> vhdl str)
                          ((get_rules obj).rl_obj_code 
                                sym modu None);
            | Sym_block _ ->
                incr n;
                if compiler.t_silent && not compiler.t_notty then progress "  object" !n !obj_n;
                if compiler.t_silent && compiler.t_notty && (!n mod 10 = 0) then out_ (sprintf "  [%d/%d]" !n !obj_n);
                List.iter (fun str -> vhdl str)
                          (Cp_Core.rules.rl_obj_code
                                sym modu None);
            | Sym_pro _ ->
                incr n;
                if compiler.t_silent && not compiler.t_notty then progress "  object" !n !obj_n;
                if compiler.t_silent && compiler.t_notty && (!n mod 10 = 0) then out_ (sprintf "  [%d/%d]" !n !obj_n);
                List.iter (fun str -> vhdl str)
                          (Cp_Process.rules.rl_obj_code
                                sym modu None);
            | _ -> ();
          ) (list_of_sym modu.mod_objs);
    (*
    ** Toplevel instructions and process instantiations.
    *)
    vhdl "";
    vhdl "-- Process instantiations";
    List.iter (fun pro ->
        let pro = Cp_process.pro pro in
        List.iter (fun line -> vhdl line) pro#vhdl_map;
        ) modu.mod_procs;

    vhdl "";
    vhdl "-- Toplevel assignments";
    vhdl "-- Monitors";
    List.iter (fun top -> vhdl top) !top_expr;
        
    
    if mod_main then
    begin
        vhdl "conpro_system_clk <= CLK;";
        vhdl "conpro_system_reset <= RESET;";
    end;
    if (get_env_bool "reset_internal") then
    begin
      vhdl "RESET_CTRL:process(conpro_system_clk,RESET_STATE)";
      vhdl "begin";
      vhdl (sprintf "  if conpro_system_clk'event and conpro_system_clk = '%d' then" (get_env_int "clock_level"));
      vhdl "    case RESET_STATE is";
      vhdl (sprintf "      when RESET_S0 => RESET <= '%d'; RESET_STATE <= RESET_S1;" (if (get_env_int "reset_level") = 0 then 1 else 0));
      vhdl (sprintf "      when RESET_S1 => RESET <= '%d'; RESET_STATE <= RESET_S2;" (if (get_env_int "reset_level") = 0 then 0 else 1));
      vhdl (sprintf "      when RESET_S2 => RESET <= '%d'; RESET_STATE <= RESET_S3;" (if (get_env_int "reset_level") = 0 then 0 else 1));
      vhdl (sprintf "      when RESET_S3 => RESET <= '%d'; RESET_STATE <= RESET_S3;" (if (get_env_int "reset_level") = 0 then 1 else 0));
      vhdl "    end case;";
      vhdl "  end if;";
      vhdl "end process;";      
    end;


    vhdl_decr (); 
    vhdl (sprintf "end %s;" ar);
    if not compiler.t_check then
        close_out !vhdl_oc;
    vhdl_oc := Pervasives.stdout;
    ind_decr ();
  end
  with
    | Synthesis str when !debug_it_select_list = [] -> 
        out (sprintf "\nSynthesizing of module <%s> failed:\n %s"
                                    mn str); exit 1

class modu modu =
  object (self)    
  method name = modu.mod_name
  method vhdl_synth = vhdl_synth modu
  method vhdl_port = vhdl_port modu
  method uc_synth = 
    try
    begin
      an.a_curpos <- nilsrc();
      out "Synthesizing process instructions...";
      ind_incr ();

      List.iter (fun pro -> 
        out_ (sprintf "Synthesizing uCode for process <%s>..." pro.pro_name);
        let pro = Cp_process.pro pro in
        pro#uc_synth) modu.mod_procs;
        
      let rec iter mll =
          List.iter (fun md ->
               List.iter (fun pro -> 
                  let pro = Cp_process.pro pro in
                  pro#uc_synth) md.mod_procs;
            ) mll;
          in
      iter modu.mod_external;
      ind_decr ()
   end
   with 
      | Synthesis str when not compiler.t_trace ->
        raise (Synthesis (sprintf "Synthesis failure:\n%s" str));
      | Exit when not compiler.t_trace ->
        raise Exit;  
      | _ when not compiler.t_trace -> 
        raise (Synthesis "Synthesis failed: Unknown error! Check for removed objects!")
  method compile = Cp_emi.compile_module modu
end

let modu_tab = Hashtbl.create 100

let modu modu =
  if Hashtbl.mem modu_tab modu.mod_name then
    Hashtbl.find modu_tab modu.mod_name 
  else
  begin
    let modu = new modu modu in
    Hashtbl.add modu_tab modu#name modu;
    modu
  end 



(*
*******************************
** Architecture Modules (no RTL)
*******************************
*)

let emit_modu modu =
  an.a_curpos <- nilsrc();
  let mn = modu.mod_name in
  let en = of_mod mn in
  let ar = "main" in
  let fn = en^".vhdl" in
  out_ (sprintf "Emitting architecture module <%s>..." mn);
  ind_incr ();
  (*
  ** Build export list from imported modules
  *)
  let connects = ref [] in
  let connect = ref [] in
  let tsl = 
    List.map (fun sym ->
      match sym with
      | Sym_type (Type_struct ts) -> 
        ts
      | _ -> progerr "Sym_type") (
      List.filter (fun sym ->
        match sym with
        | Sym_type (Type_struct _) -> true
        | _ -> false ) (list_of_sym modu.mod_objs)) in
  let csl = 
    List.map (fun sym ->
      match sym with
      | Sym_obj (OT_component st) -> st
      | _ -> progerr "Sym_obj") (
      List.filter (fun sym ->
        match sym with
        | Sym_obj (OT_component st) -> true
        | _ -> false ) (list_of_sym modu.mod_objs)) in
  let msl = 
    List.filter (fun st ->
      let is_mod = sym_check_mod modu.mod_import st.st_type.ts_name in
      if not is_mod then connect := !connect @ [st];
      is_mod
      ) csl in
  out_ (sprintf "Found %d component(s) and %d imported module instantiation(s)." 
                (List.length csl) (List.length msl));

  
  let is_connected ot =
    let name = name_of_ot ot in
    let rec search otl =
      match otl with
      | (OT_signal co) :: tl ->
        if name = co.co_name then true
        else search tl
      | [] -> false 
      | otl -> search otl in
    let rec iter csl =
      match csl with
      | st :: tl -> if search st.st_connect then true
                    else iter tl;
      | [] -> false in
    iter csl in
  let eol =
    List.flatten (List.map (fun st ->
      let modu' = sym_get_mod modu.mod_import st.st_type.ts_name in
      List.flatten (List.map (fun sym ->
        match sym with
        | Sym_obj ot ->
        begin
          match ot with
          | OT_signal co ->
            let co' = {co with co_name = sprintf "%s_%s" st.st_name co.co_name} in
            [co.co_name,OT_signal co'];
          | OT_reg co ->
            let co' = {co with co_name = sprintf "%s_%s" st.st_name co.co_name} in
            [co.co_name,OT_reg co'];
          | OT_struct st' -> 
            let st'' = {st' with 
              st_name = sprintf "%s_%s" st.st_name st'.st_name;
              st_objs = (List.map (fun ot' ->
                match ot' with
                | OT_signal co -> OT_signal {co with co_name = sprintf "%s_%s" st.st_name co.co_name};
                | OT_reg co -> OT_reg {co with co_name = sprintf "%s_%s" st.st_name co.co_name};
                | _ -> error 0 (sprintf "Unexpected object type in structure <%s_%s> found." 
                                        st.st_type.ts_name st'.st_name);

                ) st'.st_objs);} in
            [st''.st_name,OT_struct st''];
          | OT_component st' ->
            let st'' = {st' with 
              st_name = sprintf "%s_%s" st.st_name st'.st_name;
              st_objs = (List.map (fun ot' ->
                match ot' with
                | OT_signal co -> OT_signal {co with co_name = sprintf "%s_%s" st.st_name co.co_name};
                | _ -> error 0 (sprintf "Unexpected object type in component <%s_%s> found." 
                                        st.st_type.ts_name st'.st_name);

                ) st'.st_objs);} in
            [st''.st_name,OT_component st''];
          | _ -> [];
        end;
        | Sym_mon (b,Sym_obj (OT_object ao)) -> 
        begin
          let pro_name = ao.ao_name in
          let pro' = sym_get_pro modu'.mod_objs pro_name in
          sym_add modu.mod_export (Sym_mon (b,Sym_obj (OT_object {ao with ao_name=sprintf "%s_%s" st.st_name ao.ao_name})));
          sym_add modu.mod_objs (Sym_pro {pro' with pro_name=sprintf "%s_%s" st.st_name pro'.pro_name});
          [];
        end;
        | _ -> []
        ) (list_of_sym modu'.mod_export));
      ) msl) in
  List.iter (fun (name,ot) ->
    match ot with
    | OT_reg _ | OT_signal _ ->
      sym_add modu.mod_export (Sym_obj ot);
    | OT_struct st ->
      sym_add modu.mod_export (Sym_obj (OT_struct {st with st_name=of_mod st.st_name;
                                                                   st_objs=st.st_objs}));      
    | OT_component st ->
      let stobjs = List.filter (fun ot' ->
        if is_connected ot' then 
        begin
          connects := !connects @ [ot'];
          false
        end
        else true
        ) st.st_objs in
      if stobjs <> [] then
        sym_add modu.mod_export (Sym_obj (OT_component {st with st_name=of_mod st.st_name;
                                                                st_objs=stobjs}));
    | _-> ()) eol;


  
    
  out_ (sprintf "Creating entity <%s>..." fn);
  if not compiler.t_check then
  begin
      try
        vhdl_oc := open_out (sprintf "%s%s" compiler.t_output fn)
      with _ ->
        error 0 (sprintf "Can't open file <%s%s>." compiler.t_output fn);

  end;


  vhdl "--";
  vhdl "-- Automatically generated by";
  vhdl vhdl_version;
  vhdl (sprintf "-- Implementation of Module <%s>." mn);
  vhdl "--";

  List.iter (fun l -> vhdl l) (ieee ());

  vhdl (sprintf "entity MOD_%s is" en);

  let ports',tops' = vhdl_port modu in
  List.iter (fun line -> vhdl line) ports';


  vhdl (sprintf "end MOD_%s;" en);
  vhdl (sprintf "architecture %s of MOD_%s is" ar en);
  vhdl_incr ();
  List.iter (fun ot ->
    match ot with
    | OT_signal co -> vhdl (sprintf "signal %s: %s;" co.co_name (obj_decl_type co.co_type));
    | _ -> ()
    ) !connects;
  List.iter (fun ts ->
    let mod_name' = ts.ts_name in
    if sym_check_mod modu.mod_import mod_name' then
    begin
      let modu' = sym_get_mod modu.mod_import mod_name' in
      let ports',tops' = vhdl_port modu' in
      vhdl (sprintf "component MOD_%s" (of_mod mod_name'));
      List.iter (fun p -> vhdl p) ports';
      vhdl "end component;";
    end;
    ) tsl;
  List.iter (fun ts ->
    if not (sym_check_mod modu.mod_import ts.ts_name) then
    begin
      let st = List.find (fun st -> st.st_type = ts) csl in
      let strip name = Str.replace_first (Str.regexp (sprintf "%s_" st.st_name)) "" name in
      let obj = OT_component st in
      let ports',tops' =  (get_some !core_rules).rl_obj_port (Sym_obj obj) modu None in
      vhdl (sprintf "component %s" st.st_type.ts_name);
      vhdl "port(";
      vhdl_incr ();
      List.iter (fun p -> vhdl (strip p)) ports';
      vhdl (sprintf "signal CLK: in %s%s"
                    (get_env_str "logic_type")
                    (if not (get_env_bool "reset_internal") then ";" else ""));
      if not (get_env_bool "reset_internal") then
        vhdl (sprintf "signal RESET: in %s"
                      (get_env_str "logic_type"));
      vhdl_decr ();
      vhdl ");";
      vhdl "end component;";
    end;
    ) tsl;
  vhdl_decr (); 
  vhdl "begin";
  vhdl_incr ();
  vhdl "-- Module instantiation";
  List.iter (fun st ->
    let strip name = Str.replace_first (Str.regexp (sprintf "%s_" st.st_name)) "" name in
    let fix name = Str.replace_first (Str.regexp (sprintf "%s_MON_PRO" st.st_name)) 
                                     (sprintf "MON_PRO_%s" st.st_name) name in
    vhdl (sprintf "%s: MOD_%s port map(" st.st_name (of_mod st.st_type.ts_name));
    vhdl_incr ();
    List.iter (fun ot ->
      match ot with
      | OT_signal co -> vhdl (sprintf "%s => %s," (strip co.co_name) (fix co.co_name));
      | _ -> ();
      ) st.st_objs;
    vhdl "CLK => CLK,";
    vhdl "RESET => RESET";
    vhdl_decr ();
    vhdl ");";
    ) msl;
  List.iter (fun st ->
    let strip name = Str.replace_first (Str.regexp (sprintf "%s_" st.st_name)) "" name in
    vhdl (sprintf "%s: %s port map(" st.st_name st.st_type.ts_name);
    vhdl_incr ();
    List.iter2 (fun ot ot' ->
      let lhs = 
        match ot with
        | OT_signal co -> strip co.co_name;
        | _ -> "" in
      let rhs = 
        match ot' with
        | OT_signal co -> co.co_name;
        | _ -> "" in
      vhdl (sprintf "%s => %s," lhs rhs);
      ) st.st_objs st.st_connect;
    vhdl "CLK => CLK,";
    vhdl "RESET => RESET";
    vhdl_decr ();
    vhdl ");";
    ) !connect;
  vhdl_decr ();
  vhdl (sprintf "end %s;" ar);
  if not compiler.t_check then
      close_out !vhdl_oc;
  vhdl_oc := Pervasives.stdout;
  (*
  ** Create interconnect entity if any
  *)
  List.iter (fun ts ->
    if not (sym_check_mod modu.mod_import ts.ts_name) then
    begin
      let st = List.find (fun st -> st.st_type = ts) csl in
      let strip name = Str.replace_first (Str.regexp (sprintf "%s_" st.st_name)) "" name in
      let obj = OT_component st in
      let ports',tops' =  (get_some !core_rules).rl_obj_port (Sym_obj obj) modu None in
      let en = ts.ts_name in
      let fn = sprintf "%s.vhdl" en in
      let ar = "main" in
      let ports = List.length ts.ts_elems in
      let maps = List.length (List.filter (fun pi -> match pi with PI_map _ -> true | _ -> false) modu.mod_instr) in
      out_ (sprintf "Creating entity <%s>%s..." en (if maps <> ports then sprintf " [found partial interconnect %d < %d]" maps ports
                                                   else "")); 
      if not compiler.t_check then
      begin
        (*
        ** Don't overwrite existing component if there are any
        ** unmapped signals (custom component)
        *)
          try
          begin
            if ports = maps then
              vhdl_oc := open_out (sprintf "%s%s" compiler.t_output fn)
            else
            begin
              let exist = protects(__(Unix.stat (sprintf "%s%s" compiler.t_output fn))) in
              if not exist then
                vhdl_oc := open_out (sprintf "%s%s" compiler.t_output fn)
              else
              begin
                vhdl_oc := open_out (sprintf "%s%s_1.vhdl" compiler.t_output en);
                out_ (sprintf "Keeping existing %s, creating %s_1.vhdl instead." fn en);
              end;
            end;
          end
          with _ ->
            error 0 (sprintf "Can't open file <%s%s>." compiler.t_output fn);

      end;
      vhdl "--";
      vhdl "-- Automatically generated by";
      vhdl vhdl_version;
      vhdl (sprintf "-- Implementation of Interconnect <%s>." en);
      vhdl "--";

      List.iter (fun l -> vhdl l) (ieee ());

      vhdl (sprintf "entity %s is" en);
      vhdl "port(";
      vhdl_incr ();
      List.iter (fun p -> vhdl (strip p)) ports';
      vhdl (sprintf "signal CLK: in %s%s"
                    (get_env_str "logic_type")
                    (if not (get_env_bool "reset_internal") then ";" else ""));
      if not (get_env_bool "reset_internal") then
        vhdl (sprintf "signal RESET: in %s"
                      (get_env_str "logic_type"));
      vhdl_decr ();
      vhdl ");";
      vhdl (sprintf "end %s;" en);
      vhdl (sprintf "architecture %s of %s is" ar en);
      vhdl_incr ();
      let s_dt dt =
        let dt,_ = dt in
        obj_decl_type dt in
        
      List.iter (fun te ->
        match te.te_port with
        | Some PT_in -> 
          vhdl (sprintf "signal IC_%s: %s;" te.te_name (s_dt te.te_type));
        | _ -> (); 
        ) ts.ts_elems;
      vhdl_decr ();
      vhdl "begin";
      vhdl_incr ();
      List.iter (fun te ->
        match te.te_port with
        | Some PT_in -> 
          vhdl (sprintf "IC_%s <= %s;" te.te_name te.te_name)
        | _ -> (); 
        ) ts.ts_elems;
      List.iter (fun pi ->
        match pi with
        | PI_map (src,lhs,rhs) ->
          let lhs = 
            match lhs with
            | PI_obj(_,OT_signal co) -> strip co.co_name;
            | _ -> "" in
          let rhs = 
            match rhs with
            | PI_obj(_,OT_signal co) -> strip co.co_name;
            | _ -> "" in
          vhdl (sprintf "%s <= IC_%s;" lhs rhs);
        | _ -> ();
        ) modu.mod_instr;
      vhdl_decr ();
      vhdl (sprintf "end %s;" ar);
      if not compiler.t_check then
          close_out !vhdl_oc;
      vhdl_oc := Pervasives.stdout;
    end;
    ) tsl;
  
  ind_decr ();
  (*
  ** Finally fix model type name (Module L -> VHDL entity l!)
  *)
  List.iter (fun st ->
    st.st_type.ts_name <- of_mod st.st_type.ts_name; 
    ) msl;
